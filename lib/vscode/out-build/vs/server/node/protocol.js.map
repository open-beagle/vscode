{"version":3,"file":"protocol.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/server/node/protocol.ts"],"names":[],"mappings":"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","sourcesContent":["import { field, logger, Logger } from '@coder/logger';\nimport * as net from 'net';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { PersistentProtocol } from 'vs/base/parts/ipc/common/ipc.net';\nimport { NodeSocket, WebSocketNodeSocket } from 'vs/base/parts/ipc/node/ipc.net';\nimport { AuthRequest, ConnectionTypeRequest, HandshakeMessage } from 'vs/platform/remote/common/remoteAgentConnection';\n\nexport interface SocketOptions {\n\t/** The token is how we identify and connect to existing sessions. */\n\treadonly reconnectionToken: string;\n\t/** Specifies that the client is trying to reconnect. */\n\treadonly reconnection: boolean;\n\t/** If true assume this is not a web socket (always false for code-server). */\n\treadonly skipWebSocketFrames: boolean;\n\t/** Whether to support compression (web socket only). */\n\treadonly permessageDeflate?: boolean;\n\t/**\n\t * Seed zlib with these bytes (web socket only). If parts of inflating was\n\t * done in a different zlib instance we need to pass all those bytes into zlib\n\t * otherwise the inflate might hit an inflated portion referencing a distance\n\t * too far back.\n\t */\n\treadonly inflateBytes?: VSBuffer;\n}\n\nexport class Protocol extends PersistentProtocol {\n\tprivate readonly logger: Logger;\n\n\tpublic constructor(socket: net.Socket, public readonly options: SocketOptions) {\n\t\tsuper(\n\t\t\toptions.skipWebSocketFrames\n\t\t\t\t? new NodeSocket(socket)\n\t\t\t\t: new WebSocketNodeSocket(\n\t\t\t\t\tnew NodeSocket(socket),\n\t\t\t\t\toptions.permessageDeflate || false,\n\t\t\t\t\toptions.inflateBytes || null,\n\t\t\t\t\t// Always record inflate bytes if using permessage-deflate.\n\t\t\t\t\toptions.permessageDeflate || false,\n\t\t\t\t),\n\t\t);\n\n\t\tthis.logger = logger.named('protocol', field('token', this.options.reconnectionToken));\n\t}\n\n\tpublic getUnderlyingSocket(): net.Socket {\n\t\tconst socket = this.getSocket();\n\t\treturn socket instanceof NodeSocket\n\t\t\t? socket.socket\n\t\t\t: (socket as WebSocketNodeSocket).socket.socket;\n\t}\n\n\t/**\n\t * Perform a handshake to get a connection request.\n\t */\n\tpublic handshake(): Promise<ConnectionTypeRequest> {\n\t\tthis.logger.debug('Initiating handshake...');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst cleanup = () => {\n\t\t\t\thandler.dispose();\n\t\t\t\tonClose.dispose();\n\t\t\t\tclearTimeout(timeout);\n\t\t\t};\n\n\t\t\tconst onClose = this.onSocketClose(() => {\n\t\t\t\tcleanup();\n\t\t\t\tthis.logger.debug('Handshake failed');\n\t\t\t\treject(new Error('Protocol socket closed unexpectedly'));\n\t\t\t});\n\n\t\t\tconst timeout = setTimeout(() => {\n\t\t\t\tcleanup();\n\t\t\t\tthis.logger.debug('Handshake timed out');\n\t\t\t\treject(new Error('Protocol handshake timed out'));\n\t\t\t}, 10000); // Matches the client timeout.\n\n\t\t\tconst handler = this.onControlMessage((rawMessage) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst raw = rawMessage.toString();\n\t\t\t\t\tthis.logger.trace('Got message', field('message', raw));\n\t\t\t\t\tconst message = JSON.parse(raw);\n\t\t\t\t\tswitch (message.type) {\n\t\t\t\t\t\tcase 'auth':\n\t\t\t\t\t\t\treturn this.authenticate(message);\n\t\t\t\t\t\tcase 'connectionType':\n\t\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\t\tthis.logger.debug('Handshake completed');\n\t\t\t\t\t\t\treturn resolve(message);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error('Unrecognized message type');\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcleanup();\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Kick off the handshake in case we missed the client's opening shot.\n\t\t\t// TODO: Investigate why that message seems to get lost.\n\t\t\tthis.authenticate();\n\t\t});\n\t}\n\n\t/**\n\t * TODO: This ignores the authentication process entirely for now.\n\t */\n\tprivate authenticate(_?: AuthRequest): void {\n\t\tthis.sendMessage({ type: 'sign', data: '' });\n\t}\n\n\t/**\n\t * TODO: implement.\n\t */\n\tpublic tunnel(): void {\n\t\tthrow new Error('Tunnel is not implemented yet');\n\t}\n\n\t/**\n\t * Send a handshake message. In the case of the extension host it should just\n\t * send a debug port.\n\t */\n\tpublic sendMessage(message: HandshakeMessage | { debugPort?: number | null } ): void {\n\t\tthis.sendControl(VSBuffer.fromString(JSON.stringify(message)));\n\t}\n\n\t/**\n\t * Disconnect and dispose everything including the underlying socket.\n\t */\n\tpublic destroy(reason?: string): void {\n\t\ttry {\n\t\t\tif (reason) {\n\t\t\t\tthis.sendMessage({ type: 'error', reason });\n\t\t\t}\n\t\t\t// If still connected try notifying the client.\n\t\t\tthis.sendDisconnect();\n\t\t} catch (error) {\n\t\t\t// I think the write might fail if already disconnected.\n\t\t\tthis.logger.warn(error.message || error);\n\t\t}\n\t\tthis.dispose(); // This disposes timers and socket event handlers.\n\t\tthis.getSocket().dispose(); // This will destroy() the socket.\n\t}\n\n\t/**\n\t * Get inflateBytes from the current socket.\n\t */\n\tpublic get inflateBytes(): Uint8Array | undefined {\n\t\tconst socket = this.getSocket();\n\t\treturn socket instanceof WebSocketNodeSocket\n\t\t\t? socket.recordedInflateBytes.buffer\n\t\t\t: undefined;\n\t}\n}\n"]}