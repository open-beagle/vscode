{"version":3,"file":"util.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/server/common/util.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file exists in two locations:\n * - src/common/util.ts\n * - lib/vscode/src/vs/server/common/util.ts\n * The second is a symlink to the first.\n */\n\n/**\n * Base options included on every page.\n */\nexport interface Options {\n  base: string\n  csStaticBase: string\n  logLevel: number\n}\n\n/**\n * Split a string up to the delimiter. If the delimiter doesn't exist the first\n * item will have all the text and the second item will be an empty string.\n */\nexport const split = (str: string, delimiter: string): [string, string] => {\n  const index = str.indexOf(delimiter)\n  return index !== -1 ? [str.substring(0, index).trim(), str.substring(index + 1)] : [str, \"\"]\n}\n\n/**\n * Appends an 's' to the provided string if count is greater than one;\n * otherwise the string is returned\n */\nexport const plural = (count: number, str: string): string => (count === 1 ? str : `${str}s`)\n\nexport const generateUuid = (length = 24): string => {\n  const possible = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n  return Array(length)\n    .fill(1)\n    .map(() => possible[Math.floor(Math.random() * possible.length)])\n    .join(\"\")\n}\n\n/**\n * Remove extra slashes in a URL.\n */\nexport const normalize = (url: string, keepTrailing = false): string => {\n  return url.replace(/\\/\\/+/g, \"/\").replace(/\\/+$/, keepTrailing ? \"/\" : \"\")\n}\n\n/**\n * Remove leading and trailing slashes.\n */\nexport const trimSlashes = (url: string): string => {\n  return url.replace(/^\\/+|\\/+$/g, \"\")\n}\n\n/**\n * Resolve a relative base against the window location. This is used for\n * anything that doesn't work with a relative path.\n */\nexport const resolveBase = (base?: string): string => {\n  // After resolving the base will either start with / or be an empty string.\n  if (!base || base.startsWith(\"/\")) {\n    return base ?? \"\"\n  }\n  const parts = location.pathname.split(\"/\")\n  parts[parts.length - 1] = base\n  const url = new URL(location.origin + \"/\" + parts.join(\"/\"))\n  return normalize(url.pathname)\n}\n\n/**\n * Get options embedded in the HTML or query params.\n */\nexport const getOptions = <T extends Options>(): T => {\n  let options: T\n  try {\n    options = JSON.parse(document.getElementById(\"coder-options\")!.getAttribute(\"data-settings\")!)\n  } catch (error) {\n    options = {} as T\n  }\n\n  // You can also pass options in stringified form to the options query\n  // variable. Options provided here will override the ones in the options\n  // element.\n  const params = new URLSearchParams(location.search)\n  const queryOpts = params.get(\"options\")\n  if (queryOpts) {\n    options = {\n      ...options,\n      ...JSON.parse(queryOpts),\n    }\n  }\n\n  options.base = resolveBase(options.base)\n  options.csStaticBase = resolveBase(options.csStaticBase)\n\n  return options\n}\n\n/**\n * Wrap the value in an array if it's not already an array. If the value is\n * undefined return an empty array.\n */\nexport const arrayify = <T>(value?: T | T[]): T[] => {\n  if (Array.isArray(value)) {\n    return value\n  }\n  if (typeof value === \"undefined\") {\n    return []\n  }\n  return [value]\n}\n\n/**\n * Get the first string. If there's no string return undefined.\n */\nexport const getFirstString = (value: string | string[] | object | undefined): string | undefined => {\n  if (Array.isArray(value)) {\n    return value[0]\n  }\n\n  return typeof value === \"string\" ? value : undefined\n}\n\n// TODO: Might make sense to add Error handling to the logger itself.\nexport function logError(logger: { error: (msg: string) => void }, prefix: string, err: Error | string): void {\n  if (err instanceof Error) {\n    logger.error(`${prefix}: ${err.message} ${err.stack}`)\n  } else {\n    logger.error(`${prefix}: ${err}`)\n  }\n}\n"]}