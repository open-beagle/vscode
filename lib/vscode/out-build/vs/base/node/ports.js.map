{"version":3,"file":"ports.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/node/ports.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from 'net';\n\n/**\n * @returns Returns a random port between 1025 and 65535.\n */\nexport function randomPort(): number {\n\tconst min = 1025;\n\tconst max = 65535;\n\treturn min + Math.floor((max - min) * Math.random());\n}\n\n/**\n * Given a start point and a max number of retries, will find a port that\n * is openable. Will return 0 in case no free port can be found.\n */\nexport function findFreePort(startPort: number, giveUpAfter: number, timeout: number): Promise<number> {\n\tlet done = false;\n\n\treturn new Promise(resolve => {\n\t\tconst timeoutHandle = setTimeout(() => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\treturn resolve(0);\n\t\t\t}\n\t\t}, timeout);\n\n\t\tdoFindFreePort(startPort, giveUpAfter, (port) => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t\treturn resolve(port);\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction doFindFreePort(startPort: number, giveUpAfter: number, clb: (port: number) => void): void {\n\tif (giveUpAfter === 0) {\n\t\treturn clb(0);\n\t}\n\n\tconst client = new net.Socket();\n\n\t// If we can connect to the port it means the port is already taken so we continue searching\n\tclient.once('connect', () => {\n\t\tdispose(client);\n\n\t\treturn doFindFreePort(startPort + 1, giveUpAfter - 1, clb);\n\t});\n\n\tclient.once('data', () => {\n\t\t// this listener is required since node.js 8.x\n\t});\n\n\tclient.once('error', (err: Error & { code?: string }) => {\n\t\tdispose(client);\n\n\t\t// If we receive any non ECONNREFUSED error, it means the port is used but we cannot connect\n\t\tif (err.code !== 'ECONNREFUSED') {\n\t\t\treturn doFindFreePort(startPort + 1, giveUpAfter - 1, clb);\n\t\t}\n\n\t\t// Otherwise it means the port is free to use!\n\t\treturn clb(startPort);\n\t});\n\n\tclient.connect(startPort, '127.0.0.1');\n}\n\n/**\n * Uses listen instead of connect. Is faster, but if there is another listener on 0.0.0.0 then this will take 127.0.0.1 from that listener.\n */\nexport function findFreePortFaster(startPort: number, giveUpAfter: number, timeout: number): Promise<number> {\n\tlet resolved: boolean = false;\n\tlet timeoutHandle: NodeJS.Timeout | undefined = undefined;\n\tlet countTried: number = 1;\n\tconst server = net.createServer({ pauseOnConnect: true });\n\tfunction doResolve(port: number, resolve: (port: number) => void) {\n\t\tif (!resolved) {\n\t\t\tresolved = true;\n\t\t\tserver.removeAllListeners();\n\t\t\tserver.close();\n\t\t\tif (timeoutHandle) {\n\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t}\n\t\t\tresolve(port);\n\t\t}\n\t}\n\treturn new Promise<number>(resolve => {\n\t\ttimeoutHandle = setTimeout(() => {\n\t\t\tdoResolve(0, resolve);\n\t\t}, timeout);\n\n\t\tserver.on('listening', () => {\n\t\t\tdoResolve(startPort, resolve);\n\t\t});\n\t\tserver.on('error', err => {\n\t\t\tif (err && ((<any>err).code === 'EADDRINUSE' || (<any>err).code === 'EACCES') && (countTried < giveUpAfter)) {\n\t\t\t\tstartPort++;\n\t\t\t\tcountTried++;\n\t\t\t\tserver.listen(startPort, '127.0.0.1');\n\t\t\t} else {\n\t\t\t\tdoResolve(0, resolve);\n\t\t\t}\n\t\t});\n\t\tserver.on('close', () => {\n\t\t\tdoResolve(0, resolve);\n\t\t});\n\t\tserver.listen(startPort, '127.0.0.1');\n\t});\n}\n\nfunction dispose(socket: net.Socket): void {\n\ttry {\n\t\tsocket.removeAllListeners('connect');\n\t\tsocket.removeAllListeners('error');\n\t\tsocket.end();\n\t\tsocket.destroy();\n\t\tsocket.unref();\n\t} catch (error) {\n\t\tconsole.error(error); // otherwise this error would get lost in the callback chain\n\t}\n}\n"]}