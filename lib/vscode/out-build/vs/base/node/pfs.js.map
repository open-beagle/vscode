{"version":3,"file":"pfs.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/node/pfs.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { join } from 'vs/base/common/path';\nimport { ResourceQueue } from 'vs/base/common/async';\nimport { isLinux, isMacintosh, isWindows } from 'vs/base/common/platform';\nimport { isEqualOrParent, isRootOrDriveLetter } from 'vs/base/common/extpath';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport { extUriBiasedIgnorePathCase } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\n\n//#region rimraf\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\n/**\n * Allows to delete the provied path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n */\nexport async function rimraf(path: string, mode = RimRafMode.UNLINK): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via rmDir\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path);\n}\n\nasync function rimrafMove(path: string): Promise<void> {\n\ttry {\n\t\tconst pathInTemp = join(tmpdir(), generateUuid());\n\t\ttry {\n\t\t\tawait fs.promises.rename(path, pathInTemp);\n\t\t} catch (error) {\n\t\t\treturn rimrafUnlink(path); // if rename fails, delete without tmp dir\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(pathInTemp).catch(error => {/* ignore */ });\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn fs.promises.rmdir(path, { recursive: true, maxRetries: 3 });\n}\n\nexport function rimrafSync(path: string): void {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\tfs.rmdirSync(path, { recursive: true });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nexport async function readdir(path: string): Promise<string[]>;\nexport async function readdir(path: string, options: { withFileTypes: true }): Promise<IDirent[]>;\nexport async function readdir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(await (options ? safeReaddirWithFileTypes(path) : fs.promises.readdir(path)));\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await fs.promises.readdir(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn('[node.js fs] readdir with filetypes failed with error: ', error);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await fs.promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn('[node.js fs] unexpected error from lstat after readdir: ', error);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Drop-in replacement of `fs.readdirSync` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nexport function readdirSync(path: string): string[] {\n\treturn handleDirectoryChildren(fs.readdirSync(path));\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[] {\n\treturn children.map(child => {\n\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === 'string') {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convinience method to read all children of a path that\n * are directories.\n */\nexport async function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, err => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\n\texport interface IStats {\n\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await fs.promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await fs.promises.stat(path);\n\n\t\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t\t} catch (error) {\n\n\t\t\t// If the link points to a non-existing file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === 'EACCES') {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await fs.promises.stat(await fs.promises.readlink(path));\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t// If the link points to a non-existing file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a non-existing path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a non-existing path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nexport function writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\treturn writeQueues.queueFor(URI.file(path), extUriBiasedIgnorePathCase).queue(() => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t});\n}\n\nexport interface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tcanFlush = false;\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n */\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd);\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tcanFlush = false;\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - updates the `mtime` of the `source` after the operation\n * - allows to move across multiple disks\n */\nexport async function move(source: string, target: string): Promise<void> {\n\tif (source === target) {\n\t\treturn;  // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\t// We have been updating `mtime` for move operations for files since the\n\t// beginning for reasons that are no longer quite clear, but changing\n\t// this could be risky as well. As such, trying to reason about it:\n\t// It is very common as developer to have file watchers enabled that watch\n\t// the current workspace for changes. Updating the `mtime` might make it\n\t// easier for these watchers to recognize an actual change. Since changing\n\t// a source code file also updates the `mtime`, moving a file should do so\n\t// as well because conceptually it is a change of a similar category.\n\tasync function updateMtime(path: string): Promise<void> {\n\t\ttry {\n\t\t\tconst stat = await fs.promises.lstat(path);\n\t\t\tif (stat.isDirectory() || stat.isSymbolicLink()) {\n\t\t\t\treturn; // only for files\n\t\t\t}\n\n\t\t\tconst fh = await fs.promises.open(path, 'a');\n\t\t\ttry {\n\t\t\t\tawait fh.utimes(stat.atime, new Date());\n\t\t\t} finally {\n\t\t\t\tawait fh.close();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Ignore any error\n\t\t}\n\t}\n\n\ttry {\n\t\tawait fs.promises.rename(source, target);\n\t\tawait updateMtime(target);\n\t} catch (error) {\n\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target, { preserveSymlinks: false /* copying to another device */ });\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t\tawait updateMtime(target);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string, target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nexport async function copy(source: string, target: string, options: { preserveSymlinks: boolean }): Promise<void> {\n\treturn doCopy(source, target, { root: { source, target }, options, handledSourcePaths: new Set<string>() });\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch (error) {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t\tconsole.warn('[node.js fs] copy of symlink failed: ', error);\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(source, target, stat.mode & COPY_MODE_MASK, payload);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(source: string, target: string, mode: number, payload: ICopyPayload): Promise<void> {\n\n\t// Create folder\n\tawait fs.promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\n\t// Copy file\n\tawait fs.promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait fs.promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Figure out link target\n\tlet linkTarget = await fs.promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(payload.root.target, linkTarget.substr(payload.root.source.length + 1));\n\t}\n\n\t// Create symlink\n\tawait fs.promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Async FS Methods\n\nexport async function exists(path: string): Promise<boolean> {\n\ttry {\n\t\tawait fs.promises.access(path);\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n//#endregion\n"]}