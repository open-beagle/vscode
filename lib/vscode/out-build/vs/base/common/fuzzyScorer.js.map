{"version":3,"file":"fuzzyScorer.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/common/fuzzyScorer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareAnything } from 'vs/base/common/comparers';\nimport { matchesPrefix, IMatch, isUpper, fuzzyScore, createMatches as createFuzzyMatches } from 'vs/base/common/filters';\nimport { sep } from 'vs/base/common/path';\nimport { isWindows, isLinux } from 'vs/base/common/platform';\nimport { stripWildcards, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\n\n//#region Fuzzy scorer\n\nexport type FuzzyScore = [number /* score */, number[] /* match positions */];\nexport type FuzzyScorerCache = { [key: string]: IItemScore };\n\nconst NO_MATCH = 0;\nconst NO_SCORE: FuzzyScore = [NO_MATCH, []];\n\n// const DEBUG = false;\n// const DEBUG_MATRIX = false;\n\nexport function scoreFuzzy(target: string, query: string, queryLower: string, fuzzy: boolean): FuzzyScore {\n\tif (!target || !query) {\n\t\treturn NO_SCORE; // return early if target or query are undefined\n\t}\n\n\tconst targetLength = target.length;\n\tconst queryLength = query.length;\n\n\tif (targetLength < queryLength) {\n\t\treturn NO_SCORE; // impossible for query to be contained in target\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.group(`Target: ${target}, Query: ${query}`);\n\t// }\n\n\tconst targetLower = target.toLowerCase();\n\n\t// When not searching fuzzy, we require the query to be contained fully\n\t// in the target string contiguously.\n\tif (!fuzzy) {\n\t\tif (!targetLower.includes(queryLower)) {\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log(`Characters not matching consecutively ${queryLower} within ${targetLower}`);\n\t\t\t// }\n\n\t\t\treturn NO_SCORE;\n\t\t}\n\t}\n\n\tconst res = doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength);\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn res;\n}\n\nfunction doScoreFuzzy(query: string, queryLower: string, queryLength: number, target: string, targetLower: string, targetLength: number): FuzzyScore {\n\tconst scores: number[] = [];\n\tconst matches: number[] = [];\n\n\t//\n\t// Build Scorer Matrix:\n\t//\n\t// The matrix is composed of query q and target t. For each index we score\n\t// q[i] with t[i] and compare that with the previous score. If the score is\n\t// equal or larger, we keep the match. In addition to the score, we also keep\n\t// the length of the consecutive matches to use as boost for the score.\n\t//\n\t//      t   a   r   g   e   t\n\t//  q\n\t//  u\n\t//  e\n\t//  r\n\t//  y\n\t//\n\tfor (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n\t\tconst queryIndexOffset = queryIndex * targetLength;\n\t\tconst queryIndexPreviousOffset = queryIndexOffset - targetLength;\n\n\t\tconst queryIndexGtNull = queryIndex > 0;\n\n\t\tconst queryCharAtIndex = query[queryIndex];\n\t\tconst queryLowerCharAtIndex = queryLower[queryIndex];\n\n\t\tfor (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n\t\t\tconst targetIndexGtNull = targetIndex > 0;\n\n\t\t\tconst currentIndex = queryIndexOffset + targetIndex;\n\t\t\tconst leftIndex = currentIndex - 1;\n\t\t\tconst diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n\n\t\t\tconst leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n\t\t\tconst diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n\n\t\t\tconst matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n\n\t\t\t// If we are not matching on the first query character any more, we only produce a\n\t\t\t// score if we had a score previously for the last query index (by looking at the diagScore).\n\t\t\t// This makes sure that the query always matches in sequence on the target. For example\n\t\t\t// given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n\t\t\t// for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n\t\t\tlet score: number;\n\t\t\tif (!diagScore && queryIndexGtNull) {\n\t\t\t\tscore = 0;\n\t\t\t} else {\n\t\t\t\tscore = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);\n\t\t\t}\n\n\t\t\t// We have a score and its equal or larger than the left score\n\t\t\t// Match: sequence continues growing from previous diag value\n\t\t\t// Score: increases by diag score value\n\t\t\tif (score && diagScore + score >= leftScore) {\n\t\t\t\tmatches[currentIndex] = matchesSequenceLength + 1;\n\t\t\t\tscores[currentIndex] = diagScore + score;\n\t\t\t}\n\n\t\t\t// We either have no score or the score is lower than the left score\n\t\t\t// Match: reset to 0\n\t\t\t// Score: pick up from left hand side\n\t\t\telse {\n\t\t\t\tmatches[currentIndex] = NO_MATCH;\n\t\t\t\tscores[currentIndex] = leftScore;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Restore Positions (starting from bottom right of matrix)\n\tconst positions: number[] = [];\n\tlet queryIndex = queryLength - 1;\n\tlet targetIndex = targetLength - 1;\n\twhile (queryIndex >= 0 && targetIndex >= 0) {\n\t\tconst currentIndex = queryIndex * targetLength + targetIndex;\n\t\tconst match = matches[currentIndex];\n\t\tif (match === NO_MATCH) {\n\t\t\ttargetIndex--; // go left\n\t\t} else {\n\t\t\tpositions.push(targetIndex);\n\n\t\t\t// go up and left\n\t\t\tqueryIndex--;\n\t\t\ttargetIndex--;\n\t\t}\n\t}\n\n\t// Print matrix\n\t// if (DEBUG_MATRIX) {\n\t// printMatrix(query, target, matches, scores);\n\t// }\n\n\treturn [scores[queryLength * targetLength - 1], positions.reverse()];\n}\n\nfunction computeCharScore(queryCharAtIndex: string, queryLowerCharAtIndex: string, target: string, targetLower: string, targetIndex: number, matchesSequenceLength: number): number {\n\tlet score = 0;\n\n\tif (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {\n\t\treturn score; // no match of characters\n\t}\n\n\t// Character match bonus\n\tscore += 1;\n\n\t// if (DEBUG) {\n\t// console.groupCollapsed(`%cCharacter match bonus: +1 (char: ${queryLowerCharAtIndex} at index ${targetIndex}, total score: ${score})`, 'font-weight: normal');\n\t// }\n\n\t// Consecutive match bonus\n\tif (matchesSequenceLength > 0) {\n\t\tscore += (matchesSequenceLength * 5);\n\n\t\t// if (DEBUG) {\n\t\t// console.log(`Consecutive match bonus: +${matchesSequenceLength * 5}`);\n\t\t// }\n\t}\n\n\t// Same case bonus\n\tif (queryCharAtIndex === target[targetIndex]) {\n\t\tscore += 1;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Same case bonus: +1');\n\t\t// }\n\t}\n\n\t// Start of word bonus\n\tif (targetIndex === 0) {\n\t\tscore += 8;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Start of word bonus: +8');\n\t\t// }\n\t}\n\n\telse {\n\n\t\t// After separator bonus\n\t\tconst separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n\t\tif (separatorBonus) {\n\t\t\tscore += separatorBonus;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// console.log(`After separtor bonus: +${separatorBonus}`);\n\t\t\t// }\n\t\t}\n\n\t\t// Inside word upper case bonus (camel case)\n\t\telse if (isUpper(target.charCodeAt(targetIndex))) {\n\t\t\tscore += 2;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('Inside word upper case bonus: +2');\n\t\t\t// }\n\t\t}\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn score;\n}\n\nfunction considerAsEqual(a: string, b: string): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\t// Special case path spearators: ignore platform differences\n\tif (a === '/' || a === '\\\\') {\n\t\treturn b === '/' || b === '\\\\';\n\t}\n\n\treturn false;\n}\n\nfunction scoreSeparatorAtPos(charCode: number): number {\n\tswitch (charCode) {\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\t\treturn 5; // prefer path separators...\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\t\treturn 4; // ...over other separators\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n// function printMatrix(query: string, target: string, matches: number[], scores: number[]): void {\n// \tconsole.log('\\t' + target.split('').join('\\t'));\n// \tfor (let queryIndex = 0; queryIndex < query.length; queryIndex++) {\n// \t\tlet line = query[queryIndex] + '\\t';\n// \t\tfor (let targetIndex = 0; targetIndex < target.length; targetIndex++) {\n// \t\t\tconst currentIndex = queryIndex * target.length + targetIndex;\n// \t\t\tline = line + 'M' + matches[currentIndex] + '/' + 'S' + scores[currentIndex] + '\\t';\n// \t\t}\n\n// \t\tconsole.log(line);\n// \t}\n// }\n\n//#endregion\n\n\n//#region Alternate fuzzy scorer implementation that is e.g. used for symbols\n\nexport type FuzzyScore2 = [number | undefined /* score */, IMatch[]];\n\nconst NO_SCORE2: FuzzyScore2 = [undefined, []];\n\nexport function scoreFuzzy2(target: string, query: IPreparedQuery | IPreparedQueryPiece, patternStart = 0, wordStart = 0): FuzzyScore2 {\n\n\t// Score: multiple inputs\n\tconst preparedQuery = query as IPreparedQuery;\n\tif (preparedQuery.values && preparedQuery.values.length > 1) {\n\t\treturn doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n\t}\n\n\t// Score: single input\n\treturn doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\n\nfunction doScoreFuzzy2Multiple(target: string, query: IPreparedQueryPiece[], patternStart: number, wordStart: number): FuzzyScore2 {\n\tlet totalScore = 0;\n\tconst totalMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n\t\tif (typeof score !== 'number') {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_SCORE2;\n\t\t}\n\n\t\ttotalScore += score;\n\t\ttotalMatches.push(...matches);\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn [totalScore, normalizeMatches(totalMatches)];\n}\n\nfunction doScoreFuzzy2Single(target: string, query: IPreparedQueryPiece, patternStart: number, wordStart: number): FuzzyScore2 {\n\tconst score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);\n\tif (!score) {\n\t\treturn NO_SCORE2;\n\t}\n\n\treturn [score[0], createFuzzyMatches(score)];\n}\n\n//#endregion\n\n\n//#region Item (label, description, path) scorer\n\n/**\n * Scoring on structural items that have a label and optional description.\n */\nexport interface IItemScore {\n\n\t/**\n\t * Overall score.\n\t */\n\tscore: number;\n\n\t/**\n\t * Matches within the label.\n\t */\n\tlabelMatch?: IMatch[];\n\n\t/**\n\t * Matches within the description.\n\t */\n\tdescriptionMatch?: IMatch[];\n}\n\nconst NO_ITEM_SCORE: IItemScore = Object.freeze({ score: 0 });\n\nexport interface IItemAccessor<T> {\n\n\t/**\n\t * Just the label of the item to score on.\n\t */\n\tgetItemLabel(item: T): string | undefined;\n\n\t/**\n\t * The optional description of the item to score on.\n\t */\n\tgetItemDescription(item: T): string | undefined;\n\n\t/**\n\t * If the item is a file, the path of the file to score on.\n\t */\n\tgetItemPath(file: T): string | undefined;\n}\n\nconst PATH_IDENTITY_SCORE = 1 << 18;\nconst LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;\nconst LABEL_SCORE_THRESHOLD = 1 << 16;\n\nexport function scoreItemFuzzy<T>(item: T, query: IPreparedQuery, fuzzy: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): IItemScore {\n\tif (!item || !query.normalized) {\n\t\treturn NO_ITEM_SCORE; // we need an item and query to score on at least\n\t}\n\n\tconst label = accessor.getItemLabel(item);\n\tif (!label) {\n\t\treturn NO_ITEM_SCORE; // we need a label at least\n\t}\n\n\tconst description = accessor.getItemDescription(item);\n\n\t// in order to speed up scoring, we cache the score with a unique hash based on:\n\t// - label\n\t// - description (if provided)\n\t// - query (normalized)\n\t// - number of query pieces (i.e. 'hello world' and 'helloworld' are different)\n\t// - whether fuzzy matching is enabled or not\n\tlet cacheHash: string;\n\tif (description) {\n\t\tcacheHash = `${label}${description}${query.normalized}${Array.isArray(query.values) ? query.values.length : ''}${fuzzy}`;\n\t} else {\n\t\tcacheHash = `${label}${query.normalized}${Array.isArray(query.values) ? query.values.length : ''}${fuzzy}`;\n\t}\n\n\tconst cached = cache[cacheHash];\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst itemScore = doScoreItemFuzzy(label, description, accessor.getItemPath(item), query, fuzzy);\n\tcache[cacheHash] = itemScore;\n\n\treturn itemScore;\n}\n\nfunction doScoreItemFuzzy(label: string, description: string | undefined, path: string | undefined, query: IPreparedQuery, fuzzy: boolean): IItemScore {\n\tconst preferLabelMatches = !path || !query.containsPathSeparator;\n\n\t// Treat identity matches on full path highest\n\tif (path && (isLinux ? query.pathNormalized === path : equalsIgnoreCase(query.pathNormalized, path))) {\n\t\treturn { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n\t}\n\n\t// Score: multiple inputs\n\tif (query.values && query.values.length > 1) {\n\t\treturn doScoreItemFuzzyMultiple(label, description, path, query.values, preferLabelMatches, fuzzy);\n\t}\n\n\t// Score: single input\n\treturn doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, fuzzy);\n}\n\nfunction doScoreItemFuzzyMultiple(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece[], preferLabelMatches: boolean, fuzzy: boolean): IItemScore {\n\tlet totalScore = 0;\n\tconst totalLabelMatches: IMatch[] = [];\n\tconst totalDescriptionMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(label, description, path, queryPiece, preferLabelMatches, fuzzy);\n\t\tif (score === NO_MATCH) {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_ITEM_SCORE;\n\t\t}\n\n\t\ttotalScore += score;\n\t\tif (labelMatch) {\n\t\t\ttotalLabelMatches.push(...labelMatch);\n\t\t}\n\n\t\tif (descriptionMatch) {\n\t\t\ttotalDescriptionMatches.push(...descriptionMatch);\n\t\t}\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn {\n\t\tscore: totalScore,\n\t\tlabelMatch: normalizeMatches(totalLabelMatches),\n\t\tdescriptionMatch: normalizeMatches(totalDescriptionMatches)\n\t};\n}\n\nfunction doScoreItemFuzzySingle(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece, preferLabelMatches: boolean, fuzzy: boolean): IItemScore {\n\n\t// Prefer label matches if told so or we have no description\n\tif (preferLabelMatches || !description) {\n\t\tconst [labelScore, labelPositions] = scoreFuzzy(label, query.normalized, query.normalizedLowercase, fuzzy);\n\t\tif (labelScore) {\n\n\t\t\t// If we have a prefix match on the label, we give a much\n\t\t\t// higher baseScore to elevate these matches over others\n\t\t\t// This ensures that typing a file name wins over results\n\t\t\t// that are present somewhere in the label, but not the\n\t\t\t// beginning.\n\t\t\tconst labelPrefixMatch = matchesPrefix(query.normalized, label);\n\t\t\tlet baseScore: number;\n\t\t\tif (labelPrefixMatch) {\n\t\t\t\tbaseScore = LABEL_PREFIX_SCORE_THRESHOLD;\n\n\t\t\t\t// We give another boost to labels that are short, e.g. given\n\t\t\t\t// files \"window.ts\" and \"windowActions.ts\" and a query of\n\t\t\t\t// \"window\", we want \"window.ts\" to receive a higher score.\n\t\t\t\t// As such we compute the percentage the query has within the\n\t\t\t\t// label and add that to the baseScore.\n\t\t\t\tconst prefixLengthBoost = Math.round((query.normalized.length / label.length) * 100);\n\t\t\t\tbaseScore += prefixLengthBoost;\n\t\t\t} else {\n\t\t\t\tbaseScore = LABEL_SCORE_THRESHOLD;\n\t\t\t}\n\n\t\t\treturn { score: baseScore + labelScore, labelMatch: labelPrefixMatch || createMatches(labelPositions) };\n\t\t}\n\t}\n\n\t// Finally compute description + label scores if we have a description\n\tif (description) {\n\t\tlet descriptionPrefix = description;\n\t\tif (!!path) {\n\t\t\tdescriptionPrefix = `${description}${sep}`; // assume this is a file path\n\t\t}\n\n\t\tconst descriptionPrefixLength = descriptionPrefix.length;\n\t\tconst descriptionAndLabel = `${descriptionPrefix}${label}`;\n\n\t\tconst [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(descriptionAndLabel, query.normalized, query.normalizedLowercase, fuzzy);\n\t\tif (labelDescriptionScore) {\n\t\t\tconst labelDescriptionMatches = createMatches(labelDescriptionPositions);\n\t\t\tconst labelMatch: IMatch[] = [];\n\t\t\tconst descriptionMatch: IMatch[] = [];\n\n\t\t\t// We have to split the matches back onto the label and description portions\n\t\t\tlabelDescriptionMatches.forEach(h => {\n\n\t\t\t\t// Match overlaps label and description part, we need to split it up\n\t\t\t\tif (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });\n\t\t\t\t\tdescriptionMatch.push({ start: h.start, end: descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on label part\n\t\t\t\telse if (h.start >= descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on description part\n\t\t\t\telse {\n\t\t\t\t\tdescriptionMatch.push(h);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { score: labelDescriptionScore, labelMatch, descriptionMatch };\n\t\t}\n\t}\n\n\treturn NO_ITEM_SCORE;\n}\n\nfunction createMatches(offsets: number[] | undefined): IMatch[] {\n\tconst ret: IMatch[] = [];\n\tif (!offsets) {\n\t\treturn ret;\n\t}\n\n\tlet last: IMatch | undefined;\n\tfor (const pos of offsets) {\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end += 1;\n\t\t} else {\n\t\t\tlast = { start: pos, end: pos + 1 };\n\t\t\tret.push(last);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nfunction normalizeMatches(matches: IMatch[]): IMatch[] {\n\n\t// sort matches by start to be able to normalize\n\tconst sortedMatches = matches.sort((matchA, matchB) => {\n\t\treturn matchA.start - matchB.start;\n\t});\n\n\t// merge matches that overlap\n\tconst normalizedMatches: IMatch[] = [];\n\tlet currentMatch: IMatch | undefined = undefined;\n\tfor (const match of sortedMatches) {\n\n\t\t// if we have no current match or the matches\n\t\t// do not overlap, we take it as is and remember\n\t\t// it for future merging\n\t\tif (!currentMatch || !matchOverlaps(currentMatch, match)) {\n\t\t\tcurrentMatch = match;\n\t\t\tnormalizedMatches.push(match);\n\t\t}\n\n\t\t// otherwise we merge the matches\n\t\telse {\n\t\t\tcurrentMatch.start = Math.min(currentMatch.start, match.start);\n\t\t\tcurrentMatch.end = Math.max(currentMatch.end, match.end);\n\t\t}\n\t}\n\n\treturn normalizedMatches;\n}\n\nfunction matchOverlaps(matchA: IMatch, matchB: IMatch): boolean {\n\tif (matchA.end < matchB.start) {\n\t\treturn false;\t// A ends before B starts\n\t}\n\n\tif (matchB.end < matchA.start) {\n\t\treturn false; // B ends before A starts\n\t}\n\n\treturn true;\n}\n\n//#endregion\n\n\n//#region Comparers\n\nexport function compareItemsByFuzzyScore<T>(itemA: T, itemB: T, query: IPreparedQuery, fuzzy: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): number {\n\tconst itemScoreA = scoreItemFuzzy(itemA, query, fuzzy, accessor, cache);\n\tconst itemScoreB = scoreItemFuzzy(itemB, query, fuzzy, accessor, cache);\n\n\tconst scoreA = itemScoreA.score;\n\tconst scoreB = itemScoreB.score;\n\n\t// 1.) identity matches have highest score\n\tif (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n\t\t}\n\t}\n\n\t// 2.) matches on label are considered higher compared to label+description matches\n\tif (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA > scoreB ? -1 : 1;\n\t\t}\n\n\t\t// prefer more compact matches over longer in label (unless this is a prefix match where\n\t\t// longer prefix matches are actually preferred)\n\t\tif (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {\n\t\t\tconst comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n\t\t\tif (comparedByMatchLength !== 0) {\n\t\t\t\treturn comparedByMatchLength;\n\t\t\t}\n\t\t}\n\n\t\t// prefer shorter labels over longer labels\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 3.) compare by score in label+description\n\tif (scoreA !== scoreB) {\n\t\treturn scoreA > scoreB ? -1 : 1;\n\t}\n\n\t// 4.) scores are identical: prefer matches in label over non-label matches\n\tconst itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;\n\tconst itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;\n\tif (itemAHasLabelMatches && !itemBHasLabelMatches) {\n\t\treturn -1;\n\t} else if (itemBHasLabelMatches && !itemAHasLabelMatches) {\n\t\treturn 1;\n\t}\n\n\t// 5.) scores are identical: prefer more compact matches (label and description)\n\tconst itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n\tconst itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n\tif (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n\t\treturn itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n\t}\n\n\t// 6.) scores are identical: start to use the fallback compare\n\treturn fallbackCompare(itemA, itemB, query, accessor);\n}\n\nfunction computeLabelAndDescriptionMatchDistance<T>(item: T, score: IItemScore, accessor: IItemAccessor<T>): number {\n\tlet matchStart: number = -1;\n\tlet matchEnd: number = -1;\n\n\t// If we have description matches, the start is first of description match\n\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchStart = score.descriptionMatch[0].start;\n\t}\n\n\t// Otherwise, the start is the first label match\n\telse if (score.labelMatch && score.labelMatch.length) {\n\t\tmatchStart = score.labelMatch[0].start;\n\t}\n\n\t// If we have label match, the end is the last label match\n\t// If we had a description match, we add the length of the description\n\t// as offset to the end to indicate this.\n\tif (score.labelMatch && score.labelMatch.length) {\n\t\tmatchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n\t\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\t\tconst itemDescription = accessor.getItemDescription(item);\n\t\t\tif (itemDescription) {\n\t\t\t\tmatchEnd += itemDescription.length;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have just a description match, the end is the last description match\n\telse if (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n\t}\n\n\treturn matchEnd - matchStart;\n}\n\nfunction compareByMatchLength(matchesA?: IMatch[], matchesB?: IMatch[]): number {\n\tif ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {\n\t\treturn 0; // make sure to not cause bad comparing when matches are not provided\n\t}\n\n\tif (!matchesB || !matchesB.length) {\n\t\treturn -1;\n\t}\n\n\tif (!matchesA || !matchesA.length) {\n\t\treturn 1;\n\t}\n\n\t// Compute match length of A (first to last match)\n\tconst matchStartA = matchesA[0].start;\n\tconst matchEndA = matchesA[matchesA.length - 1].end;\n\tconst matchLengthA = matchEndA - matchStartA;\n\n\t// Compute match length of B (first to last match)\n\tconst matchStartB = matchesB[0].start;\n\tconst matchEndB = matchesB[matchesB.length - 1].end;\n\tconst matchLengthB = matchEndB - matchStartB;\n\n\t// Prefer shorter match length\n\treturn matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n}\n\nfunction fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {\n\n\t// check for label + description length and prefer shorter\n\tconst labelA = accessor.getItemLabel(itemA) || '';\n\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\tconst descriptionA = accessor.getItemDescription(itemA);\n\tconst descriptionB = accessor.getItemDescription(itemB);\n\n\tconst labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n\tconst labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n\n\tif (labelDescriptionALength !== labelDescriptionBLength) {\n\t\treturn labelDescriptionALength - labelDescriptionBLength;\n\t}\n\n\t// check for path length and prefer shorter\n\tconst pathA = accessor.getItemPath(itemA);\n\tconst pathB = accessor.getItemPath(itemB);\n\n\tif (pathA && pathB && pathA.length !== pathB.length) {\n\t\treturn pathA.length - pathB.length;\n\t}\n\n\t// 7.) finally we have equal scores and equal length, we fallback to comparer\n\n\t// compare by label\n\tif (labelA !== labelB) {\n\t\treturn compareAnything(labelA, labelB, query.normalized);\n\t}\n\n\t// compare by description\n\tif (descriptionA && descriptionB && descriptionA !== descriptionB) {\n\t\treturn compareAnything(descriptionA, descriptionB, query.normalized);\n\t}\n\n\t// compare by path\n\tif (pathA && pathB && pathA !== pathB) {\n\t\treturn compareAnything(pathA, pathB, query.normalized);\n\t}\n\n\t// equal\n\treturn 0;\n}\n\n//#endregion\n\n\n//#region Query Normalizer\n\nexport interface IPreparedQueryPiece {\n\n\t/**\n\t * The original query as provided as input.\n\t */\n\toriginal: string;\n\toriginalLowercase: string;\n\n\t/**\n\t * Original normalized to platform separators:\n\t * - Windows: \\\n\t * - Posix: /\n\t */\n\tpathNormalized: string;\n\n\t/**\n\t * In addition to the normalized path, will have\n\t * whitespace and wildcards removed.\n\t */\n\tnormalized: string;\n\tnormalizedLowercase: string;\n}\n\nexport interface IPreparedQuery extends IPreparedQueryPiece {\n\n\t/**\n\t * Query split by spaces into pieces.\n\t */\n\tvalues: IPreparedQueryPiece[] | undefined;\n\n\t/**\n\t * Whether the query contains path separator(s) or not.\n\t */\n\tcontainsPathSeparator: boolean;\n}\n\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original: string): IPreparedQuery {\n\tif (typeof original !== 'string') {\n\t\toriginal = '';\n\t}\n\n\tconst originalLowercase = original.toLowerCase();\n\tconst { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n\tconst containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n\n\tlet values: IPreparedQueryPiece[] | undefined = undefined;\n\n\tconst originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n\tif (originalSplit.length > 1) {\n\t\tfor (const originalPiece of originalSplit) {\n\t\t\tconst {\n\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\tnormalizedLowercase: normalizedLowercasePiece\n\t\t\t} = normalizeQuery(originalPiece);\n\n\t\t\tif (normalizedPiece) {\n\t\t\t\tif (!values) {\n\t\t\t\t\tvalues = [];\n\t\t\t\t}\n\n\t\t\t\tvalues.push({\n\t\t\t\t\toriginal: originalPiece,\n\t\t\t\t\toriginalLowercase: originalPiece.toLowerCase(),\n\t\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\t\tnormalizedLowercase: normalizedLowercasePiece\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator };\n}\n\nfunction normalizeQuery(original: string): { pathNormalized: string, normalized: string, normalizedLowercase: string } {\n\tlet pathNormalized: string;\n\tif (isWindows) {\n\t\tpathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n\t} else {\n\t\tpathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n\t}\n\n\tconst normalized = stripWildcards(pathNormalized).replace(/\\s/g, '');\n\n\treturn {\n\t\tpathNormalized,\n\t\tnormalized,\n\t\tnormalizedLowercase: normalized.toLowerCase()\n\t};\n}\n\nexport function pieceToQuery(piece: IPreparedQueryPiece): IPreparedQuery;\nexport function pieceToQuery(pieces: IPreparedQueryPiece[]): IPreparedQuery;\nexport function pieceToQuery(arg1: IPreparedQueryPiece | IPreparedQueryPiece[]): IPreparedQuery {\n\tif (Array.isArray(arg1)) {\n\t\treturn prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n\t}\n\n\treturn prepareQuery(arg1.original);\n}\n\n//#endregion\n"]}