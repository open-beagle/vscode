{"version":3,"file":"iconLabels.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/common/iconLabels.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CSSIcon } from 'vs/base/common/codicons';\nimport { matchesFuzzy, IMatch } from 'vs/base/common/filters';\nimport { ltrim } from 'vs/base/common/strings';\n\nexport const iconStartMarker = '$(';\n\nconst iconsRegex = new RegExp(`\\\\$\\\\(${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\n\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text: string): string {\n\treturn text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\n\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text: string): string {\n\t// Need to add an extra \\ for escaping in markdown\n\treturn text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\n\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\nexport function stripIcons(text: string): string {\n\tif (text.indexOf(iconStartMarker) === -1) {\n\t\treturn text;\n\t}\n\n\treturn text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\n\n\nexport interface IParsedLabelWithIcons {\n\treadonly text: string;\n\treadonly iconOffsets?: readonly number[];\n}\n\nexport function parseLabelWithIcons(text: string): IParsedLabelWithIcons {\n\tconst firstIconIndex = text.indexOf(iconStartMarker);\n\tif (firstIconIndex === -1) {\n\t\treturn { text }; // return early if the word does not include an icon\n\t}\n\n\treturn doParseLabelWithIcons(text, firstIconIndex);\n}\n\nfunction doParseLabelWithIcons(text: string, firstIconIndex: number): IParsedLabelWithIcons {\n\tconst iconOffsets: number[] = [];\n\tlet textWithoutIcons: string = '';\n\n\tfunction appendChars(chars: string) {\n\t\tif (chars) {\n\t\t\ttextWithoutIcons += chars;\n\n\t\t\tfor (const _ of chars) {\n\t\t\t\ticonOffsets.push(iconsOffset); // make sure to fill in icon offsets\n\t\t\t}\n\t\t}\n\t}\n\n\tlet currentIconStart = -1;\n\tlet currentIconValue: string = '';\n\tlet iconsOffset = 0;\n\n\tlet char: string;\n\tlet nextChar: string;\n\n\tlet offset = firstIconIndex;\n\tconst length = text.length;\n\n\t// Append all characters until the first icon\n\tappendChars(text.substr(0, firstIconIndex));\n\n\t// example: $(file-symlink-file) my cool $(other-icon) entry\n\twhile (offset < length) {\n\t\tchar = text[offset];\n\t\tnextChar = text[offset + 1];\n\n\t\t// beginning of icon: some value $( <--\n\t\tif (char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {\n\t\t\tcurrentIconStart = offset;\n\n\t\t\t// if we had a previous potential icon value without\n\t\t\t// the closing ')', it was actually not an icon and\n\t\t\t// so we have to add it to the actual value\n\t\t\tappendChars(currentIconValue);\n\n\t\t\tcurrentIconValue = iconStartMarker;\n\n\t\t\toffset++; // jump over '('\n\t\t}\n\n\t\t// end of icon: some value $(some-icon) <--\n\t\telse if (char === ')' && currentIconStart !== -1) {\n\t\t\tconst currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'\n\t\t\ticonsOffset += currentIconLength;\n\t\t\tcurrentIconStart = -1;\n\t\t\tcurrentIconValue = '';\n\t\t}\n\n\t\t// within icon\n\t\telse if (currentIconStart !== -1) {\n\t\t\t// Make sure this is a real icon name\n\t\t\tif (/^[a-z0-9\\-]$/i.test(char)) {\n\t\t\t\tcurrentIconValue += char;\n\t\t\t} else {\n\t\t\t\t// This is not a real icon, treat it as text\n\t\t\t\tappendChars(currentIconValue);\n\n\t\t\t\tcurrentIconStart = -1;\n\t\t\t\tcurrentIconValue = '';\n\t\t\t}\n\t\t}\n\n\t\t// any value outside of icon\n\t\telse {\n\t\t\tappendChars(char);\n\t\t}\n\n\t\toffset++;\n\t}\n\n\t// if we had a previous potential icon value without\n\t// the closing ')', it was actually not an icon and\n\t// so we have to add it to the actual value\n\tappendChars(currentIconValue);\n\n\treturn { text: textWithoutIcons, iconOffsets };\n}\n\nexport function matchesFuzzyIconAware(query: string, target: IParsedLabelWithIcons, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tconst { text, iconOffsets } = target;\n\n\t// Return early if there are no icon markers in the word to match against\n\tif (!iconOffsets || iconOffsets.length === 0) {\n\t\treturn matchesFuzzy(query, text, enableSeparateSubstringMatching);\n\t}\n\n\t// Trim the word to match against because it could have leading\n\t// whitespace now if the word started with an icon\n\tconst wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n\tconst leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n\n\t// match on value without icon\n\tconst matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n\n\t// Map matches back to offsets with icon and trimming\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tconst iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n\t\t\tmatch.start += iconOffset;\n\t\t\tmatch.end += iconOffset;\n\t\t}\n\t}\n\n\treturn matches;\n}\n"]}