{"version":3,"file":"event.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/common/event.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { Disposable, IDisposable, toDisposable, combinedDisposable, DisposableStore } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { StopWatch } from 'vs/base/common/stopwatch';\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event and a `map` function, returns another event which maps each element\n\t * through the mapping function.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n\t}\n\n\t/**\n\t * Given an event and an `each` function, returns another identical event and calls\n\t * the `each` function per each element.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n\t}\n\n\t/**\n\t * Given an event and a `filter` function, returns another event which emits those\n\t * elements for which the `filter` function returns `true`.\n\t */\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits\n\t * whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n\t}\n\n\t/**\n\t * Given an event and a `merge` function, returns another event which maps each element\n\t * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t});\n\t}\n\n\t/**\n\t * Given a chain of event processing functions (filter, map, etc), each\n\t * function will be invoked per event & per listener. Snapshotting an event\n\t * chain allows each function to be invoked just once per event.\n\t */\n\texport function snapshot<T>(event: Event<T>): Event<T> {\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tlistener.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces the provided event, given a `merge` function.\n\t *\n\t * @param event The input event.\n\t * @param merge The reducing function.\n\t * @param delay The debouncing delay in millis.\n\t * @param leading Whether the event should fire in the leading phase of the timeout.\n\t * @param leakWarningThreshold The leak warning threshold override.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number = 100, leading = false, leakWarningThreshold?: number): Event<O> {\n\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\n\t\tconst emitter = new Emitter<O>({\n\t\t\tleakWarningThreshold,\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only once and as soon as\n\t * the input event emits. The event data is the number of millis it took for the\n\t * event to fire.\n\t */\n\texport function stopwatch<T>(event: Event<T>): Event<number> {\n\t\tconst start = new Date().getTime();\n\t\treturn map(once(event), _ => new Date().getTime() - start);\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only when the event\n\t * element changes.\n\t */\n\texport function latch<T>(event: Event<T>): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || value !== cache;\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t});\n\t}\n\n\t/**\n\t * Buffers the provided event until a first listener comes\n\t * along, at which point fire all the events at once and\n\t * pipe the event from then on.\n\t *\n\t * ```typescript\n\t * const emitter = new Emitter<number>();\n\t * const event = emitter.event;\n\t * const bufferedEvent = buffer(event);\n\t *\n\t * emitter.fire(1);\n\t * emitter.fire(2);\n\t * emitter.fire(3);\n\t * // nothing...\n\t *\n\t * const listener = bufferedEvent(num => console.log(num));\n\t * // 1, 2, 3\n\t *\n\t * emitter.fire(4);\n\t * // 4\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, nextTick = false, _buffer: T[] = []): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tconst flush = () => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.forEach(e => emitter.fire(e));\n\t\t\t}\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonFirstListenerDidAdd() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (nextTick) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLastListenerRemove() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\texport interface IChainableEvent<T> {\n\t\tevent: Event<T>;\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O>;\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;\n\t\tlatch(): IChainableEvent<T>;\n\t\tdebounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;\n\t\ton(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n\t\tonce(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t}\n\n\tclass ChainableEvent<T> implements IChainableEvent<T> {\n\n\t\tconstructor(readonly event: Event<T>) { }\n\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O> {\n\t\t\treturn new ChainableEvent(map(this.event, fn));\n\t\t}\n\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(forEach(this.event, fn));\n\t\t}\n\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(filter(this.event, fn));\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(reduce(this.event, merge, initial));\n\t\t}\n\n\t\tlatch(): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(latch(this.event));\n\t\t}\n\n\t\tdebounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay: number = 100, leading = false, leakWarningThreshold?: number): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n\t\t}\n\n\t\ton(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[] | DisposableStore) {\n\t\t\treturn this.event(listener, thisArgs, disposables);\n\t\t}\n\n\t\tonce(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn once(this.event)(listener, thisArgs, disposables);\n\t\t}\n\t}\n\n\texport function chain<T>(event: Event<T>): IChainableEvent<T> {\n\t\treturn new ChainableEvent(event);\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport function fromPromise<T = any>(promise: Promise<T>): Event<undefined> {\n\t\tconst emitter = new Emitter<undefined>();\n\t\tlet shouldEmit = false;\n\n\t\tpromise\n\t\t\t.then(undefined, () => null)\n\t\t\t.then(() => {\n\t\t\t\tif (!shouldEmit) {\n\t\t\t\t\tsetTimeout(() => emitter.fire(undefined), 0);\n\t\t\t\t} else {\n\t\t\t\t\temitter.fire(undefined);\n\t\t\t\t}\n\t\t\t});\n\n\t\tshouldEmit = true;\n\t\treturn emitter.event;\n\t}\n\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(resolve => once(event)(resolve));\n\t}\n}\n\nexport type Listener<T> = [(e: T) => void, any] | ((e: T) => void);\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonFirstListenerDidAdd?: Function;\n\tonListenerDidAdd?: Function;\n\tonLastListenerRemove?: Function;\n\tleakWarningThreshold?: number;\n\n\t/** ONLY enable this during development */\n\t_profName?: string\n}\n\n\nclass EventProfiling {\n\n\tprivate static _idPool = 0;\n\n\tprivate _name: string;\n\tprivate _stopWatch?: StopWatch;\n\tprivate _listenerCount: number = 0;\n\tprivate _invocationCount = 0;\n\tprivate _elapsedOverall = 0;\n\n\tconstructor(name: string) {\n\t\tthis._name = `${name}_${EventProfiling._idPool++}`;\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch(true);\n\t\tthis._listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis._elapsedOverall += elapsed;\n\t\t\tthis._invocationCount += 1;\n\n\t\t\tconsole.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly customThreshold?: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tif (this._stacks) {\n\t\t\tthis._stacks.clear();\n\t\t}\n\t}\n\n\tcheck(listenerCount: number): undefined | (() => void) {\n\n\t\tlet threshold = _globalLeakWarningThreshold;\n\t\tif (typeof this.customThreshold === 'number') {\n\t\t\tthreshold = this.customThreshold;\n\t\t}\n\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst stack = new Error().stack!.split('\\n').slice(3).join('\\n');\n\t\tconst count = (this._stacks.get(stack) || 0);\n\t\tthis._stacks.set(stack, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string | undefined;\n\t\t\tlet topCount: number = 0;\n\t\t\tfor (const [stack, count] of this._stacks) {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack) || 0);\n\t\t\tthis._stacks!.set(stack, count - 1);\n\t\t};\n\t}\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate static readonly _noop = function () { };\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed: boolean = false;\n\tprivate _event?: Event<T>;\n\tprivate _deliveryQueue?: LinkedList<[Listener<T>, T]>;\n\tprotected _listeners?: LinkedList<Listener<T>>;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\t\tif (!this._listeners) {\n\t\t\t\t\tthis._listeners = new LinkedList();\n\t\t\t\t}\n\n\t\t\t\tconst firstListener = this._listeners.isEmpty();\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerAdd) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\n\t\t\t\tconst remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n\t\t\t\t\tthis._options.onFirstListenerDidAdd(this);\n\t\t\t\t}\n\n\t\t\t\tif (this._options && this._options.onListenerDidAdd) {\n\t\t\t\t\tthis._options.onListenerDidAdd(this, listener, thisArgs);\n\t\t\t\t}\n\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tconst removeMonitor = this._leakageMon?.check(this._listeners.size);\n\n\t\t\t\tlet result: IDisposable;\n\t\t\t\tresult = {\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tif (removeMonitor) {\n\t\t\t\t\t\t\tremoveMonitor();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.dispose = Emitter._noop;\n\t\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\t\tremove();\n\t\t\t\t\t\t\tif (this._options && this._options.onLastListenerRemove) {\n\t\t\t\t\t\t\t\tconst hasListeners = (this._listeners && !this._listeners.isEmpty());\n\t\t\t\t\t\t\t\tif (!hasListeners) {\n\t\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\t\tdisposables.add(result);\n\t\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\t// put all [listener,event]-pairs into delivery queue\n\t\t\t// then emit all event. an inner/nested event might be\n\t\t\t// the driver of this\n\n\t\t\tif (!this._deliveryQueue) {\n\t\t\t\tthis._deliveryQueue = new LinkedList();\n\t\t\t}\n\n\t\t\tfor (let listener of this._listeners) {\n\t\t\t\tthis._deliveryQueue.push([listener, event]);\n\t\t\t}\n\n\t\t\t// start/stop performance insight collection\n\t\t\tthis._perfMon?.start(this._deliveryQueue.size);\n\n\t\t\twhile (this._deliveryQueue.size > 0) {\n\t\t\t\tconst [listener, event] = this._deliveryQueue.shift()!;\n\t\t\t\ttry {\n\t\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._perfMon?.stop();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._listeners?.clear();\n\t\tthis._deliveryQueue?.clear();\n\t\tthis._leakageMon?.dispose();\n\t\tthis._disposed = true;\n\t}\n}\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprivate _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\tthis._eventQueue.clear();\n\t\t\t\tsuper.fire(this._mergeFn(events));\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null; }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => this.onFirstListenerAdd(),\n\t\t\tonLastListenerRemove: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonFirstListenerDidAdd: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n"]}