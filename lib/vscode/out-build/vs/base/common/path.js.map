{"version":3,"file":"path.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/common/path.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: unknown) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : '..';\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t}\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t`${pathObject.name || ''}${pathObject.ext || ''}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, 'path');\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn resolvedAbsolute ?\n\t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n\t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail = rootEnd < len ?\n\t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n\t\t\t'';\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn isPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\tlen > 2 &&\n\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisPathSeparator(path.charCodeAt(2));\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (slashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (fromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (fromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (toStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (toEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : '.';\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '\\\\'),\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tconst path = i >= 0 ? pathSegments[i] : process.cwd();\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t\treturn trailingSeparator ? './' : '.';\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t} else {\n\t\t\t\t\tjoined += `/${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '/..';\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '/'),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n"]}