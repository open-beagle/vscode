{"version":3,"file":"lazy.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/common/lazy.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAgBhG,MAAa,IAAI;QAMhB,YACkB,QAAiB;YAAjB,aAAQ,GAAR,QAAQ,CAAS;YAL3B,YAAO,GAAY,KAAK,CAAC;QAM7B,CAAC;QAEL;;WAEG;QACH,QAAQ,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QAEnC;;;;;WAKG;QACH,QAAQ;YACP,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBAClB,IAAI;oBACH,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;iBAC9B;gBAAC,OAAO,GAAG,EAAE;oBACb,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;iBAClB;wBAAS;oBACT,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;iBACpB;aACD;YACD,IAAI,IAAI,CAAC,MAAM,EAAE;gBAChB,MAAM,IAAI,CAAC,MAAM,CAAC;aAClB;YACD,OAAO,IAAI,CAAC,MAAO,CAAC;QACrB,CAAC;QAED;;WAEG;QACH,IAAI,QAAQ,KAAoB,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QAErD;;;;WAIG;QACH,GAAG,CAAI,CAAc;YACpB,OAAO,IAAI,IAAI,CAAI,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QAC9C,CAAC;KACD;IAlDD,oBAkDC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A value that is resolved synchronously when it is first needed.\n */\nexport interface Lazy<T> {\n\n\thasValue(): boolean;\n\n\n\tgetValue(): T;\n\n\n\tmap<R>(f: (x: T) => R): Lazy<R>;\n}\n\nexport class Lazy<T> {\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: Error | undefined;\n\n\tconstructor(\n\t\tprivate readonly executor: () => T,\n\t) { }\n\n\t/**\n\t * True if the lazy value has been resolved.\n\t */\n\thasValue() { return this._didRun; }\n\n\t/**\n\t * Get the wrapped value.\n\t *\n\t * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n\t * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n\t */\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\ttry {\n\t\t\t\tthis._value = this.executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\t/**\n\t * Get the wrapped value without forcing evaluation.\n\t */\n\tget rawValue(): T | undefined { return this._value; }\n\n\t/**\n\t * Create a new lazy value that is the result of applying `f` to the wrapped value.\n\t *\n\t * This does not force the evaluation of the current lazy value.\n\t */\n\tmap<R>(f: (x: T) => R): Lazy<R> {\n\t\treturn new Lazy<R>(() => f(this.getValue()));\n\t}\n}\n"]}