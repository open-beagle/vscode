{"version":3,"file":"json.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/common/json.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum ScanError {\n\tNone = 0,\n\tUnexpectedEndOfComment = 1,\n\tUnexpectedEndOfString = 2,\n\tUnexpectedEndOfNumber = 3,\n\tInvalidUnicode = 4,\n\tInvalidEscapeCharacter = 5,\n\tInvalidCharacter = 6\n}\n\nexport const enum SyntaxKind {\n\tOpenBraceToken = 1,\n\tCloseBraceToken = 2,\n\tOpenBracketToken = 3,\n\tCloseBracketToken = 4,\n\tCommaToken = 5,\n\tColonToken = 6,\n\tNullKeyword = 7,\n\tTrueKeyword = 8,\n\tFalseKeyword = 9,\n\tStringLiteral = 10,\n\tNumericLiteral = 11,\n\tLineCommentTrivia = 12,\n\tBlockCommentTrivia = 13,\n\tLineBreakTrivia = 14,\n\tTrivia = 15,\n\tUnknown = 16,\n\tEOF = 17\n}\n\n/**\n * The scanner object, representing a JSON scanner at a position in the input string.\n */\nexport interface JSONScanner {\n\t/**\n\t * Sets the scan position to a new offset. A call to 'scan' is needed to get the first token.\n\t */\n\tsetPosition(pos: number): void;\n\t/**\n\t * Read the next token. Returns the token code.\n\t */\n\tscan(): SyntaxKind;\n\t/**\n\t * Returns the current scan position, which is after the last read token.\n\t */\n\tgetPosition(): number;\n\t/**\n\t * Returns the last read token.\n\t */\n\tgetToken(): SyntaxKind;\n\t/**\n\t * Returns the last read token value. The value for strings is the decoded string content. For numbers its of type number, for boolean it's true or false.\n\t */\n\tgetTokenValue(): string;\n\t/**\n\t * The start offset of the last read token.\n\t */\n\tgetTokenOffset(): number;\n\t/**\n\t * The length of the last read token.\n\t */\n\tgetTokenLength(): number;\n\t/**\n\t * An error code of the last scan.\n\t */\n\tgetTokenError(): ScanError;\n}\n\n\n\nexport interface ParseError {\n\terror: ParseErrorCode;\n\toffset: number;\n\tlength: number;\n}\n\nexport const enum ParseErrorCode {\n\tInvalidSymbol = 1,\n\tInvalidNumberFormat = 2,\n\tPropertyNameExpected = 3,\n\tValueExpected = 4,\n\tColonExpected = 5,\n\tCommaExpected = 6,\n\tCloseBraceExpected = 7,\n\tCloseBracketExpected = 8,\n\tEndOfFileExpected = 9,\n\tInvalidCommentToken = 10,\n\tUnexpectedEndOfComment = 11,\n\tUnexpectedEndOfString = 12,\n\tUnexpectedEndOfNumber = 13,\n\tInvalidUnicode = 14,\n\tInvalidEscapeCharacter = 15,\n\tInvalidCharacter = 16\n}\n\nexport type NodeType = 'object' | 'array' | 'property' | 'string' | 'number' | 'boolean' | 'null';\n\nexport interface Node {\n\treadonly type: NodeType;\n\treadonly value?: any;\n\treadonly offset: number;\n\treadonly length: number;\n\treadonly colonOffset?: number;\n\treadonly parent?: Node;\n\treadonly children?: Node[];\n}\n\nexport type Segment = string | number;\nexport type JSONPath = Segment[];\n\nexport interface Location {\n\t/**\n\t * The previous property key or literal value (string, number, boolean or null) or undefined.\n\t */\n\tpreviousNode?: Node;\n\t/**\n\t * The path describing the location in the JSON document. The path consists of a sequence strings\n\t * representing an object property or numbers for array indices.\n\t */\n\tpath: JSONPath;\n\t/**\n\t * Matches the locations path against a pattern consisting of strings (for properties) and numbers (for array indices).\n\t * '*' will match a single segment, of any property name or index.\n\t * '**' will match a sequence of segments or no segment, of any property name or index.\n\t */\n\tmatches: (patterns: JSONPath) => boolean;\n\t/**\n\t * If set, the location's offset is at a property key.\n\t */\n\tisAtPropertyKey: boolean;\n}\n\nexport interface ParseOptions {\n\tdisallowComments?: boolean;\n\tallowTrailingComma?: boolean;\n\tallowEmptyContent?: boolean;\n}\n\nexport namespace ParseOptions {\n\texport const DEFAULT = {\n\t\tallowTrailingComma: true\n\t};\n}\n\nexport interface JSONVisitor {\n\t/**\n\t * Invoked when an open brace is encountered and an object is started. The offset and length represent the location of the open brace.\n\t */\n\tonObjectBegin?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a property is encountered. The offset and length represent the location of the property name.\n\t */\n\tonObjectProperty?: (property: string, offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a closing brace is encountered and an object is completed. The offset and length represent the location of the closing brace.\n\t */\n\tonObjectEnd?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when an open bracket is encountered. The offset and length represent the location of the open bracket.\n\t */\n\tonArrayBegin?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a closing bracket is encountered. The offset and length represent the location of the closing bracket.\n\t */\n\tonArrayEnd?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a literal value is encountered. The offset and length represent the location of the literal value.\n\t */\n\tonLiteralValue?: (value: any, offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a comma or colon separator is encountered. The offset and length represent the location of the separator.\n\t */\n\tonSeparator?: (character: string, offset: number, length: number) => void;\n\n\t/**\n\t * When comments are allowed, invoked when a line or block comment is encountered. The offset and length represent the location of the comment.\n\t */\n\tonComment?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked on an error.\n\t */\n\tonError?: (error: ParseErrorCode, offset: number, length: number) => void;\n}\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text: string, ignoreTrivia: boolean = false): JSONScanner {\n\n\tlet pos = 0,\n\t\tlen = text.length,\n\t\tvalue: string = '',\n\t\ttokenOffset = 0,\n\t\ttoken: SyntaxKind = SyntaxKind.Unknown,\n\t\tscanError: ScanError = ScanError.None;\n\n\tfunction scanHexDigits(count: number): number {\n\t\tlet digits = 0;\n\t\tlet hexValue = 0;\n\t\twhile (digits < count) {\n\t\t\tconst ch = text.charCodeAt(pos);\n\t\t\tif (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes._0;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes.A + 10;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n\t\t\t\thexValue = hexValue * 16 + ch - CharacterCodes.a + 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t\tdigits++;\n\t\t}\n\t\tif (digits < count) {\n\t\t\thexValue = -1;\n\t\t}\n\t\treturn hexValue;\n\t}\n\n\tfunction setPosition(newPosition: number) {\n\t\tpos = newPosition;\n\t\tvalue = '';\n\t\ttokenOffset = 0;\n\t\ttoken = SyntaxKind.Unknown;\n\t\tscanError = ScanError.None;\n\t}\n\n\tfunction scanNumber(): string {\n\t\tconst start = pos;\n\t\tif (text.charCodeAt(pos) === CharacterCodes._0) {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos++;\n\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t\treturn text.substring(start, pos);\n\t\t\t}\n\t\t}\n\t\tlet end = pos;\n\t\tif (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tend = pos;\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t}\n\t\t}\n\t\treturn text.substring(start, end);\n\t}\n\n\tfunction scanString(): string {\n\n\t\tlet result = '',\n\t\t\tstart = pos;\n\n\t\twhile (true) {\n\t\t\tif (pos >= len) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst ch = text.charCodeAt(pos);\n\t\t\tif (ch === CharacterCodes.doubleQuote) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch === CharacterCodes.backslash) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tif (pos >= len) {\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst ch2 = text.charCodeAt(pos++);\n\t\t\t\tswitch (ch2) {\n\t\t\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\t\t\tresult += '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.backslash:\n\t\t\t\t\t\tresult += '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.slash:\n\t\t\t\t\t\tresult += '/';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.b:\n\t\t\t\t\t\tresult += '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.f:\n\t\t\t\t\t\tresult += '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.n:\n\t\t\t\t\t\tresult += '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.r:\n\t\t\t\t\t\tresult += '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.t:\n\t\t\t\t\t\tresult += '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.u:\n\t\t\t\t\t\tconst ch3 = scanHexDigits(4);\n\t\t\t\t\t\tif (ch3 >= 0) {\n\t\t\t\t\t\t\tresult += String.fromCharCode(ch3);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscanError = ScanError.InvalidUnicode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tscanError = ScanError.InvalidEscapeCharacter;\n\t\t\t\t}\n\t\t\t\tstart = pos;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch >= 0 && ch <= 0x1F) {\n\t\t\t\tif (isLineBreak(ch)) {\n\t\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tscanError = ScanError.InvalidCharacter;\n\t\t\t\t\t// mark as error but continue with string\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction scanNext(): SyntaxKind {\n\n\t\tvalue = '';\n\t\tscanError = ScanError.None;\n\n\t\ttokenOffset = pos;\n\n\t\tif (pos >= len) {\n\t\t\t// at the end\n\t\t\ttokenOffset = len;\n\t\t\treturn token = SyntaxKind.EOF;\n\t\t}\n\n\t\tlet code = text.charCodeAt(pos);\n\t\t// trivia: whitespace\n\t\tif (isWhitespace(code)) {\n\t\t\tdo {\n\t\t\t\tpos++;\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t} while (isWhitespace(code));\n\n\t\t\treturn token = SyntaxKind.Trivia;\n\t\t}\n\n\t\t// trivia: newlines\n\t\tif (isLineBreak(code)) {\n\t\t\tpos++;\n\t\t\tvalue += String.fromCharCode(code);\n\t\t\tif (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n\t\t\t\tpos++;\n\t\t\t\tvalue += '\\n';\n\t\t\t}\n\t\t\treturn token = SyntaxKind.LineBreakTrivia;\n\t\t}\n\n\t\tswitch (code) {\n\t\t\t// tokens: []{}:,\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBraceToken;\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBraceToken;\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBracketToken;\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBracketToken;\n\t\t\tcase CharacterCodes.colon:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.ColonToken;\n\t\t\tcase CharacterCodes.comma:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CommaToken;\n\n\t\t\t// strings\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\tpos++;\n\t\t\t\tvalue = scanString();\n\t\t\t\treturn token = SyntaxKind.StringLiteral;\n\n\t\t\t// comments\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\tconst start = pos - 1;\n\t\t\t\t// Single-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\twhile (pos < len) {\n\t\t\t\t\t\tif (isLineBreak(text.charCodeAt(pos))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\n\t\t\t\t\t}\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.LineCommentTrivia;\n\t\t\t\t}\n\n\t\t\t\t// Multi-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\tconst safeLength = len - 1; // For lookahead.\n\t\t\t\t\tlet commentClosed = false;\n\t\t\t\t\twhile (pos < safeLength) {\n\t\t\t\t\t\tconst ch = text.charCodeAt(pos);\n\n\t\t\t\t\t\tif (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\t\t\tpos += 2;\n\t\t\t\t\t\t\tcommentClosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!commentClosed) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tscanError = ScanError.UnexpectedEndOfComment;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.BlockCommentTrivia;\n\t\t\t\t}\n\t\t\t\t// just a single slash\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\n\t\t\t// numbers\n\t\t\tcase CharacterCodes.minus:\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\tif (pos === len || !isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t// found a minus, followed by a number so\n\t\t\t// we fall through to proceed with scanning\n\t\t\t// numbers\n\t\t\tcase CharacterCodes._0:\n\t\t\tcase CharacterCodes._1:\n\t\t\tcase CharacterCodes._2:\n\t\t\tcase CharacterCodes._3:\n\t\t\tcase CharacterCodes._4:\n\t\t\tcase CharacterCodes._5:\n\t\t\tcase CharacterCodes._6:\n\t\t\tcase CharacterCodes._7:\n\t\t\tcase CharacterCodes._8:\n\t\t\tcase CharacterCodes._9:\n\t\t\t\tvalue += scanNumber();\n\t\t\t\treturn token = SyntaxKind.NumericLiteral;\n\t\t\t// literals and unknown symbols\n\t\t\tdefault:\n\t\t\t\t// is a literal? Read the full word.\n\t\t\t\twhile (pos < len && isUnknownContentCharacter(code)) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t\t}\n\t\t\t\tif (tokenOffset !== pos) {\n\t\t\t\t\tvalue = text.substring(tokenOffset, pos);\n\t\t\t\t\t// keywords: true, false, null\n\t\t\t\t\tswitch (value) {\n\t\t\t\t\t\tcase 'true': return token = SyntaxKind.TrueKeyword;\n\t\t\t\t\t\tcase 'false': return token = SyntaxKind.FalseKeyword;\n\t\t\t\t\t\tcase 'null': return token = SyntaxKind.NullKeyword;\n\t\t\t\t\t}\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t\t// some\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t}\n\t}\n\n\tfunction isUnknownContentCharacter(code: CharacterCodes) {\n\t\tif (isWhitespace(code) || isLineBreak(code)) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (code) {\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\tcase CharacterCodes.colon:\n\t\t\tcase CharacterCodes.comma:\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tfunction scanNextNonTrivia(): SyntaxKind {\n\t\tlet result: SyntaxKind;\n\t\tdo {\n\t\t\tresult = scanNext();\n\t\t} while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n\t\treturn result;\n\t}\n\n\treturn {\n\t\tsetPosition: setPosition,\n\t\tgetPosition: () => pos,\n\t\tscan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n\t\tgetToken: () => token,\n\t\tgetTokenValue: () => value,\n\t\tgetTokenOffset: () => tokenOffset,\n\t\tgetTokenLength: () => pos - tokenOffset,\n\t\tgetTokenError: () => scanError\n\t};\n}\n\nfunction isWhitespace(ch: number): boolean {\n\treturn ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n\t\tch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n\t\tch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n}\n\nfunction isLineBreak(ch: number): boolean {\n\treturn ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n}\n\nfunction isDigit(ch: number): boolean {\n\treturn ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n}\n\nconst enum CharacterCodes {\n\tnullCharacter = 0,\n\tmaxAsciiCharacter = 0x7F,\n\n\tlineFeed = 0x0A,              // \\n\n\tcarriageReturn = 0x0D,        // \\r\n\tlineSeparator = 0x2028,\n\tparagraphSeparator = 0x2029,\n\n\t// REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n\t// like an odd disparity?  (Or maybe it's completely fine for them to be different).\n\tnextLine = 0x0085,\n\n\t// Unicode 3.0 space characters\n\tspace = 0x0020,   // \" \"\n\tnonBreakingSpace = 0x00A0,   //\n\tenQuad = 0x2000,\n\temQuad = 0x2001,\n\tenSpace = 0x2002,\n\temSpace = 0x2003,\n\tthreePerEmSpace = 0x2004,\n\tfourPerEmSpace = 0x2005,\n\tsixPerEmSpace = 0x2006,\n\tfigureSpace = 0x2007,\n\tpunctuationSpace = 0x2008,\n\tthinSpace = 0x2009,\n\thairSpace = 0x200A,\n\tzeroWidthSpace = 0x200B,\n\tnarrowNoBreakSpace = 0x202F,\n\tideographicSpace = 0x3000,\n\tmathematicalSpace = 0x205F,\n\togham = 0x1680,\n\n\t_ = 0x5F,\n\t$ = 0x24,\n\n\t_0 = 0x30,\n\t_1 = 0x31,\n\t_2 = 0x32,\n\t_3 = 0x33,\n\t_4 = 0x34,\n\t_5 = 0x35,\n\t_6 = 0x36,\n\t_7 = 0x37,\n\t_8 = 0x38,\n\t_9 = 0x39,\n\n\ta = 0x61,\n\tb = 0x62,\n\tc = 0x63,\n\td = 0x64,\n\te = 0x65,\n\tf = 0x66,\n\tg = 0x67,\n\th = 0x68,\n\ti = 0x69,\n\tj = 0x6A,\n\tk = 0x6B,\n\tl = 0x6C,\n\tm = 0x6D,\n\tn = 0x6E,\n\to = 0x6F,\n\tp = 0x70,\n\tq = 0x71,\n\tr = 0x72,\n\ts = 0x73,\n\tt = 0x74,\n\tu = 0x75,\n\tv = 0x76,\n\tw = 0x77,\n\tx = 0x78,\n\ty = 0x79,\n\tz = 0x7A,\n\n\tA = 0x41,\n\tB = 0x42,\n\tC = 0x43,\n\tD = 0x44,\n\tE = 0x45,\n\tF = 0x46,\n\tG = 0x47,\n\tH = 0x48,\n\tI = 0x49,\n\tJ = 0x4A,\n\tK = 0x4B,\n\tL = 0x4C,\n\tM = 0x4D,\n\tN = 0x4E,\n\tO = 0x4F,\n\tP = 0x50,\n\tQ = 0x51,\n\tR = 0x52,\n\tS = 0x53,\n\tT = 0x54,\n\tU = 0x55,\n\tV = 0x56,\n\tW = 0x57,\n\tX = 0x58,\n\tY = 0x59,\n\tZ = 0x5A,\n\n\tampersand = 0x26,             // &\n\tasterisk = 0x2A,              // *\n\tat = 0x40,                    // @\n\tbackslash = 0x5C,             // \\\n\tbar = 0x7C,                   // |\n\tcaret = 0x5E,                 // ^\n\tcloseBrace = 0x7D,            // }\n\tcloseBracket = 0x5D,          // ]\n\tcloseParen = 0x29,            // )\n\tcolon = 0x3A,                 // :\n\tcomma = 0x2C,                 // ,\n\tdot = 0x2E,                   // .\n\tdoubleQuote = 0x22,           // \"\n\tequals = 0x3D,                // =\n\texclamation = 0x21,           // !\n\tgreaterThan = 0x3E,           // >\n\tlessThan = 0x3C,              // <\n\tminus = 0x2D,                 // -\n\topenBrace = 0x7B,             // {\n\topenBracket = 0x5B,           // [\n\topenParen = 0x28,             // (\n\tpercent = 0x25,               // %\n\tplus = 0x2B,                  // +\n\tquestion = 0x3F,              // ?\n\tsemicolon = 0x3B,             // ;\n\tsingleQuote = 0x27,           // '\n\tslash = 0x2F,                 // /\n\ttilde = 0x7E,                 // ~\n\n\tbackspace = 0x08,             // \\b\n\tformFeed = 0x0C,              // \\f\n\tbyteOrderMark = 0xFEFF,\n\ttab = 0x09,                   // \\t\n\tverticalTab = 0x0B,           // \\v\n}\n\ninterface NodeImpl extends Node {\n\ttype: NodeType;\n\tvalue?: any;\n\toffset: number;\n\tlength: number;\n\tcolonOffset?: number;\n\tparent?: NodeImpl;\n\tchildren?: NodeImpl[];\n}\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text: string, position: number): Location {\n\tconst segments: Segment[] = []; // strings or numbers\n\tconst earlyReturnException = new Object();\n\tlet previousNode: NodeImpl | undefined = undefined;\n\tconst previousNodeInst: NodeImpl = {\n\t\tvalue: {},\n\t\toffset: 0,\n\t\tlength: 0,\n\t\ttype: 'object',\n\t\tparent: undefined\n\t};\n\tlet isAtPropertyKey = false;\n\tfunction setPreviousNode(value: string, offset: number, length: number, type: NodeType) {\n\t\tpreviousNodeInst.value = value;\n\t\tpreviousNodeInst.offset = offset;\n\t\tpreviousNodeInst.length = length;\n\t\tpreviousNodeInst.type = type;\n\t\tpreviousNodeInst.colonOffset = undefined;\n\t\tpreviousNode = previousNodeInst;\n\t}\n\ttry {\n\n\t\tvisit(text, {\n\t\t\tonObjectBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tisAtPropertyKey = position > offset;\n\t\t\t\tsegments.push(''); // push a placeholder (will be replaced)\n\t\t\t},\n\t\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(name, offset, length, 'property');\n\t\t\t\tsegments[segments.length - 1] = name;\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.push(0);\n\t\t\t},\n\t\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(value, offset, length, getNodeType(value));\n\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tif (sep === ':' && previousNode && previousNode.type === 'property') {\n\t\t\t\t\tpreviousNode.colonOffset = offset;\n\t\t\t\t\tisAtPropertyKey = false;\n\t\t\t\t\tpreviousNode = undefined;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tconst last = segments[segments.length - 1];\n\t\t\t\t\tif (typeof last === 'number') {\n\t\t\t\t\t\tsegments[segments.length - 1] = last + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisAtPropertyKey = true;\n\t\t\t\t\t\tsegments[segments.length - 1] = '';\n\t\t\t\t\t}\n\t\t\t\t\tpreviousNode = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (e) {\n\t\tif (e !== earlyReturnException) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treturn {\n\t\tpath: segments,\n\t\tpreviousNode,\n\t\tisAtPropertyKey,\n\t\tmatches: (pattern: Segment[]) => {\n\t\t\tlet k = 0;\n\t\t\tfor (let i = 0; k < pattern.length && i < segments.length; i++) {\n\t\t\t\tif (pattern[k] === segments[i] || pattern[k] === '*') {\n\t\t\t\t\tk++;\n\t\t\t\t} else if (pattern[k] !== '**') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn k === pattern.length;\n\t\t}\n\t};\n}\n\n\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text: string, errors: ParseError[] = [], options: ParseOptions = ParseOptions.DEFAULT): any {\n\tlet currentProperty: string | null = null;\n\tlet currentParent: any = [];\n\tconst previousParents: any[] = [];\n\n\tfunction onValue(value: any) {\n\t\tif (Array.isArray(currentParent)) {\n\t\t\t(<any[]>currentParent).push(value);\n\t\t} else if (currentProperty !== null) {\n\t\t\tcurrentParent[currentProperty] = value;\n\t\t}\n\t}\n\n\tconst visitor: JSONVisitor = {\n\t\tonObjectBegin: () => {\n\t\t\tconst object = {};\n\t\t\tonValue(object);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = object;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonObjectProperty: (name: string) => {\n\t\t\tcurrentProperty = name;\n\t\t},\n\t\tonObjectEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonArrayBegin: () => {\n\t\t\tconst array: any[] = [];\n\t\t\tonValue(array);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = array;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonArrayEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonLiteralValue: onValue,\n\t\tonError: (error: ParseErrorCode, offset: number, length: number) => {\n\t\t\terrors.push({ error, offset, length });\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\treturn currentParent[0];\n}\n\n\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text: string, errors: ParseError[] = [], options: ParseOptions = ParseOptions.DEFAULT): Node {\n\tlet currentParent: NodeImpl = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n\n\tfunction ensurePropertyComplete(endOffset: number) {\n\t\tif (currentParent.type === 'property') {\n\t\t\tcurrentParent.length = endOffset - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t}\n\t}\n\n\tfunction onValue(valueNode: Node): Node {\n\t\tcurrentParent.children!.push(valueNode);\n\t\treturn valueNode;\n\t}\n\n\tconst visitor: JSONVisitor = {\n\t\tonObjectBegin: (offset: number) => {\n\t\t\tcurrentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n\t\t\tcurrentParent.children!.push({ type: 'string', value: name, offset, length, parent: currentParent });\n\t\t},\n\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\tonValue({ type: getNodeType(value), offset, length, parent: currentParent, value });\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\tif (currentParent.type === 'property') {\n\t\t\t\tif (sep === ':') {\n\t\t\t\t\tcurrentParent.colonOffset = offset;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tensurePropertyComplete(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonError: (error: ParseErrorCode, offset: number, length: number) => {\n\t\t\terrors.push({ error, offset, length });\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\n\tconst result = currentParent.children![0];\n\tif (result) {\n\t\tdelete result.parent;\n\t}\n\treturn result;\n}\n\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root: Node, path: JSONPath): Node | undefined {\n\tif (!root) {\n\t\treturn undefined;\n\t}\n\tlet node = root;\n\tfor (let segment of path) {\n\t\tif (typeof segment === 'string') {\n\t\t\tif (node.type !== 'object' || !Array.isArray(node.children)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tlet found = false;\n\t\t\tfor (const propertyNode of node.children) {\n\t\t\t\tif (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n\t\t\t\t\tnode = propertyNode.children[1];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tconst index = <number>segment;\n\t\t\tif (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tnode = node.children[index];\n\t\t}\n\t}\n\treturn node;\n}\n\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node: Node): JSONPath {\n\tif (!node.parent || !node.parent.children) {\n\t\treturn [];\n\t}\n\tconst path = getNodePath(node.parent);\n\tif (node.parent.type === 'property') {\n\t\tconst key = node.parent.children[0].value;\n\t\tpath.push(key);\n\t} else if (node.parent.type === 'array') {\n\t\tconst index = node.parent.children.indexOf(node);\n\t\tif (index !== -1) {\n\t\t\tpath.push(index);\n\t\t}\n\t}\n\treturn path;\n}\n\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node: Node): any {\n\tswitch (node.type) {\n\t\tcase 'array':\n\t\t\treturn node.children!.map(getNodeValue);\n\t\tcase 'object':\n\t\t\tconst obj = Object.create(null);\n\t\t\tfor (let prop of node.children!) {\n\t\t\t\tconst valueNode = prop.children![1];\n\t\t\t\tif (valueNode) {\n\t\t\t\t\tobj[prop.children![0].value] = getNodeValue(valueNode);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\tcase 'null':\n\t\tcase 'string':\n\t\tcase 'number':\n\t\tcase 'boolean':\n\t\t\treturn node.value;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n\n}\n\nexport function contains(node: Node, offset: number, includeRightBound = false): boolean {\n\treturn (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node: Node, offset: number, includeRightBound = false): Node | undefined {\n\tif (contains(node, offset, includeRightBound)) {\n\t\tconst children = node.children;\n\t\tif (Array.isArray(children)) {\n\t\t\tfor (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n\t\t\t\tconst item = findNodeAtOffset(children[i], offset, includeRightBound);\n\t\t\t\tif (item) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text: string, visitor: JSONVisitor, options: ParseOptions = ParseOptions.DEFAULT): any {\n\n\tconst _scanner = createScanner(text, false);\n\n\tfunction toNoArgVisit(visitFunction?: (offset: number, length: number) => void): () => void {\n\t\treturn visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\tfunction toOneArgVisit<T>(visitFunction?: (arg: T, offset: number, length: number) => void): (arg: T) => void {\n\t\treturn visitFunction ? (arg: T) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\n\tconst onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n\t\tonObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n\t\tonObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n\t\tonArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n\t\tonArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n\t\tonLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n\t\tonSeparator = toOneArgVisit(visitor.onSeparator),\n\t\tonComment = toNoArgVisit(visitor.onComment),\n\t\tonError = toOneArgVisit(visitor.onError);\n\n\tconst disallowComments = options && options.disallowComments;\n\tconst allowTrailingComma = options && options.allowTrailingComma;\n\tfunction scanNext(): SyntaxKind {\n\t\twhile (true) {\n\t\t\tconst token = _scanner.scan();\n\t\t\tswitch (_scanner.getTokenError()) {\n\t\t\t\tcase ScanError.InvalidUnicode:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidUnicode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.InvalidEscapeCharacter:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidEscapeCharacter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfNumber:\n\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfNumber);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfComment:\n\t\t\t\t\tif (!disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfComment);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfString:\n\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfString);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.InvalidCharacter:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidCharacter);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (token) {\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidCommentToken);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonComment();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidSymbol);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Trivia:\n\t\t\t\tcase SyntaxKind.LineBreakTrivia:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleError(error: ParseErrorCode, skipUntilAfter: SyntaxKind[] = [], skipUntil: SyntaxKind[] = []): void {\n\t\tonError(error);\n\t\tif (skipUntilAfter.length + skipUntil.length > 0) {\n\t\t\tlet token = _scanner.getToken();\n\t\t\twhile (token !== SyntaxKind.EOF) {\n\t\t\t\tif (skipUntilAfter.indexOf(token) !== -1) {\n\t\t\t\t\tscanNext();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (skipUntil.indexOf(token) !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttoken = scanNext();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString(isValue: boolean): boolean {\n\t\tconst value = _scanner.getTokenValue();\n\t\tif (isValue) {\n\t\t\tonLiteralValue(value);\n\t\t} else {\n\t\t\tonObjectProperty(value);\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseLiteral(): boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.NumericLiteral:\n\t\t\t\tlet value = 0;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = JSON.parse(_scanner.getTokenValue());\n\t\t\t\t\tif (typeof value !== 'number') {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t}\n\t\t\t\tonLiteralValue(value);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tonLiteralValue(null);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tonLiteralValue(true);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tonLiteralValue(false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseProperty(): boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n\t\t\thandleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\treturn false;\n\t\t}\n\t\tparseString(false);\n\t\tif (_scanner.getToken() === SyntaxKind.ColonToken) {\n\t\t\tonSeparator(':');\n\t\t\tscanNext(); // consume colon\n\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t} else {\n\t\t\thandleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseObject(): boolean {\n\t\tonObjectBegin();\n\t\tscanNext(); // consume open brace\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t\tif (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], []);\n\t\t\t}\n\t\t\tif (!parseProperty()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonObjectEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n\t\t\thandleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close brace\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseArray(): boolean {\n\t\tonArrayBegin();\n\t\tscanNext(); // consume open bracket\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t\tif (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], []);\n\t\t\t}\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonArrayEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n\t\t\thandleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close bracket\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseValue(): boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.OpenBracketToken:\n\t\t\t\treturn parseArray();\n\t\t\tcase SyntaxKind.OpenBraceToken:\n\t\t\t\treturn parseObject();\n\t\t\tcase SyntaxKind.StringLiteral:\n\t\t\t\treturn parseString(true);\n\t\t\tdefault:\n\t\t\t\treturn parseLiteral();\n\t\t}\n\t}\n\n\tscanNext();\n\tif (_scanner.getToken() === SyntaxKind.EOF) {\n\t\tif (options.allowEmptyContent) {\n\t\t\treturn true;\n\t\t}\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (!parseValue()) {\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (_scanner.getToken() !== SyntaxKind.EOF) {\n\t\thandleError(ParseErrorCode.EndOfFileExpected, [], []);\n\t}\n\treturn true;\n}\n\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text: string, replaceCh?: string): string {\n\n\tlet _scanner = createScanner(text),\n\t\tparts: string[] = [],\n\t\tkind: SyntaxKind,\n\t\toffset = 0,\n\t\tpos: number;\n\n\tdo {\n\t\tpos = _scanner.getPosition();\n\t\tkind = _scanner.scan();\n\t\tswitch (kind) {\n\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\tcase SyntaxKind.EOF:\n\t\t\t\tif (offset !== pos) {\n\t\t\t\t\tparts.push(text.substring(offset, pos));\n\t\t\t\t}\n\t\t\t\tif (replaceCh !== undefined) {\n\t\t\t\t\tparts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n\t\t\t\t}\n\t\t\t\toffset = _scanner.getPosition();\n\t\t\t\tbreak;\n\t\t}\n\t} while (kind !== SyntaxKind.EOF);\n\n\treturn parts.join('');\n}\n\nexport function getNodeType(value: any): NodeType {\n\tswitch (typeof value) {\n\t\tcase 'boolean': return 'boolean';\n\t\tcase 'number': return 'number';\n\t\tcase 'string': return 'string';\n\t\tcase 'object': {\n\t\t\tif (!value) {\n\t\t\t\treturn 'null';\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\treturn 'array';\n\t\t\t}\n\t\t\treturn 'object';\n\t\t}\n\t\tdefault: return 'null';\n\t}\n}\n"]}