{"version":3,"file":"labels.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/common/labels.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { posix, normalize, win32, sep } from 'vs/base/common/path';\nimport { startsWithIgnoreCase, rtrim } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows, isMacintosh } from 'vs/base/common/platform';\nimport { isEqual, basename, relativePath } from 'vs/base/common/resources';\nimport { hasDriveLetter, isRootOrDriveLetter } from 'vs/base/common/extpath';\n\nexport interface IWorkspaceFolderProvider {\n\tgetWorkspaceFolder(resource: URI): { uri: URI, name?: string; } | null;\n\tgetWorkspace(): {\n\t\tfolders: { uri: URI, name?: string; }[];\n\t};\n}\n\nexport interface IUserHomeProvider {\n\tuserHome?: URI;\n}\n\n/**\n * @deprecated use LabelService instead\n */\nexport function getPathLabel(resource: URI | string, userHomeProvider?: IUserHomeProvider, rootProvider?: IWorkspaceFolderProvider): string {\n\tif (typeof resource === 'string') {\n\t\tresource = URI.file(resource);\n\t}\n\n\t// return early if we can resolve a relative path label from the root\n\tif (rootProvider) {\n\t\tconst baseResource = rootProvider.getWorkspaceFolder(resource);\n\t\tif (baseResource) {\n\t\t\tconst hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\n\n\t\t\tlet pathLabel: string;\n\t\t\tif (isEqual(baseResource.uri, resource)) {\n\t\t\t\tpathLabel = ''; // no label if paths are identical\n\t\t\t} else {\n\t\t\t\tpathLabel = relativePath(baseResource.uri, resource)!;\n\t\t\t}\n\n\t\t\tif (hasMultipleRoots) {\n\t\t\t\tconst rootName = baseResource.name ? baseResource.name : basename(baseResource.uri);\n\t\t\t\tpathLabel = pathLabel ? (rootName + ' â€¢ ' + pathLabel) : rootName; // always show root basename if there are multiple\n\t\t\t}\n\n\t\t\treturn pathLabel;\n\t\t}\n\t}\n\n\t// return if the resource is neither file:// nor untitled:// and no baseResource was provided\n\tif (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {\n\t\treturn resource.with({ query: null, fragment: null }).toString(true);\n\t}\n\n\t// convert c:\\something => C:\\something\n\tif (hasDriveLetter(resource.fsPath)) {\n\t\treturn normalize(normalizeDriveLetter(resource.fsPath));\n\t}\n\n\t// normalize and tildify (macOS, Linux only)\n\tlet res = normalize(resource.fsPath);\n\tif (!isWindows && userHomeProvider?.userHome) {\n\t\tres = tildify(res, userHomeProvider.userHome.fsPath);\n\t}\n\n\treturn res;\n}\n\nexport function getBaseLabel(resource: URI | string): string;\nexport function getBaseLabel(resource: URI | string | undefined): string | undefined;\nexport function getBaseLabel(resource: URI | string | undefined): string | undefined {\n\tif (!resource) {\n\t\treturn undefined;\n\t}\n\n\tif (typeof resource === 'string') {\n\t\tresource = URI.file(resource);\n\t}\n\n\tconst base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;\n\n\t// convert c: => C:\n\tif (isWindows && isRootOrDriveLetter(base)) {\n\t\treturn normalizeDriveLetter(base);\n\t}\n\n\treturn base;\n}\n\nexport function normalizeDriveLetter(path: string): string {\n\tif (hasDriveLetter(path)) {\n\t\treturn path.charAt(0).toUpperCase() + path.slice(1);\n\t}\n\n\treturn path;\n}\n\nlet normalizedUserHomeCached: { original: string; normalized: string; } = Object.create(null);\nexport function tildify(path: string, userHome: string): string {\n\tif (isWindows || !path || !userHome) {\n\t\treturn path; // unsupported\n\t}\n\n\t// Keep a normalized user home path as cache to prevent accumulated string creation\n\tlet normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\tif (!normalizedUserHome) {\n\t\tnormalizedUserHome = `${rtrim(userHome, posix.sep)}${posix.sep}`;\n\t\tnormalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n\t}\n\n\t// Linux: case sensitive, macOS: case insensitive\n\tif (isLinux ? path.startsWith(normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {\n\t\tpath = `~/${path.substr(normalizedUserHome.length)}`;\n\t}\n\n\treturn path;\n}\n\nexport function untildify(path: string, userHome: string): string {\n\treturn path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\n\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nconst ellipsis = '\\u2026';\nconst unc = '\\\\\\\\';\nconst home = '~';\nexport function shorten(paths: string[], pathSeparator: string = sep): string[] {\n\tconst shortenedPaths: string[] = new Array(paths.length);\n\n\t// for every path\n\tlet match = false;\n\tfor (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n\t\tlet path = paths[pathIndex];\n\n\t\tif (path === '') {\n\t\t\tshortenedPaths[pathIndex] = `.${pathSeparator}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!path) {\n\t\t\tshortenedPaths[pathIndex] = path;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = true;\n\n\t\t// trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n\t\tlet prefix = '';\n\t\tif (path.indexOf(unc) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(unc) + unc.length);\n\t\t\tpath = path.substr(path.indexOf(unc) + unc.length);\n\t\t} else if (path.indexOf(pathSeparator) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(pathSeparator) + pathSeparator.length);\n\t\t\tpath = path.substr(path.indexOf(pathSeparator) + pathSeparator.length);\n\t\t} else if (path.indexOf(home) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(home) + home.length);\n\t\t\tpath = path.substr(path.indexOf(home) + home.length);\n\t\t}\n\n\t\t// pick the first shortest subpath found\n\t\tconst segments: string[] = path.split(pathSeparator);\n\t\tfor (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n\t\t\tfor (let start = segments.length - subpathLength; match && start >= 0; start--) {\n\t\t\t\tmatch = false;\n\t\t\t\tlet subpath = segments.slice(start, start + subpathLength).join(pathSeparator);\n\n\t\t\t\t// that is unique to any other path\n\t\t\t\tfor (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n\n\t\t\t\t\t// suffix subpath treated specially as we consider no match 'x' and 'x/...'\n\t\t\t\t\tif (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n\t\t\t\t\t\tconst isSubpathEnding: boolean = (start + subpathLength === segments.length);\n\n\t\t\t\t\t\t// Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n\t\t\t\t\t\t// prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n\t\t\t\t\t\tconst subpathWithSep: string = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;\n\t\t\t\t\t\tconst isOtherPathEnding: boolean = paths[otherPathIndex].endsWith(subpathWithSep);\n\n\t\t\t\t\t\tmatch = !isSubpathEnding || isOtherPathEnding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// found unique subpath\n\t\t\t\tif (!match) {\n\t\t\t\t\tlet result = '';\n\n\t\t\t\t\t// preserve disk drive or root prefix\n\t\t\t\t\tif (segments[0].endsWith(':') || prefix !== '') {\n\t\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\t\t// extend subpath to include disk drive prefix\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tsubpathLength++;\n\t\t\t\t\t\t\tsubpath = segments[0] + pathSeparator + subpath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\t\tresult = segments[0] + pathSeparator;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult = prefix + result;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add ellipsis at the beginning if neeeded\n\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\tresult = result + ellipsis + pathSeparator;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = result + subpath;\n\n\t\t\t\t\t// add ellipsis at the end if needed\n\t\t\t\t\tif (start + subpathLength < segments.length) {\n\t\t\t\t\t\tresult = result + pathSeparator + ellipsis;\n\t\t\t\t\t}\n\n\t\t\t\t\tshortenedPaths[pathIndex] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tshortenedPaths[pathIndex] = path; // use full path if no unique subpaths found\n\t\t}\n\t}\n\n\treturn shortenedPaths;\n}\n\nexport interface ISeparator {\n\tlabel: string;\n}\n\nenum Type {\n\tTEXT,\n\tVARIABLE,\n\tSEPARATOR\n}\n\ninterface ISegment {\n\tvalue: string;\n\ttype: Type;\n}\n\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which templating is applied\n * @param values the values of the templates to use\n */\nexport function template(template: string, values: { [key: string]: string | ISeparator | undefined | null; } = Object.create(null)): string {\n\tconst segments: ISegment[] = [];\n\n\tlet inVariable = false;\n\tlet curVal = '';\n\tfor (const char of template) {\n\t\t// Beginning of variable\n\t\tif (char === '$' || (inVariable && char === '{')) {\n\t\t\tif (curVal) {\n\t\t\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = true;\n\t\t}\n\n\t\t// End of variable\n\t\telse if (char === '}' && inVariable) {\n\t\t\tconst resolved = values[curVal];\n\n\t\t\t// Variable\n\t\t\tif (typeof resolved === 'string') {\n\t\t\t\tif (resolved.length) {\n\t\t\t\t\tsegments.push({ value: resolved, type: Type.VARIABLE });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Separator\n\t\t\telse if (resolved) {\n\t\t\t\tconst prevSegment = segments[segments.length - 1];\n\t\t\t\tif (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n\t\t\t\t\tsegments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = false;\n\t\t}\n\n\t\t// Text or Variable Name\n\t\telse {\n\t\t\tcurVal += char;\n\t\t}\n\t}\n\n\t// Tail\n\tif (curVal && !inVariable) {\n\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t}\n\n\treturn segments.filter((segment, index) => {\n\n\t\t// Only keep separator if we have values to the left and right\n\t\tif (segment.type === Type.SEPARATOR) {\n\t\t\tconst left = segments[index - 1];\n\t\t\tconst right = segments[index + 1];\n\n\t\t\treturn [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n\t\t}\n\n\t\t// accept any TEXT and VARIABLE\n\t\treturn true;\n\t}).map(segment => segment.value).join('');\n}\n\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicMenuLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');\n\t}\n\n\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n}\n\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicButtonLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '');\n\t}\n\n\tif (isWindows) {\n\t\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n\t}\n\n\treturn label.replace(/&&/g, '_');\n}\n\nexport function unmnemonicLabel(label: string): string {\n\treturn label.replace(/&/g, '&&');\n}\n\n/**\n * Splits a path in name and parent path, supporting both '/' and '\\'\n */\nexport function splitName(fullPath: string): { name: string, parentPath: string; } {\n\tconst p = fullPath.indexOf('/') !== -1 ? posix : win32;\n\tconst name = p.basename(fullPath);\n\tconst parentPath = p.dirname(fullPath);\n\tif (name.length) {\n\t\treturn { name, parentPath };\n\t}\n\t// only the root segment\n\treturn { name: parentPath, parentPath: '' };\n}\n"]}