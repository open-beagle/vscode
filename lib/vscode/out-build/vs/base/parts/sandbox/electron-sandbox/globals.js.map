{"version":3,"file":"globals.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/parts/sandbox/electron-sandbox/globals.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAwHnF,QAAA,WAAW,GAAgB,kBAAO,CAAC,MAAM,CAAC,WAAW,CAAC;IACtD,QAAA,cAAc,GAAmB,kBAAO,CAAC,MAAM,CAAC,cAAc,CAAC;IAC/D,QAAA,QAAQ,GAAa,kBAAO,CAAC,MAAM,CAAC,QAAQ,CAAC;IAC7C,QAAA,aAAa,GAAkB,kBAAO,CAAC,MAAM,CAAC,aAAa,CAAC;IAC5D,QAAA,OAAO,GAAwB,kBAAO,CAAC,MAAM,CAAC,OAAO,CAAC;IACtD,QAAA,OAAO,GAAoB,kBAAO,CAAC,MAAM,CAAC,OAAO,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { globals, INodeProcess, IProcessEnvironment } from 'vs/base/common/platform';\nimport { ISandboxConfiguration } from 'vs/base/parts/sandbox/common/sandboxTypes';\nimport { ProcessMemoryInfo, CrashReporter, IpcRenderer, WebFrame } from 'vs/base/parts/sandbox/electron-sandbox/electronTypes';\n\n/**\n * In sandboxed renderers we cannot expose all of the `process` global of node.js\n */\nexport interface ISandboxNodeProcess extends INodeProcess {\n\n\t/**\n\t * The process.platform property returns a string identifying the operating system platform\n\t * on which the Node.js process is running.\n\t */\n\treadonly platform: string;\n\n\t/**\n\t * The process.arch property returns a string identifying the CPU architecture\n\t * on which the Node.js process is running.\n\t */\n\treadonly arch: string;\n\n\t/**\n\t * The type will always be `renderer`.\n\t */\n\treadonly type: string;\n\n\t/**\n\t * Whether the process is sandboxed or not.\n\t */\n\treadonly sandboxed: boolean;\n\n\t/**\n\t * A list of versions for the current node.js/electron configuration.\n\t */\n\treadonly versions: { [key: string]: string | undefined };\n\n\t/**\n\t * The process.env property returns an object containing the user environment.\n\t */\n\treadonly env: IProcessEnvironment;\n\n\t/**\n\t * The `execPath` will be the location of the executable of this application.\n\t */\n\treadonly execPath: string;\n\n\t/**\n\t * A listener on the process. Only a small subset of listener types are allowed.\n\t */\n\ton: (type: string, callback: Function) => void;\n\n\t/**\n\t * The current working directory of the process.\n\t */\n\tcwd: () => string;\n\n\t/**\n\t * Resolves with a ProcessMemoryInfo\n\t *\n\t * Returns an object giving memory usage statistics about the current process. Note\n\t * that all statistics are reported in Kilobytes. This api should be called after\n\t * app ready.\n\t *\n\t * Chromium does not provide `residentSet` value for macOS. This is because macOS\n\t * performs in-memory compression of pages that haven't been recently used. As a\n\t * result the resident set size value is not what one would expect. `private`\n\t * memory is more representative of the actual pre-compression memory usage of the\n\t * process on macOS.\n\t */\n\tgetProcessMemoryInfo: () => Promise<ProcessMemoryInfo>;\n\n\t/**\n\t * Returns a process environment that includes all shell environment variables even if\n\t * the application was not started from a shell / terminal / console.\n\t *\n\t * There are different layers of environment that will apply:\n\t * - `process.env`: this is the actual environment of the process before this method\n\t * - `shellEnv`   : if the program was not started from a terminal, we resolve all shell\n\t *                  variables to get the same experience as if the program was started from\n\t *                  a terminal (Linux, macOS)\n\t * - `userEnv`    : this is instance specific environment, e.g. if the user started the program\n\t *                  from a terminal and changed certain variables\n\t *\n\t * The order of overwrites is `process.env` < `shellEnv` < `userEnv`.\n\t */\n\tshellEnv(): Promise<IProcessEnvironment>;\n}\n\nexport interface IpcMessagePort {\n\n\t/**\n\t * Establish a connection via `MessagePort` to a target. The main process\n\t * will need to transfer the port over to the `channelResponse` after listening\n\t * to `channelRequest` with a payload of `requestNonce` so that the\n\t * source can correlate the response.\n\t *\n\t * The source should install a `window.on('message')` listener, ensuring `e.data`\n\t * matches `requestNonce`, `e.source` matches `window` and then receiving the\n\t * `MessagePort` via `e.ports[0]`.\n\t */\n\tconnect(channelRequest: string, channelResponse: string, requestNonce: string): void;\n}\n\nexport interface ISandboxContext {\n\n\t/**\n\t * A configuration object made accessible from the main side\n\t * to configure the sandbox browser window. Will be `undefined`\n\t * for as long as `resolveConfiguration` is not awaited.\n\t */\n\tconfiguration(): ISandboxConfiguration | undefined;\n\n\t/**\n\t * Allows to await the resolution of the configuration object.\n\t */\n\tresolveConfiguration(): Promise<ISandboxConfiguration>;\n}\n\nexport const ipcRenderer: IpcRenderer = globals.vscode.ipcRenderer;\nexport const ipcMessagePort: IpcMessagePort = globals.vscode.ipcMessagePort;\nexport const webFrame: WebFrame = globals.vscode.webFrame;\nexport const crashReporter: CrashReporter = globals.vscode.crashReporter;\nexport const process: ISandboxNodeProcess = globals.vscode.process;\nexport const context: ISandboxContext = globals.vscode.context;\n"]}