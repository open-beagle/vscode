{"version":3,"file":"ipc.mp.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/parts/ipc/electron-browser/ipc.mp.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAOhG;;;OAGG;IACH,MAAa,MAAO,SAAQ,eAAS;QAE5B,MAAM,CAAC,qBAAqB;YAEnC,6DAA6D;YAC7D,+DAA+D;YAC/D,sDAAsD;YACtD,EAAE;YACF,gEAAgE;YAChE,6CAA6C;YAC7C,MAAM,sBAAsB,GAAG,aAAK,CAAC,oBAAoB,CAAS,sBAAW,EAAE,6BAA6B,EAAE,CAAC,CAAC,EAAE,KAAa,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC;YAE3I,OAAO,aAAK,CAAC,GAAG,CAAC,sBAAsB,EAAE,KAAK,CAAC,EAAE;gBAEhD,8DAA8D;gBAC9D,MAAM,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,YAAY,EAAE,GAAG,IAAI,cAAc,EAAE,CAAC;gBAC1E,MAAM,QAAQ,GAAG,IAAI,iBAAmB,CAAC,YAAY,CAAC,CAAC;gBAEvD,MAAM,MAAM,GAA0B;oBACrC,QAAQ;oBACR,wEAAwE;oBACxE,oEAAoE;oBACpE,+FAA+F;oBAC/F,qBAAqB,EAAE,aAAK,CAAC,mBAAmB,CAAC,YAAY,EAAE,OAAO,CAAC;iBACvE,CAAC;gBAEF,sCAAsC;gBACtC,0DAA0D;gBAC1D,4DAA4D;gBAC5D,qDAAqD;gBACrD,sBAAW,CAAC,WAAW,CAAC,mCAAmC,EAAE,KAAK,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC;gBAEpF,OAAO,MAAM,CAAC;YACf,CAAC,CAAC,CAAC;QACJ,CAAC;QAED;YACC,KAAK,CAAC,MAAM,CAAC,qBAAqB,EAAE,CAAC,CAAC;QACvC,CAAC;KACD;IAvCD,wBAuCC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ipcRenderer } from 'electron';\nimport { Event } from 'vs/base/common/event';\nimport { ClientConnectionEvent, IPCServer } from 'vs/base/parts/ipc/common/ipc';\nimport { Protocol as MessagePortProtocol } from 'vs/base/parts/ipc/common/ipc.mp';\n\n/**\n * An implementation of a `IPCServer` on top of MessagePort style IPC communication.\n * The clients register themselves via Electron IPC transfer.\n */\nexport class Server extends IPCServer {\n\n\tprivate static getOnDidClientConnect(): Event<ClientConnectionEvent> {\n\n\t\t// Clients connect via `vscode:createMessageChannel` to get a\n\t\t// `MessagePort` that is ready to be used. For every connection\n\t\t// we create a pair of message ports and send it back.\n\t\t//\n\t\t// The `nonce` is included so that the main side has a chance to\n\t\t// correlate the response back to the sender.\n\t\tconst onCreateMessageChannel = Event.fromNodeEventEmitter<string>(ipcRenderer, 'vscode:createMessageChannel', (_, nonce: string) => nonce);\n\n\t\treturn Event.map(onCreateMessageChannel, nonce => {\n\n\t\t\t// Create a new pair of ports and protocol for this connection\n\t\t\tconst { port1: incomingPort, port2: outgoingPort } = new MessageChannel();\n\t\t\tconst protocol = new MessagePortProtocol(incomingPort);\n\n\t\t\tconst result: ClientConnectionEvent = {\n\t\t\t\tprotocol,\n\t\t\t\t// Not part of the standard spec, but in Electron we get a `close` event\n\t\t\t\t// when the other side closes. We can use this to detect disconnects\n\t\t\t\t// (https://github.com/electron/electron/blob/11-x-y/docs/api/message-port-main.md#event-close)\n\t\t\t\tonDidClientDisconnect: Event.fromDOMEventEmitter(incomingPort, 'close')\n\t\t\t};\n\n\t\t\t// Send one port back to the requestor\n\t\t\t// Note: we intentionally use `electron` APIs here because\n\t\t\t// transferables like the `MessagePort` cannot be transfered\n\t\t\t// over preload scripts when `contextIsolation: true`\n\t\t\tipcRenderer.postMessage('vscode:createMessageChannelResult', nonce, [outgoingPort]);\n\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tconstructor() {\n\t\tsuper(Server.getOnDidClientConnect());\n\t}\n}\n"]}