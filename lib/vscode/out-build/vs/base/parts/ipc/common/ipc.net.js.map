{"version":3,"file":"ipc.net.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/parts/ipc/common/ipc.net.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IMessagePassingProtocol, IPCClient, IIPCLogger } from 'vs/base/parts/ipc/common/ipc';\nimport { IDisposable, Disposable, dispose } from 'vs/base/common/lifecycle';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport * as platform from 'vs/base/common/platform';\nimport * as process from 'vs/base/common/process';\n\nexport interface ISocket extends IDisposable {\n\tonData(listener: (e: VSBuffer) => void): IDisposable;\n\tonClose(listener: () => void): IDisposable;\n\tonEnd(listener: () => void): IDisposable;\n\twrite(buffer: VSBuffer): void;\n\tend(): void;\n\tdrain(): Promise<void>;\n}\n\nlet emptyBuffer: VSBuffer | null = null;\nfunction getEmptyBuffer(): VSBuffer {\n\tif (!emptyBuffer) {\n\t\temptyBuffer = VSBuffer.alloc(0);\n\t}\n\treturn emptyBuffer;\n}\n\nexport class ChunkStream {\n\n\tprivate _chunks: VSBuffer[];\n\tprivate _totalLength: number;\n\n\tpublic get byteLength() {\n\t\treturn this._totalLength;\n\t}\n\n\tconstructor() {\n\t\tthis._chunks = [];\n\t\tthis._totalLength = 0;\n\t}\n\n\tpublic acceptChunk(buff: VSBuffer) {\n\t\tthis._chunks.push(buff);\n\t\tthis._totalLength += buff.byteLength;\n\t}\n\n\tpublic read(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, true);\n\t}\n\n\tpublic peek(byteCount: number): VSBuffer {\n\t\treturn this._read(byteCount, false);\n\t}\n\n\tprivate _read(byteCount: number, advance: boolean): VSBuffer {\n\n\t\tif (byteCount === 0) {\n\t\t\treturn getEmptyBuffer();\n\t\t}\n\n\t\tif (byteCount > this._totalLength) {\n\t\t\tthrow new Error(`Cannot read so many bytes!`);\n\t\t}\n\n\t\tif (this._chunks[0].byteLength === byteCount) {\n\t\t\t// super fast path, precisely first chunk must be returned\n\t\t\tconst result = this._chunks[0];\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks.shift();\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this._chunks[0].byteLength > byteCount) {\n\t\t\t// fast path, the reading is entirely within the first chunk\n\t\t\tconst result = this._chunks[0].slice(0, byteCount);\n\t\t\tif (advance) {\n\t\t\t\tthis._chunks[0] = this._chunks[0].slice(byteCount);\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlet result = VSBuffer.alloc(byteCount);\n\t\tlet resultOffset = 0;\n\t\tlet chunkIndex = 0;\n\t\twhile (byteCount > 0) {\n\t\t\tconst chunk = this._chunks[chunkIndex];\n\t\t\tif (chunk.byteLength > byteCount) {\n\t\t\t\t// this chunk will survive\n\t\t\t\tconst chunkPart = chunk.slice(0, byteCount);\n\t\t\t\tresult.set(chunkPart, resultOffset);\n\t\t\t\tresultOffset += byteCount;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks[chunkIndex] = chunk.slice(byteCount);\n\t\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= byteCount;\n\t\t\t} else {\n\t\t\t\t// this chunk will be entirely read\n\t\t\t\tresult.set(chunk, resultOffset);\n\t\t\t\tresultOffset += chunk.byteLength;\n\n\t\t\t\tif (advance) {\n\t\t\t\t\tthis._chunks.shift();\n\t\t\t\t\tthis._totalLength -= chunk.byteLength;\n\t\t\t\t} else {\n\t\t\t\t\tchunkIndex++;\n\t\t\t\t}\n\n\t\t\t\tbyteCount -= chunk.byteLength;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nconst enum ProtocolMessageType {\n\tNone = 0,\n\tRegular = 1,\n\tControl = 2,\n\tAck = 3,\n\tKeepAlive = 4,\n\tDisconnect = 5,\n\tReplayRequest = 6\n}\n\nexport const enum ProtocolConstants {\n\tHeaderLength = 13,\n\t/**\n\t * Send an Acknowledge message at most 2 seconds later...\n\t */\n\tAcknowledgeTime = 2000, // 2 seconds\n\t/**\n\t * If there is a message that has been unacknowledged for 10 seconds, consider the connection closed...\n\t */\n\tAcknowledgeTimeoutTime = 20000, // 20 seconds\n\t/**\n\t * Send at least a message every 5s for keep alive reasons.\n\t */\n\tKeepAliveTime = 5000, // 5 seconds\n\t/**\n\t * If there is no message received for 10 seconds, consider the connection closed...\n\t */\n\tKeepAliveTimeoutTime = 20000, // 20 seconds\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t */\n\tReconnectionGraceTime = 3 * 60 * 60 * 1000, // 3hrs\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t */\n\tReconnectionShortGraceTime = 5 * 60 * 1000, // 5min\n}\n\nclass ProtocolMessage {\n\n\tpublic writtenTime: number;\n\n\tconstructor(\n\t\tpublic readonly type: ProtocolMessageType,\n\t\tpublic readonly id: number,\n\t\tpublic readonly ack: number,\n\t\tpublic readonly data: VSBuffer\n\t) {\n\t\tthis.writtenTime = 0;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this.data.byteLength;\n\t}\n}\n\nclass ProtocolReader extends Disposable {\n\n\tprivate readonly _socket: ISocket;\n\tprivate _isDisposed: boolean;\n\tprivate readonly _incomingData: ChunkStream;\n\tpublic lastReadTime: number;\n\n\tprivate readonly _onMessage = this._register(new Emitter<ProtocolMessage>());\n\tpublic readonly onMessage: Event<ProtocolMessage> = this._onMessage.event;\n\n\tprivate readonly _state = {\n\t\treadHead: true,\n\t\treadLen: ProtocolConstants.HeaderLength,\n\t\tmessageType: ProtocolMessageType.None,\n\t\tid: 0,\n\t\tack: 0\n\t};\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._isDisposed = false;\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this._socket.onData(data => this.acceptChunk(data)));\n\t\tthis.lastReadTime = Date.now();\n\t}\n\n\tpublic acceptChunk(data: VSBuffer | null): void {\n\t\tif (!data || data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastReadTime = Date.now();\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tconst buff = this._incomingData.read(this._state.readLen);\n\n\t\t\tif (this._state.readHead) {\n\t\t\t\t// buff is the header\n\n\t\t\t\t// save new state => next time will read the body\n\t\t\t\tthis._state.readHead = false;\n\t\t\t\tthis._state.readLen = buff.readUInt32BE(9);\n\t\t\t\tthis._state.messageType = buff.readUInt8(0);\n\t\t\t\tthis._state.id = buff.readUInt32BE(1);\n\t\t\t\tthis._state.ack = buff.readUInt32BE(5);\n\t\t\t} else {\n\t\t\t\t// buff is the body\n\t\t\t\tconst messageType = this._state.messageType;\n\t\t\t\tconst id = this._state.id;\n\t\t\t\tconst ack = this._state.ack;\n\n\t\t\t\t// save new state => next time will read the header\n\t\t\t\tthis._state.readHead = true;\n\t\t\t\tthis._state.readLen = ProtocolConstants.HeaderLength;\n\t\t\t\tthis._state.messageType = ProtocolMessageType.None;\n\t\t\t\tthis._state.id = 0;\n\t\t\t\tthis._state.ack = 0;\n\n\t\t\t\tthis._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));\n\n\t\t\t\tif (this._isDisposed) {\n\t\t\t\t\t// check if an event listener lead to our disposal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic readEntireBuffer(): VSBuffer {\n\t\treturn this._incomingData.read(this._incomingData.byteLength);\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n}\n\nclass ProtocolWriter {\n\n\tprivate _isDisposed: boolean;\n\tprivate readonly _socket: ISocket;\n\tprivate _data: VSBuffer[];\n\tprivate _totalLength: number;\n\tpublic lastWriteTime: number;\n\n\tconstructor(socket: ISocket) {\n\t\tthis._isDisposed = false;\n\t\tthis._socket = socket;\n\t\tthis._data = [];\n\t\tthis._totalLength = 0;\n\t\tthis.lastWriteTime = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\ttry {\n\t\t\tthis.flush();\n\t\t} catch (err) {\n\t\t\t// ignore error, since the socket could be already closed\n\t\t}\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic drain(): Promise<void> {\n\t\tthis.flush();\n\t\treturn this._socket.drain();\n\t}\n\n\tpublic flush(): void {\n\t\t// flush\n\t\tthis._writeNow();\n\t}\n\n\tpublic write(msg: ProtocolMessage) {\n\t\tif (this._isDisposed) {\n\t\t\t// ignore: there could be left-over promises which complete and then\n\t\t\t// decide to write a response, etc...\n\t\t\treturn;\n\t\t}\n\t\tmsg.writtenTime = Date.now();\n\t\tthis.lastWriteTime = Date.now();\n\t\tconst header = VSBuffer.alloc(ProtocolConstants.HeaderLength);\n\t\theader.writeUInt8(msg.type, 0);\n\t\theader.writeUInt32BE(msg.id, 1);\n\t\theader.writeUInt32BE(msg.ack, 5);\n\t\theader.writeUInt32BE(msg.data.byteLength, 9);\n\t\tthis._writeSoon(header, msg.data);\n\t}\n\n\tprivate _bufferAdd(head: VSBuffer, body: VSBuffer): boolean {\n\t\tconst wasEmpty = this._totalLength === 0;\n\t\tthis._data.push(head, body);\n\t\tthis._totalLength += head.byteLength + body.byteLength;\n\t\treturn wasEmpty;\n\t}\n\n\tprivate _bufferTake(): VSBuffer {\n\t\tconst ret = VSBuffer.concat(this._data, this._totalLength);\n\t\tthis._data.length = 0;\n\t\tthis._totalLength = 0;\n\t\treturn ret;\n\t}\n\n\tprivate _writeSoon(header: VSBuffer, data: VSBuffer): void {\n\t\tif (this._bufferAdd(header, data)) {\n\t\t\tplatform.setImmediate(() => {\n\t\t\t\tthis._writeNow();\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _writeNow(): void {\n\t\tif (this._totalLength === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._socket.write(this._bufferTake());\n\t}\n}\n\n/**\n * A message has the following format:\n * ```\n *     /-------------------------------|------\\\n *     |             HEADER            |      |\n *     |-------------------------------| DATA |\n *     | TYPE | ID | ACK | DATA_LENGTH |      |\n *     \\-------------------------------|------/\n * ```\n * The header is 9 bytes and consists of:\n *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n *\n * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n */\nexport class Protocol extends Disposable implements IMessagePassingProtocol {\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\n\tprivate readonly _onMessage = new Emitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new Emitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._register(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._register(new ProtocolReader(this._socket));\n\n\t\tthis._register(this._socketReader.onMessage((msg) => {\n\t\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this._socket.onClose(() => this._onDidDispose.fire()));\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tgetSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tsendDisconnect(): void {\n\t\t// Nothing to do...\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer));\n\t}\n}\n\nexport class Client<TContext = string> extends IPCClient<TContext> {\n\n\tstatic fromSocket<TContext = string>(socket: ISocket, id: TContext): Client<TContext> {\n\t\treturn new Client(new Protocol(socket), id);\n\t}\n\n\tget onDidDispose(): Event<void> { return this.protocol.onDidDispose; }\n\n\tconstructor(private protocol: Protocol | PersistentProtocol, id: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tsuper(protocol, id, ipcLogger);\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\tthis.protocol.sendDisconnect();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t}\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nexport class BufferedEmitter<T> {\n\tprivate _emitter: Emitter<T>;\n\tpublic readonly event: Event<T>;\n\n\tprivate _hasListeners = false;\n\tprivate _isDeliveringMessages = false;\n\tprivate _bufferedMessages: T[] = [];\n\n\tconstructor() {\n\t\tthis._emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tthis._hasListeners = true;\n\t\t\t\t// it is important to deliver these messages after this call, but before\n\t\t\t\t// other messages have a chance to be received (to guarantee in order delivery)\n\t\t\t\t// that's why we're using here nextTick and not other types of timeouts\n\t\t\t\tprocess.nextTick(() => this._deliverMessages());\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tthis._hasListeners = false;\n\t\t\t}\n\t\t});\n\n\t\tthis.event = this._emitter.event;\n\t}\n\n\tprivate _deliverMessages(): void {\n\t\tif (this._isDeliveringMessages) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isDeliveringMessages = true;\n\t\twhile (this._hasListeners && this._bufferedMessages.length > 0) {\n\t\t\tthis._emitter.fire(this._bufferedMessages.shift()!);\n\t\t}\n\t\tthis._isDeliveringMessages = false;\n\t}\n\n\tpublic fire(event: T): void {\n\t\tif (this._hasListeners) {\n\t\t\tif (this._bufferedMessages.length > 0) {\n\t\t\t\tthis._bufferedMessages.push(event);\n\t\t\t} else {\n\t\t\t\tthis._emitter.fire(event);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._bufferedMessages.push(event);\n\t\t}\n\t}\n\n\tpublic flushBuffer(): void {\n\t\tthis._bufferedMessages = [];\n\t}\n}\n\nclass QueueElement<T> {\n\tpublic readonly data: T;\n\tpublic next: QueueElement<T> | null;\n\n\tconstructor(data: T) {\n\t\tthis.data = data;\n\t\tthis.next = null;\n\t}\n}\n\nclass Queue<T> {\n\n\tprivate _first: QueueElement<T> | null;\n\tprivate _last: QueueElement<T> | null;\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t}\n\n\tpublic peek(): T | null {\n\t\tif (!this._first) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._first.data;\n\t}\n\n\tpublic toArray(): T[] {\n\t\tlet result: T[] = [], resultLen = 0;\n\t\tlet it = this._first;\n\t\twhile (it) {\n\t\t\tresult[resultLen++] = it.data;\n\t\t\tit = it.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pop(): void {\n\t\tif (!this._first) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._first === this._last) {\n\t\t\tthis._first = null;\n\t\t\tthis._last = null;\n\t\t\treturn;\n\t\t}\n\t\tthis._first = this._first.next;\n\t}\n\n\tpublic push(item: T): void {\n\t\tconst element = new QueueElement(item);\n\t\tif (!this._first) {\n\t\t\tthis._first = element;\n\t\t\tthis._last = element;\n\t\t\treturn;\n\t\t}\n\t\tthis._last!.next = element;\n\t\tthis._last = element;\n\t}\n}\n\nclass LoadEstimator {\n\n\tprivate static _HISTORY_LENGTH = 10;\n\tprivate static _INSTANCE: LoadEstimator | null = null;\n\tpublic static getInstance(): LoadEstimator {\n\t\tif (!LoadEstimator._INSTANCE) {\n\t\t\tLoadEstimator._INSTANCE = new LoadEstimator();\n\t\t}\n\t\treturn LoadEstimator._INSTANCE;\n\t}\n\n\tprivate lastRuns: number[];\n\n\tconstructor() {\n\t\tthis.lastRuns = [];\n\t\tconst now = Date.now();\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tthis.lastRuns[i] = now - 1000 * i;\n\t\t}\n\t\tsetInterval(() => {\n\t\t\tfor (let i = LoadEstimator._HISTORY_LENGTH; i >= 1; i--) {\n\t\t\t\tthis.lastRuns[i] = this.lastRuns[i - 1];\n\t\t\t}\n\t\t\tthis.lastRuns[0] = Date.now();\n\t\t}, 1000);\n\t}\n\n\t/**\n\t * returns an estimative number, from 0 (low load) to 1 (high load)\n\t */\n\tpublic load(): number {\n\t\tconst now = Date.now();\n\t\tconst historyLimit = (1 + LoadEstimator._HISTORY_LENGTH) * 1000;\n\t\tlet score = 0;\n\t\tfor (let i = 0; i < LoadEstimator._HISTORY_LENGTH; i++) {\n\t\t\tif (now - this.lastRuns[i] <= historyLimit) {\n\t\t\t\tscore++;\n\t\t\t}\n\t\t}\n\t\treturn 1 - score / LoadEstimator._HISTORY_LENGTH;\n\t}\n\n\tpublic hasHighLoad(): boolean {\n\t\treturn this.load() >= 0.5;\n\t}\n}\n\n/**\n * Same as Protocol, but will actually track messages and acks.\n * Moreover, it will ensure no messages are lost if there are no event listeners.\n */\nexport class PersistentProtocol implements IMessagePassingProtocol {\n\n\tprivate _isReconnecting: boolean;\n\n\tprivate _outgoingUnackMsg: Queue<ProtocolMessage>;\n\tprivate _outgoingMsgId: number;\n\tprivate _outgoingAckId: number;\n\tprivate _outgoingAckTimeout: any | null;\n\n\tprivate _incomingMsgId: number;\n\tprivate _incomingAckId: number;\n\tprivate _incomingMsgLastTime: number;\n\tprivate _incomingAckTimeout: any | null;\n\n\tprivate _outgoingKeepAliveTimeout: any | null;\n\tprivate _incomingKeepAliveTimeout: any | null;\n\n\tprivate _lastReplayRequestTime: number;\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\tprivate _socketDisposables: IDisposable[];\n\n\tprivate readonly _loadEstimator = LoadEstimator.getInstance();\n\n\tprivate readonly _onControlMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onControlMessage: Event<VSBuffer> = this._onControlMessage.event;\n\n\tprivate readonly _onMessage = new BufferedEmitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate readonly _onDidDispose = new BufferedEmitter<void>();\n\treadonly onDidDispose: Event<void> = this._onDidDispose.event;\n\n\tprivate readonly _onSocketClose = new BufferedEmitter<void>();\n\treadonly onSocketClose: Event<void> = this._onSocketClose.event;\n\n\tprivate readonly _onSocketTimeout = new BufferedEmitter<void>();\n\treadonly onSocketTimeout: Event<void> = this._onSocketTimeout.event;\n\n\tpublic get unacknowledgedCount(): number {\n\t\treturn this._outgoingMsgId - this._outgoingAckId;\n\t}\n\n\tconstructor(socket: ISocket, initialChunk: VSBuffer | null = null) {\n\t\tthis._isReconnecting = false;\n\t\tthis._outgoingUnackMsg = new Queue<ProtocolMessage>();\n\t\tthis._outgoingMsgId = 0;\n\t\tthis._outgoingAckId = 0;\n\t\tthis._outgoingAckTimeout = null;\n\n\t\tthis._incomingMsgId = 0;\n\t\tthis._incomingAckId = 0;\n\t\tthis._incomingMsgLastTime = 0;\n\t\tthis._incomingAckTimeout = null;\n\n\t\tthis._outgoingKeepAliveTimeout = null;\n\t\tthis._incomingKeepAliveTimeout = null;\n\n\t\tthis._lastReplayRequestTime = 0;\n\n\t\tthis._socketDisposables = [];\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = new ProtocolWriter(this._socket);\n\t\tthis._socketDisposables.push(this._socketWriter);\n\t\tthis._socketReader = new ProtocolReader(this._socket);\n\t\tthis._socketDisposables.push(this._socketReader);\n\t\tthis._socketDisposables.push(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.push(this._socket.onClose(() => this._onSocketClose.fire()));\n\t\tif (initialChunk) {\n\t\t\tthis._socketReader.acceptChunk(initialChunk);\n\t\t}\n\n\t\tthis._sendKeepAliveCheck();\n\t\tthis._recvKeepAliveCheck();\n\t}\n\n\tdispose(): void {\n\t\tif (this._outgoingAckTimeout) {\n\t\t\tclearTimeout(this._outgoingAckTimeout);\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t}\n\t\tif (this._incomingAckTimeout) {\n\t\t\tclearTimeout(this._incomingAckTimeout);\n\t\t\tthis._incomingAckTimeout = null;\n\t\t}\n\t\tif (this._outgoingKeepAliveTimeout) {\n\t\t\tclearTimeout(this._outgoingKeepAliveTimeout);\n\t\t\tthis._outgoingKeepAliveTimeout = null;\n\t\t}\n\t\tif (this._incomingKeepAliveTimeout) {\n\t\t\tclearTimeout(this._incomingKeepAliveTimeout);\n\t\t\tthis._incomingKeepAliveTimeout = null;\n\t\t}\n\t\tthis._socketDisposables = dispose(this._socketDisposables);\n\t}\n\n\tdrain(): Promise<void> {\n\t\treturn this._socketWriter.drain();\n\t}\n\n\tsendDisconnect(): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Disconnect, 0, 0, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t\tthis._socketWriter.flush();\n\t}\n\n\tprivate _sendKeepAliveCheck(): void {\n\t\tif (this._outgoingKeepAliveTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastOutgoingMsg = Date.now() - this._socketWriter.lastWriteTime;\n\t\tif (timeSinceLastOutgoingMsg >= ProtocolConstants.KeepAliveTime) {\n\t\t\t// sufficient time has passed since last message was written,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only a keep alive.\n\t\t\tconst msg = new ProtocolMessage(ProtocolMessageType.KeepAlive, 0, 0, getEmptyBuffer());\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._sendKeepAliveCheck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._outgoingKeepAliveTimeout = setTimeout(() => {\n\t\t\tthis._outgoingKeepAliveTimeout = null;\n\t\t\tthis._sendKeepAliveCheck();\n\t\t}, ProtocolConstants.KeepAliveTime - timeSinceLastOutgoingMsg + 5);\n\t}\n\n\tprivate _recvKeepAliveCheck(): void {\n\t\tif (this._incomingKeepAliveTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._socketReader.lastReadTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.KeepAliveTimeoutTime) {\n\t\t\t// It's been a long time since we received a server message\n\t\t\t// But this might be caused by the event loop being busy and failing to read messages\n\t\t\tif (!this._loadEstimator.hasHighLoad()) {\n\t\t\t\t// Trash the socket\n\t\t\t\tthis._onSocketTimeout.fire(undefined);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis._incomingKeepAliveTimeout = setTimeout(() => {\n\t\t\tthis._incomingKeepAliveTimeout = null;\n\t\t\tthis._recvKeepAliveCheck();\n\t\t}, Math.max(ProtocolConstants.KeepAliveTimeoutTime - timeSinceLastIncomingMsg, 0) + 5);\n\t}\n\n\t// NOTE@coder: Set the socket without initiating a reconnect.\n\tpublic setSocket(socket: ISocket): void {\n\t\tthis._socket = socket;\n\t}\n\n\tpublic getSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tpublic getMillisSinceLastIncomingData(): number {\n\t\treturn Date.now() - this._socketReader.lastReadTime;\n\t}\n\n\tpublic beginAcceptReconnection(socket: ISocket, initialDataChunk: VSBuffer | null): void {\n\t\tthis._isReconnecting = true;\n\n\t\tthis._socketDisposables = dispose(this._socketDisposables);\n\t\tthis._onControlMessage.flushBuffer();\n\t\tthis._onSocketClose.flushBuffer();\n\t\tthis._onSocketTimeout.flushBuffer();\n\t\tthis._socket.dispose();\n\n\t\tthis._lastReplayRequestTime = 0;\n\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = new ProtocolWriter(this._socket);\n\t\tthis._socketDisposables.push(this._socketWriter);\n\t\tthis._socketReader = new ProtocolReader(this._socket);\n\t\tthis._socketDisposables.push(this._socketReader);\n\t\tthis._socketDisposables.push(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.push(this._socket.onClose(() => this._onSocketClose.fire()));\n\t\tthis._socketReader.acceptChunk(initialDataChunk);\n\t}\n\n\tpublic endAcceptReconnection(): void {\n\t\tthis._isReconnecting = false;\n\n\t\t// Send again all unacknowledged messages\n\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t}\n\t\tthis._recvAckCheck();\n\n\t\tthis._sendKeepAliveCheck();\n\t\tthis._recvKeepAliveCheck();\n\t}\n\n\tpublic acceptDisconnect(): void {\n\t\tthis._onDidDispose.fire();\n\t}\n\n\tprivate _receiveMessage(msg: ProtocolMessage): void {\n\t\tif (msg.ack > this._outgoingAckId) {\n\t\t\tthis._outgoingAckId = msg.ack;\n\t\t\tdo {\n\t\t\t\tconst first = this._outgoingUnackMsg.peek();\n\t\t\t\tif (first && first.id <= msg.ack) {\n\t\t\t\t\t// this message has been confirmed, remove it\n\t\t\t\t\tthis._outgoingUnackMsg.pop();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t}\n\n\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\tif (msg.id > this._incomingMsgId) {\n\t\t\t\tif (msg.id !== this._incomingMsgId + 1) {\n\t\t\t\t\t// in case we missed some messages we ask the other party to resend them\n\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\tif (now - this._lastReplayRequestTime > 10000) {\n\t\t\t\t\t\t// send a replay request at most once every 10s\n\t\t\t\t\t\tthis._lastReplayRequestTime = now;\n\t\t\t\t\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.ReplayRequest, 0, 0, getEmptyBuffer()));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._incomingMsgId = msg.id;\n\t\t\t\t\tthis._incomingMsgLastTime = Date.now();\n\t\t\t\t\tthis._sendAckCheck();\n\t\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (msg.type === ProtocolMessageType.Control) {\n\t\t\tthis._onControlMessage.fire(msg.data);\n\t\t} else if (msg.type === ProtocolMessageType.Disconnect) {\n\t\t\tthis._onDidDispose.fire();\n\t\t} else if (msg.type === ProtocolMessageType.ReplayRequest) {\n\t\t\t// Send again all unacknowledged messages\n\t\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t\t}\n\t\t\tthis._recvAckCheck();\n\t\t}\n\t}\n\n\treadEntireBuffer(): VSBuffer {\n\t\treturn this._socketReader.readEntireBuffer();\n\t}\n\n\tflush(): void {\n\t\tthis._socketWriter.flush();\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tconst myId = ++this._outgoingMsgId;\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Regular, myId, this._incomingAckId, buffer);\n\t\tthis._outgoingUnackMsg.push(msg);\n\t\tif (!this._isReconnecting) {\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._recvAckCheck();\n\t\t}\n\t}\n\n\t/**\n\t * Send a message which will not be part of the regular acknowledge flow.\n\t * Use this for early control messages which are repeated in case of reconnection.\n\t */\n\tsendControl(buffer: VSBuffer): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Control, 0, 0, buffer);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendAckCheck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._incomingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n\t\t\t// sufficient time has passed since this message has been received,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only an ack.\n\t\t\tthis._sendAck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckTimeout = setTimeout(() => {\n\t\t\tthis._incomingAckTimeout = null;\n\t\t\tthis._sendAckCheck();\n\t\t}, ProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5);\n\t}\n\n\tprivate _recvAckCheck(): void {\n\t\tif (this._outgoingMsgId <= this._outgoingAckId) {\n\t\t\t// everything has been acknowledged\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._outgoingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek()!;\n\t\tconst timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;\n\t\tif (timeSinceOldestUnacknowledgedMsg >= ProtocolConstants.AcknowledgeTimeoutTime) {\n\t\t\t// It's been a long time since our sent message was acknowledged\n\t\t\t// But this might be caused by the event loop being busy and failing to read messages\n\t\t\tif (!this._loadEstimator.hasHighLoad()) {\n\t\t\t\t// Trash the socket\n\t\t\t\tthis._onSocketTimeout.fire(undefined);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis._outgoingAckTimeout = setTimeout(() => {\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t\tthis._recvAckCheck();\n\t\t}, Math.max(ProtocolConstants.AcknowledgeTimeoutTime - timeSinceOldestUnacknowledgedMsg, 0) + 5);\n\t}\n\n\tprivate _sendAck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n}\n"]}