{"version":3,"file":"storage.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/parts/storage/common/storage.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { ThrottledDelayer } from 'vs/base/common/async';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\n\nexport enum StorageHint {\n\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST\n}\n\nexport interface IStorageOptions {\n\treadonly hint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\treadonly insert?: Map<string, string>;\n\treadonly delete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\treadonly changed?: Map<string, string>;\n\treadonly deleted?: Set<string>;\n}\n\nexport interface IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\n\tgetItems(): Promise<Map<string, string>>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n\n\tclose(recovery?: () => Map<string, string>): Promise<void>;\n}\n\nexport interface IStorage extends IDisposable {\n\n\treadonly onDidChangeStorage: Event<string>;\n\n\treadonly items: Map<string, string>;\n\treadonly size: number;\n\n\tinit(): Promise<void>;\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tset(key: string, value: string | boolean | number | undefined | null): Promise<void>;\n\tdelete(key: string): Promise<void>;\n\n\twhenFlushed(): Promise<void>;\n\n\tclose(): Promise<void>;\n}\n\nenum StorageState {\n\tNone,\n\tInitialized,\n\tClosed\n}\n\nexport class Storage extends Disposable implements IStorage {\n\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage = this._register(new Emitter<string>());\n\treadonly onDidChangeStorage = this._onDidChangeStorage.event;\n\n\tprivate state = StorageState.None;\n\n\tprivate cache = new Map<string, string>();\n\n\tprivate readonly flushDelayer = new ThrottledDelayer<void>(Storage.DEFAULT_FLUSH_DELAY);\n\n\tprivate pendingDeletes = new Set<string>();\n\tprivate pendingInserts = new Map<string, string>();\n\n\tprivate pendingClose: Promise<void> | undefined = undefined;\n\n\tprivate readonly whenFlushedCallbacks: Function[] = [];\n\n\tconstructor(\n\t\tprotected readonly database: IStorageDatabase,\n\t\tprivate readonly options: IStorageOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\t// items that change external require us to update our\n\t\t// caches with the values. we just accept the value and\n\t\t// emit an event if there is a change.\n\t\te.changed?.forEach((value, key) => this.accept(key, value));\n\t\te.deleted?.forEach(key => this.accept(key, undefined));\n\t}\n\n\tprivate accept(key: string, value: string | undefined): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire(key);\n\t\t}\n\t}\n\n\tget items(): Map<string, string> {\n\t\treturn this.cache;\n\t}\n\n\tget size(): number {\n\t\treturn this.cache.size;\n\t}\n\n\tasync init(): Promise<void> {\n\t\tif (this.state !== StorageState.None) {\n\t\t\treturn; // either closed or already initialized\n\t\t}\n\n\t\tthis.state = StorageState.Initialized;\n\n\t\tif (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n\t\t\t// return early if we know the storage file does not exist. this is a performance\n\t\t\t// optimization to not load all items of the underlying storage if we know that\n\t\t\t// there can be no items because the storage does not exist.\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cache = await this.database.getItems();\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tasync set(key: string, value: string | boolean | number | null | undefined): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire(key);\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.flushDelayer.trigger(() => this.flushPending());\n\t}\n\n\tasync delete(key: string): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn; // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire(key);\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.flushDelayer.trigger(() => this.flushPending());\n\t}\n\n\tasync close(): Promise<void> {\n\t\tif (!this.pendingClose) {\n\t\t\tthis.pendingClose = this.doClose();\n\t\t}\n\n\t\treturn this.pendingClose;\n\t}\n\n\tprivate async doClose(): Promise<void> {\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Trigger new flush to ensure data is persisted and then close\n\t\t// even if there is an error flushing. We must always ensure\n\t\t// the DB is closed to avoid corruption.\n\t\t//\n\t\t// Recovery: we pass our cache over as recovery option in case\n\t\t// the DB is not healthy.\n\t\ttry {\n\t\t\tawait this.flushDelayer.trigger(() => this.flushPending(), 0 /* as soon as possible */);\n\t\t} catch (error) {\n\t\t\t// Ignore\n\t\t}\n\n\t\tawait this.database.close(() => this.cache);\n\t}\n\n\tprivate get hasPending() {\n\t\treturn this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n\t}\n\n\tprivate async flushPending(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage and release any\n\t\t// waiters we have once done\n\t\treturn this.database.updateItems(updateRequest).finally(() => {\n\t\t\tif (!this.hasPending) {\n\t\t\t\twhile (this.whenFlushedCallbacks.length) {\n\t\t\t\t\tthis.whenFlushedCallbacks.pop()?.();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync whenFlushed(): Promise<void> {\n\t\tif (!this.hasPending) {\n\t\t\treturn; // return early if nothing to do\n\t\t}\n\n\t\treturn new Promise(resolve => this.whenFlushedCallbacks.push(resolve));\n\t}\n\n\toverride dispose(): void {\n\t\tthis.flushDelayer.cancel(); // workaround https://github.com/microsoft/vscode/issues/116777\n\t\tthis.flushDelayer.dispose();\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate readonly items = new Map<string, string>();\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\treturn this.items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\tif (request.insert) {\n\t\t\trequest.insert.forEach((value, key) => this.items.set(key, value));\n\t\t}\n\n\t\tif (request.delete) {\n\t\t\trequest.delete.forEach(key => this.items.delete(key));\n\t\t}\n\t}\n\n\tasync close(): Promise<void> { }\n}\n"]}