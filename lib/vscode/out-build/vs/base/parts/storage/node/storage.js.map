{"version":3,"file":"storage.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/parts/storage/node/storage.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IA4BhG,MAAa,qBAAqB;QAejC,YAA6B,IAAY,EAAmB,UAAyC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;YAA3F,SAAI,GAAJ,IAAI,CAAQ;YAAmB,YAAO,GAAP,OAAO,CAAqD;YANvG,SAAI,GAAG,CAAA,GAAA,eAAQ,CAAA,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAE3B,WAAM,GAAG,IAAI,2BAA2B,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YAE/D,kBAAa,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEmE,CAAC;QAX7H,IAAI,wBAAwB,KAAsC,OAAO,aAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,iEAAiE;QAaxJ,KAAK,CAAC,QAAQ;YACb,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC;YAE5C,MAAM,KAAK,GAAG,IAAI,GAAG,EAAkB,CAAC;YAExC,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,yBAAyB,CAAC,CAAC;YACnE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YAEnD,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;gBAC1B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,iBAAiB,KAAK,CAAC,IAAI,OAAO,CAAC,CAAC;aAC3E;YAED,OAAO,KAAK,CAAC;QACd,CAAC;QAED,KAAK,CAAC,WAAW,CAAC,OAAuB;YACxC,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC;YAE5C,OAAO,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAChD,CAAC;QAEO,aAAa,CAAC,UAA+B,EAAE,OAAuB;YAC7E,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;gBAC1B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,2BAA2B,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA,GAAA,iBAAW,CAAA,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,aAAa,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA,GAAA,iBAAW,CAAA,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;aACxL;YAED,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,GAAG,EAAE;gBACxC,MAAM,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC;gBAChC,MAAM,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC;gBAEhC,SAAS;gBACT,IAAI,QAAQ,IAAI,QAAQ,CAAC,IAAI,GAAG,CAAC,EAAE;oBAClC,MAAM,gBAAgB,GAAiB,EAAE,CAAC;oBAC1C,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,gCAAgC;oBAE3D,4EAA4E;oBAC5E,qFAAqF;oBACrF,IAAI,iBAAiB,GAAG,CAAC,CAAC;oBAC1B,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE;wBAC/B,IAAI,aAAa,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,CAAC;wBAExD,IAAI,aAAa,CAAC,MAAM,GAAG,qBAAqB,CAAC,mBAAmB,EAAE;4BACrE,iBAAiB,EAAE,CAAC;4BACpB,aAAa,GAAG,EAAE,CAAC;4BACnB,gBAAgB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;yBACrC;wBAED,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;oBAChC,CAAC,CAAC,CAAC;oBAEH,gBAAgB,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;wBAC1C,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,gCAAgC,IAAI,KAAK,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,EAAE,GAAG,EAAE;4BACjK,MAAM,IAAI,GAAa,EAAE,CAAC;4BAC1B,IAAI,MAAM,GAAG,CAAC,CAAC;4BACf,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE;gCAC/B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gCACf,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC;4BACxB,CAAC,CAAC,CAAC;4BAEH,OAAO,SAAS,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,MAAM,EAAE,CAAC;wBACrD,CAAC,CAAC,CAAC;oBACJ,CAAC,CAAC,CAAC;iBACH;gBAED,SAAS;gBACT,IAAI,QAAQ,IAAI,QAAQ,CAAC,IAAI,EAAE;oBAC9B,MAAM,UAAU,GAAiB,EAAE,CAAC;oBACpC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,gCAAgC;oBAErD,sEAAsE;oBACtE,yEAAyE;oBACzE,cAAc;oBACd,IAAI,iBAAiB,GAAG,CAAC,CAAC;oBAC1B,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;wBACtB,IAAI,QAAQ,GAAG,UAAU,CAAC,iBAAiB,CAAC,CAAC;wBAE7C,IAAI,QAAQ,CAAC,MAAM,GAAG,qBAAqB,CAAC,mBAAmB,EAAE;4BAChE,iBAAiB,EAAE,CAAC;4BACpB,QAAQ,GAAG,EAAE,CAAC;4BACd,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;yBAC1B;wBAED,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACpB,CAAC,CAAC,CAAC;oBAEH,UAAU,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;wBAC9B,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,uCAAuC,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,GAAG,EAAE;4BACrJ,MAAM,IAAI,GAAa,EAAE,CAAC;4BAC1B,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gCACtB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;4BAChB,CAAC,CAAC,CAAC;4BAEH,OAAO,SAAS,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;wBACnC,CAAC,CAAC,CAAC;oBACJ,CAAC,CAAC,CAAC;iBACH;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;QAED,KAAK,CAAC,KAAK,CAAC,QAAoC;YAC/C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,WAAW,CAAC,CAAC;YAEpD,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC;YAE5C,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QAC3C,CAAC;QAEO,OAAO,CAAC,UAA+B,EAAE,QAAoC;YACpF,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACtC,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;oBAChC,IAAI,UAAU,EAAE;wBACf,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,YAAY,IAAI,CAAC,IAAI,cAAc,UAAU,EAAE,CAAC,CAAC;qBACpF;oBAED,0DAA0D;oBAC1D,oDAAoD;oBACpD,IAAI,IAAI,CAAC,IAAI,KAAK,qBAAqB,CAAC,cAAc,EAAE;wBACvD,OAAO,OAAO,EAAE,CAAC;qBACjB;oBAED,iEAAiE;oBACjE,8DAA8D;oBAC9D,iEAAiE;oBACjE,oCAAoC;oBACpC,IAAI,CAAC,UAAU,CAAC,WAAW,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;wBACtD,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE;4BAC1C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,eAAe,KAAK,EAAE,CAAC,CAAC;4BAE/D,OAAO,OAAO,EAAE,CAAC,CAAC,wBAAwB;wBAC3C,CAAC,CAAC,CAAC;qBACH;oBAED,qEAAqE;oBACrE,4EAA4E;oBAC5E,yEAAyE;oBACzE,2DAA2D;oBAC3D,IAAI,OAAO,QAAQ,KAAK,UAAU,EAAE;wBAEnC,iEAAiE;wBACjE,iEAAiE;wBACjE,+CAA+C;wBAC/C,OAAO,aAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;4BAE3C,uBAAuB;4BACvB,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE;gCAC1D,MAAM,uBAAuB,GAAG,GAAG,EAAE;oCACpC,OAAO,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE,SAAS,CAAC,qCAAqC,CAAC,CAAC;gCAC1F,CAAC,CAAC;gCAEF,cAAc;gCACd,OAAO,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,EAAE,MAAM,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,uBAAuB,EAAE,EAAE,KAAK,CAAC,EAAE;oCAEnH,2EAA2E;oCAC3E,qEAAqE;oCACrE,uBAAuB,EAAE,CAAC;oCAE1B,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gCAC9B,CAAC,CAAC,CAAC;4BACJ,CAAC,CAAC,CAAC;wBACJ,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;qBACzB;oBAED,0CAA0C;oBAC1C,OAAO,MAAM,CAAC,UAAU,IAAI,IAAI,KAAK,CAAC,6DAA6D,CAAC,CAAC,CAAC;gBACvG,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,MAAM;YACb,MAAM,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAEhD,OAAO,CAAA,GAAA,UAAI,CAAA,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,EAAE,gBAAgB,EAAE,KAAK,EAAE,CAAC,CAAC;QACjE,CAAC;QAEO,YAAY,CAAC,IAAY;YAChC,OAAO,GAAG,IAAI,SAAS,CAAC;QACzB,CAAC;QAED,KAAK,CAAC,cAAc,CAAC,IAAa;YACjC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,0BAA0B,IAAI,GAAG,CAAC,CAAC;YAE1E,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC;YAC5C,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC,oBAAoB,CAAC,CAAC;YAE/F,MAAM,SAAS,GAAG,IAAI,CAAC,CAAC,CAAE,GAAW,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAE,GAAW,CAAC,aAAa,CAAC,CAAC;YAEvF,IAAI,UAAU,CAAC,WAAW,EAAE;gBAC3B,OAAO,GAAG,SAAS,iBAAiB,UAAU,CAAC,SAAS,GAAG,CAAC;aAC5D;YAED,IAAI,UAAU,CAAC,UAAU,EAAE;gBAC1B,OAAO,GAAG,SAAS,eAAe,CAAC;aACnC;YAED,OAAO,SAAS,CAAC;QAClB,CAAC;QAEO,KAAK,CAAC,OAAO,CAAC,IAAY,EAAE,cAAuB,IAAI;YAC9D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,UAAU,IAAI,kBAAkB,WAAW,GAAG,CAAC,CAAC;YAEvF,IAAI;gBACH,OAAO,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;aAClC;YAAC,OAAO,KAAK,EAAE;gBACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,sCAAsC,KAAK,EAAE,CAAC,CAAC;gBAEtF,kFAAkF;gBAClF,gFAAgF;gBAChF,mFAAmF;gBACnF,mFAAmF;gBACnF,uBAAuB;gBACvB,EAAE;gBACF,wFAAwF;gBACxF,EAAE;gBACF,IAAI,KAAK,CAAC,IAAI,KAAK,aAAa,IAAI,WAAW,EAAE;oBAChD,MAAM,CAAA,GAAA,eAAO,CAAA,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,CAAC;oBAEvD,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,uBAAuB,CAAC,CAAC;iBACzD;gBAED,mFAAmF;gBACnF,kFAAkF;gBAClF,iDAAiD;gBACjD,EAAE;gBACF,sFAAsF;gBACtF,yCAAyC;gBACzC,EAAE;gBACF,IAAI;oBACH,MAAM,aAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBAC5B,IAAI;wBACH,MAAM,aAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;qBACrD;oBAAC,OAAO,KAAK,EAAE;wBACf,SAAS;qBACT;oBAED,OAAO,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;iBAClC;gBAAC,OAAO,KAAK,EAAE;oBACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,yCAAyC,KAAK,EAAE,CAAC,CAAC;oBAEzF,wDAAwD;oBACxD,mDAAmD;oBACnD,OAAO,IAAI,CAAC,SAAS,CAAC,qBAAqB,CAAC,cAAc,CAAC,CAAC;iBAC5D;aACD;QACF,CAAC;QAEO,iBAAiB,CAAC,UAA+B,EAAE,GAAW;YACrE,UAAU,CAAC,WAAW,GAAG,IAAI,CAAC;YAC9B,UAAU,CAAC,SAAS,GAAG,GAAG,CAAC;YAE3B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACxB,CAAC;QAEO,SAAS,CAAC,IAAY;YAC7B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACtC,gDAAO,gBAAgB,4BAAE,IAAI,CAAC,OAAO,CAAC,EAAE;oBACvC,MAAM,UAAU,GAAwB;wBACvC,EAAE,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;4BAC7F,IAAI,KAAK,EAAE;gCACV,OAAO,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;6BAChF;4BAED,sDAAsD;4BACtD,2CAA2C;4BAC3C,mFAAmF;4BACnF,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;gCAC5B,0BAA0B;gCAC1B,wFAAwF;6BACxF,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;gCACrB,OAAO,OAAO,CAAC,UAAU,CAAC,CAAC;4BAC5B,CAAC,EAAE,KAAK,CAAC,EAAE;gCACV,OAAO,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;4BACjD,CAAC,CAAC,CAAC;wBACJ,CAAC,CAAC;wBACF,UAAU,EAAE,IAAI,KAAK,qBAAqB,CAAC,cAAc;qBACzD,CAAC;oBAEF,SAAS;oBACT,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,YAAY,IAAI,CAAC,IAAI,oBAAoB,KAAK,EAAE,CAAC,CAAC,CAAC;oBAEzH,UAAU;oBACV,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;wBAC1B,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,IAAI,oBAAoB,GAAG,EAAE,CAAC,CAAC,CAAC;qBACpG;gBACF,CAAC,EAAE,MAAM,CAAC,CAAC;YACZ,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,IAAI,CAAC,UAA+B,EAAE,GAAW;YACxD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACtC,UAAU,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE;oBAC/B,IAAI,KAAK,EAAE;wBACV,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,YAAY,IAAI,CAAC,IAAI,aAAa,KAAK,EAAE,CAAC,CAAC;wBAE9E,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;qBACrB;oBAED,OAAO,OAAO,EAAE,CAAC;gBAClB,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,GAAG,CAAC,UAA+B,EAAE,GAAW;YACvD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACtC,UAAU,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE;oBACrC,IAAI,KAAK,EAAE;wBACV,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,YAAY,IAAI,CAAC,IAAI,YAAY,KAAK,EAAE,CAAC,CAAC;wBAE7E,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;qBACrB;oBAED,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC;gBACrB,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,GAAG,CAAC,UAA+B,EAAE,GAAW;YACvD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACtC,UAAU,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;oBACtC,IAAI,KAAK,EAAE;wBACV,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,YAAY,IAAI,CAAC,IAAI,YAAY,KAAK,EAAE,CAAC,CAAC;wBAE7E,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;qBACrB;oBAED,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;gBACtB,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,WAAW,CAAC,UAA+B,EAAE,YAAwB;YAC5E,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACtC,UAAU,CAAC,EAAE,CAAC,SAAS,CAAC,GAAG,EAAE;oBAC5B,UAAU,CAAC,EAAE,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;oBAEvC,YAAY,EAAE,CAAC;oBAEf,UAAU,CAAC,EAAE,CAAC,GAAG,CAAC,iBAAiB,EAAE,KAAK,CAAC,EAAE;wBAC5C,IAAI,KAAK,EAAE;4BACV,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,YAAY,IAAI,CAAC,IAAI,oBAAoB,KAAK,EAAE,CAAC,CAAC;4BAErF,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;yBACrB;wBAED,OAAO,OAAO,EAAE,CAAC;oBAClB,CAAC,CAAC,CAAC;gBACJ,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,OAAO,CAAC,UAA+B,EAAE,GAAW,EAAE,WAAsC,EAAE,YAA0B;YAC/H,MAAM,IAAI,GAAG,UAAU,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAExC,MAAM,sBAAsB,GAAG,CAAC,KAAY,EAAE,EAAE;gBAC/C,IAAI,CAAC,iBAAiB,CAAC,UAAU,EAAE,YAAY,IAAI,CAAC,IAAI,gBAAgB,KAAK,KAAK,GAAG,eAAe,YAAY,EAAE,EAAE,CAAC,CAAC;YACvH,CAAC,CAAC;YAEF,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,sBAAsB,CAAC,CAAC;YAEzC,WAAW,CAAC,IAAI,CAAC,CAAC;YAElB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;gBACrB,IAAI,KAAK,EAAE;oBACV,sBAAsB,CAAC,KAAK,CAAC,CAAC;iBAC9B;gBAED,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,sBAAsB,CAAC,CAAC;YACtD,CAAC,CAAC,CAAC;QACJ,CAAC;;IAhYF,sDAiYC;IA/XgB,oCAAc,GAAG,UAAU,CAAC;IAIpB,uCAAiB,GAAG,IAAI,CAAC,CAAC,gEAAgE;IAC1F,yCAAmB,GAAG,GAAG,CAAC,CAAC,kDAAkD;IA4XtG,MAAM,2BAA2B;QAUhC,YAAY,OAA8C;YACzD,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,QAAQ,KAAK,UAAU,IAAI,OAAO,CAAC,GAAG,CAAC,2BAA2B,CAAC,oBAAoB,CAAC,EAAE;gBACvH,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;aACjC;YAED,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,QAAQ,KAAK,UAAU,EAAE;gBACtD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;aACjC;QACF,CAAC;QAED,IAAI,SAAS;YACZ,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;QACxB,CAAC;QAED,KAAK,CAAC,GAAW;YAChB,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAClB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;aACnB;QACF,CAAC;QAED,KAAK,CAAC,KAAqB;YAC1B,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAClB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;aACrB;QACF,CAAC;;IAhCD,8EAA8E;IAC9E,4EAA4E;IAC5E,sCAAsC;IACtB,gDAAoB,GAAG,sBAAsB,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { Database, Statement } from 'vscode-sqlite3';\nimport { promises } from 'fs';\nimport { Event } from 'vs/base/common/event';\nimport { timeout } from 'vs/base/common/async';\nimport { mapToString, setToString } from 'vs/base/common/map';\nimport { basename } from 'vs/base/common/path';\nimport { copy } from 'vs/base/node/pfs';\nimport { IStorageDatabase, IStorageItemsChangeEvent, IUpdateRequest } from 'vs/base/parts/storage/common/storage';\n\ninterface IDatabaseConnection {\n\treadonly db: Database;\n\treadonly isInMemory: boolean;\n\n\tisErroneous?: boolean;\n\tlastError?: string;\n}\n\nexport interface ISQLiteStorageDatabaseOptions {\n\treadonly logging?: ISQLiteStorageDatabaseLoggingOptions;\n}\n\nexport interface ISQLiteStorageDatabaseLoggingOptions {\n\tlogError?: (error: string | Error) => void;\n\tlogTrace?: (msg: string) => void;\n}\n\nexport class SQLiteStorageDatabase implements IStorageDatabase {\n\n\tstatic readonly IN_MEMORY_PATH = ':memory:';\n\n\tget onDidChangeItemsExternal(): Event<IStorageItemsChangeEvent> { return Event.None; } // since we are the only client, there can be no external changes\n\n\tprivate static readonly BUSY_OPEN_TIMEOUT = 2000; // timeout in ms to retry when opening DB fails with SQLITE_BUSY\n\tprivate static readonly MAX_HOST_PARAMETERS = 256; // maximum number of parameters within a statement\n\n\tprivate readonly name = basename(this.path);\n\n\tprivate readonly logger = new SQLiteStorageDatabaseLogger(this.options.logging);\n\n\tprivate readonly whenConnected = this.connect(this.path);\n\n\tconstructor(private readonly path: string, private readonly options: ISQLiteStorageDatabaseOptions = Object.create(null)) { }\n\n\tasync getItems(): Promise<Map<string, string>> {\n\t\tconst connection = await this.whenConnected;\n\n\t\tconst items = new Map<string, string>();\n\n\t\tconst rows = await this.all(connection, 'SELECT * FROM ItemTable');\n\t\trows.forEach(row => items.set(row.key, row.value));\n\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] getItems(): ${items.size} rows`);\n\t\t}\n\n\t\treturn items;\n\t}\n\n\tasync updateItems(request: IUpdateRequest): Promise<void> {\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doUpdateItems(connection, request);\n\t}\n\n\tprivate doUpdateItems(connection: IDatabaseConnection, request: IUpdateRequest): Promise<void> {\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] updateItems(): insert(${request.insert ? mapToString(request.insert) : '0'}), delete(${request.delete ? setToString(request.delete) : '0'})`);\n\t\t}\n\n\t\treturn this.transaction(connection, () => {\n\t\t\tconst toInsert = request.insert;\n\t\t\tconst toDelete = request.delete;\n\n\t\t\t// INSERT\n\t\t\tif (toInsert && toInsert.size > 0) {\n\t\t\t\tconst keysValuesChunks: (string[])[] = [];\n\t\t\t\tkeysValuesChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split key/values into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the INSERT with as many HOST parameters as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\tlet keyValueChunk = keysValuesChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyValueChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyValueChunk = [];\n\t\t\t\t\t\tkeysValuesChunks.push(keyValueChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyValueChunk.push(key, value);\n\t\t\t\t});\n\n\t\t\t\tkeysValuesChunks.forEach(keysValuesChunk => {\n\t\t\t\t\tthis.prepare(connection, `INSERT INTO ItemTable VALUES ${new Array(keysValuesChunk.length / 2).fill('(?,?)').join(',')}`, stmt => stmt.run(keysValuesChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\tlet length = 0;\n\t\t\t\t\t\ttoInsert.forEach((value, key) => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t\tlength += value.length;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')} Length: ${length}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// DELETE\n\t\t\tif (toDelete && toDelete.size) {\n\t\t\t\tconst keysChunks: (string[])[] = [];\n\t\t\t\tkeysChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split keys into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the DELETE with as many HOST parameters\n\t\t\t\t// as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\ttoDelete.forEach(key => {\n\t\t\t\t\tlet keyChunk = keysChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyChunk = [];\n\t\t\t\t\t\tkeysChunks.push(keyChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyChunk.push(key);\n\t\t\t\t});\n\n\t\t\t\tkeysChunks.forEach(keysChunk => {\n\t\t\t\t\tthis.prepare(connection, `DELETE FROM ItemTable WHERE key IN (${new Array(keysChunk.length).fill('?').join(',')})`, stmt => stmt.run(keysChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\ttoDelete.forEach(key => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tasync close(recovery?: () => Map<string, string>): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] close()`);\n\n\t\tconst connection = await this.whenConnected;\n\n\t\treturn this.doClose(connection, recovery);\n\t}\n\n\tprivate doClose(connection: IDatabaseConnection, recovery?: () => Map<string, string>): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.close(closeError => {\n\t\t\t\tif (closeError) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] close(): ${closeError}`);\n\t\t\t\t}\n\n\t\t\t\t// Return early if this storage was created only in-memory\n\t\t\t\t// e.g. when running tests we do not need to backup.\n\t\t\t\tif (this.path === SQLiteStorageDatabase.IN_MEMORY_PATH) {\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\t// If the DB closed successfully and we are not running in-memory\n\t\t\t\t// and the DB did not get errors during runtime, make a backup\n\t\t\t\t// of the DB so that we can use it as fallback in case the actual\n\t\t\t\t// DB becomes corrupt in the future.\n\t\t\t\tif (!connection.isErroneous && !connection.isInMemory) {\n\t\t\t\t\treturn this.backup().then(resolve, error => {\n\t\t\t\t\t\tthis.logger.error(`[storage ${this.name}] backup(): ${error}`);\n\n\t\t\t\t\t\treturn resolve(); // ignore failing backup\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recovery: if we detected errors while using the DB or we are using\n\t\t\t\t// an inmemory DB (as a fallback to not being able to open the DB initially)\n\t\t\t\t// and we have a recovery function provided, we recreate the DB with this\n\t\t\t\t// data to recover all known data without loss if possible.\n\t\t\t\tif (typeof recovery === 'function') {\n\n\t\t\t\t\t// Delete the existing DB. If the path does not exist or fails to\n\t\t\t\t\t// be deleted, we do not try to recover anymore because we assume\n\t\t\t\t\t// that the path is no longer writeable for us.\n\t\t\t\t\treturn promises.unlink(this.path).then(() => {\n\n\t\t\t\t\t\t// Re-open the DB fresh\n\t\t\t\t\t\treturn this.doConnect(this.path).then(recoveryConnection => {\n\t\t\t\t\t\t\tconst closeRecoveryConnection = () => {\n\t\t\t\t\t\t\t\treturn this.doClose(recoveryConnection, undefined /* do not attempt to recover again */);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Store items\n\t\t\t\t\t\t\treturn this.doUpdateItems(recoveryConnection, { insert: recovery() }).then(() => closeRecoveryConnection(), error => {\n\n\t\t\t\t\t\t\t\t// In case of an error updating items, still ensure to close the connection\n\t\t\t\t\t\t\t\t// to prevent SQLITE_BUSY errors when the connection is reestablished\n\t\t\t\t\t\t\t\tcloseRecoveryConnection();\n\n\t\t\t\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}).then(resolve, reject);\n\t\t\t\t}\n\n\t\t\t\t// Finally without recovery we just reject\n\t\t\t\treturn reject(closeError || new Error('Database has errors or is in-memory without recovery option'));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate backup(): Promise<void> {\n\t\tconst backupPath = this.toBackupPath(this.path);\n\n\t\treturn copy(this.path, backupPath, { preserveSymlinks: false });\n\t}\n\n\tprivate toBackupPath(path: string): string {\n\t\treturn `${path}.backup`;\n\t}\n\n\tasync checkIntegrity(full: boolean): Promise<string> {\n\t\tthis.logger.trace(`[storage ${this.name}] checkIntegrity(full: ${full})`);\n\n\t\tconst connection = await this.whenConnected;\n\t\tconst row = await this.get(connection, full ? 'PRAGMA integrity_check' : 'PRAGMA quick_check');\n\n\t\tconst integrity = full ? (row as any)['integrity_check'] : (row as any)['quick_check'];\n\n\t\tif (connection.isErroneous) {\n\t\t\treturn `${integrity} (last error: ${connection.lastError})`;\n\t\t}\n\n\t\tif (connection.isInMemory) {\n\t\t\treturn `${integrity} (in-memory!)`;\n\t\t}\n\n\t\treturn integrity;\n\t}\n\n\tprivate async connect(path: string, retryOnBusy: boolean = true): Promise<IDatabaseConnection> {\n\t\tthis.logger.trace(`[storage ${this.name}] open(${path}, retryOnBusy: ${retryOnBusy})`);\n\n\t\ttry {\n\t\t\treturn await this.doConnect(path);\n\t\t} catch (error) {\n\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to open DB due to ${error}`);\n\n\t\t\t// SQLITE_BUSY should only arise if another process is locking the same DB we want\n\t\t\t// to open at that time. This typically never happens because a DB connection is\n\t\t\t// limited per window. However, in the event of a window reload, it may be possible\n\t\t\t// that the previous connection was not properly closed while the new connection is\n\t\t\t// already established.\n\t\t\t//\n\t\t\t// In this case we simply wait for some time and retry once to establish the connection.\n\t\t\t//\n\t\t\tif (error.code === 'SQLITE_BUSY' && retryOnBusy) {\n\t\t\t\tawait timeout(SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT);\n\n\t\t\t\treturn this.connect(path, false /* not another retry */);\n\t\t\t}\n\n\t\t\t// Otherwise, best we can do is to recover from a backup if that exists, as such we\n\t\t\t// move the DB to a different filename and try to load from backup. If that fails,\n\t\t\t// a new empty DB is being created automatically.\n\t\t\t//\n\t\t\t// The final fallback is to use an in-memory DB which should only happen if the target\n\t\t\t// folder is really not writeable for us.\n\t\t\t//\n\t\t\ttry {\n\t\t\t\tawait promises.unlink(path);\n\t\t\t\ttry {\n\t\t\t\t\tawait promises.rename(this.toBackupPath(path), path);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\n\t\t\t\treturn await this.doConnect(path);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to use backup due to ${error}`);\n\n\t\t\t\t// In case of any error to open the DB, use an in-memory\n\t\t\t\t// DB so that we always have a valid DB to talk to.\n\t\t\t\treturn this.doConnect(SQLiteStorageDatabase.IN_MEMORY_PATH);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleSQLiteError(connection: IDatabaseConnection, msg: string): void {\n\t\tconnection.isErroneous = true;\n\t\tconnection.lastError = msg;\n\n\t\tthis.logger.error(msg);\n\t}\n\n\tprivate doConnect(path: string): Promise<IDatabaseConnection> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\timport('vscode-sqlite3').then(sqlite3 => {\n\t\t\t\tconst connection: IDatabaseConnection = {\n\t\t\t\t\tdb: new (this.logger.isTracing ? sqlite3.verbose().Database : sqlite3.Database)(path, error => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn connection.db ? connection.db.close(() => reject(error)) : reject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The following exec() statement serves two purposes:\n\t\t\t\t\t\t// - create the DB if it does not exist yet\n\t\t\t\t\t\t// - validate that the DB is not corrupt (the open() call does not throw otherwise)\n\t\t\t\t\t\treturn this.exec(connection, [\n\t\t\t\t\t\t\t'PRAGMA user_version = 1;',\n\t\t\t\t\t\t\t'CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)'\n\t\t\t\t\t\t].join('')).then(() => {\n\t\t\t\t\t\t\treturn resolve(connection);\n\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\treturn connection.db.close(() => reject(error));\n\t\t\t\t\t\t});\n\t\t\t\t\t}),\n\t\t\t\t\tisInMemory: path === SQLiteStorageDatabase.IN_MEMORY_PATH\n\t\t\t\t};\n\n\t\t\t\t// Errors\n\t\t\t\tconnection.db.on('error', error => this.handleSQLiteError(connection, `[storage ${this.name}] Error (event): ${error}`));\n\n\t\t\t\t// Tracing\n\t\t\t\tif (this.logger.isTracing) {\n\t\t\t\t\tconnection.db.on('trace', sql => this.logger.trace(`[storage ${this.name}] Trace (event): ${sql}`));\n\t\t\t\t}\n\t\t\t}, reject);\n\t\t});\n\t}\n\n\tprivate exec(connection: IDatabaseConnection, sql: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.exec(sql, error => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] exec(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate get(connection: IDatabaseConnection, sql: string): Promise<object> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.get(sql, (error, row) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] get(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(row);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate all(connection: IDatabaseConnection, sql: string): Promise<{ key: string, value: string }[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.all(sql, (error, rows) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] all(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(rows);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate transaction(connection: IDatabaseConnection, transactions: () => void): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.serialize(() => {\n\t\t\t\tconnection.db.run('BEGIN TRANSACTION');\n\n\t\t\t\ttransactions();\n\n\t\t\t\tconnection.db.run('END TRANSACTION', error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] transaction(): ${error}`);\n\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate prepare(connection: IDatabaseConnection, sql: string, runCallback: (stmt: Statement) => void, errorDetails: () => string): void {\n\t\tconst stmt = connection.db.prepare(sql);\n\n\t\tconst statementErrorListener = (error: Error) => {\n\t\t\tthis.handleSQLiteError(connection, `[storage ${this.name}] prepare(): ${error} (${sql}). Details: ${errorDetails()}`);\n\t\t};\n\n\t\tstmt.on('error', statementErrorListener);\n\n\t\trunCallback(stmt);\n\n\t\tstmt.finalize(error => {\n\t\t\tif (error) {\n\t\t\t\tstatementErrorListener(error);\n\t\t\t}\n\n\t\t\tstmt.removeListener('error', statementErrorListener);\n\t\t});\n\t}\n}\n\nclass SQLiteStorageDatabaseLogger {\n\n\t// to reduce lots of output, require an environment variable to enable tracing\n\t// this helps when running with --verbose normally where the storage tracing\n\t// might hide useful output to look at\n\tstatic readonly VSCODE_TRACE_STORAGE = 'VSCODE_TRACE_STORAGE';\n\n\tprivate readonly logTrace: ((msg: string) => void) | undefined;\n\tprivate readonly logError: ((error: string | Error) => void) | undefined;\n\n\tconstructor(options?: ISQLiteStorageDatabaseLoggingOptions) {\n\t\tif (options && typeof options.logTrace === 'function' && process.env[SQLiteStorageDatabaseLogger.VSCODE_TRACE_STORAGE]) {\n\t\t\tthis.logTrace = options.logTrace;\n\t\t}\n\n\t\tif (options && typeof options.logError === 'function') {\n\t\t\tthis.logError = options.logError;\n\t\t}\n\t}\n\n\tget isTracing(): boolean {\n\t\treturn !!this.logTrace;\n\t}\n\n\ttrace(msg: string): void {\n\t\tif (this.logTrace) {\n\t\t\tthis.logTrace(msg);\n\t\t}\n\t}\n\n\terror(error: string | Error): void {\n\t\tif (this.logError) {\n\t\t\tthis.logError(error);\n\t\t}\n\t}\n}\n"]}