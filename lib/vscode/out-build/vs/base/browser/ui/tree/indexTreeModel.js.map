{"version":3,"file":"indexTreeModel.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/browser/ui/tree/indexTreeModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IIdentityProvider } from 'vs/base/browser/ui/list/list';\nimport { ICollapseStateChangeEvent, ITreeElement, ITreeFilter, ITreeFilterDataResult, ITreeModel, ITreeNode, TreeVisibility, ITreeModelSpliceEvent, TreeError } from 'vs/base/browser/ui/tree/tree';\nimport { tail2 } from 'vs/base/common/arrays';\nimport { LcsDiff } from 'vs/base/common/diff/diff';\nimport { Emitter, Event, EventBufferer } from 'vs/base/common/event';\nimport { Iterable } from 'vs/base/common/iterator';\nimport { ISpliceable } from 'vs/base/common/sequence';\n\n// Exported for tests\nexport interface IIndexTreeNode<T, TFilterData = void> extends ITreeNode<T, TFilterData> {\n\treadonly parent: IIndexTreeNode<T, TFilterData> | undefined;\n\treadonly children: IIndexTreeNode<T, TFilterData>[];\n\tvisibleChildrenCount: number;\n\tvisibleChildIndex: number;\n\tcollapsible: boolean;\n\tcollapsed: boolean;\n\trenderNodeCount: number;\n\tvisibility: TreeVisibility;\n\tvisible: boolean;\n\tfilterData: TFilterData | undefined;\n}\n\nexport function isFilterResult<T>(obj: any): obj is ITreeFilterDataResult<T> {\n\treturn typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\n\nexport function getVisibleState(visibility: boolean | TreeVisibility): TreeVisibility {\n\tswitch (visibility) {\n\t\tcase true: return TreeVisibility.Visible;\n\t\tcase false: return TreeVisibility.Hidden;\n\t\tdefault: return visibility;\n\t}\n}\n\nexport interface IIndexTreeModelOptions<T, TFilterData> {\n\treadonly collapseByDefault?: boolean; // defaults to false\n\treadonly filter?: ITreeFilter<T, TFilterData>;\n\treadonly autoExpandSingleChildren?: boolean;\n}\n\nexport interface IIndexTreeModelSpliceOptions<T, TFilterData> {\n\t/**\n\t * If set, child updates will recurse the given number of levels even if\n\t * items in the splice operation are unchanged. `Infinity` is a valid value.\n\t */\n\treadonly diffDepth?: number;\n\n\t/**\n\t * Identity provider used to optimize splice() calls in the IndexTree. If\n\t * this is not present, optimized splicing is not enabled.\n\t *\n\t * Warning: if this is present, calls to `setChildren()` will not replace\n\t * or update nodes if their identity is the same, even if the elements are\n\t * different. For this, you should call `rerender()`.\n\t */\n\treadonly diffIdentityProvider?: IIdentityProvider<T>;\n\n\t/**\n\t * Callback for when a node is created.\n\t */\n\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void;\n\n\t/**\n\t * Callback for when a node is deleted.\n\t */\n\tonDidDeleteNode?: (node: ITreeNode<T, TFilterData>) => void\n}\n\ninterface CollapsibleStateUpdate {\n\treadonly collapsible: boolean;\n}\n\ninterface CollapsedStateUpdate {\n\treadonly collapsed: boolean;\n\treadonly recursive: boolean;\n}\n\ntype CollapseStateUpdate = CollapsibleStateUpdate | CollapsedStateUpdate;\n\nfunction isCollapsibleStateUpdate(update: CollapseStateUpdate): update is CollapsibleStateUpdate {\n\treturn typeof (update as any).collapsible === 'boolean';\n}\n\nexport interface IList<T> extends ISpliceable<T> {\n\tupdateElementHeight(index: number, height: number): void;\n}\n\nexport class IndexTreeModel<T extends Exclude<any, undefined>, TFilterData = void> implements ITreeModel<T, TFilterData, number[]> {\n\n\treadonly rootRef = [];\n\n\tprivate root: IIndexTreeNode<T, TFilterData>;\n\tprivate eventBufferer = new EventBufferer();\n\n\tprivate readonly _onDidChangeCollapseState = new Emitter<ICollapseStateChangeEvent<T, TFilterData>>();\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>> = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n\n\tprivate readonly _onDidChangeRenderNodeCount = new Emitter<ITreeNode<T, TFilterData>>();\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>> = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n\n\tprivate collapseByDefault: boolean;\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\tprivate autoExpandSingleChildren: boolean;\n\n\tprivate readonly _onDidSplice = new Emitter<ITreeModelSpliceEvent<T, TFilterData>>();\n\treadonly onDidSplice = this._onDidSplice.event;\n\n\tconstructor(\n\t\tprivate user: string,\n\t\tprivate list: IList<ITreeNode<T, TFilterData>>,\n\t\trootElement: T,\n\t\toptions: IIndexTreeModelOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n\t\tthis.filter = options.filter;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\n\t\tthis.root = {\n\t\t\tparent: undefined,\n\t\t\telement: rootElement,\n\t\t\tchildren: [],\n\t\t\tdepth: 0,\n\t\t\tvisibleChildrenCount: 0,\n\t\t\tvisibleChildIndex: -1,\n\t\t\tcollapsible: false,\n\t\t\tcollapsed: false,\n\t\t\trenderNodeCount: 0,\n\t\t\tvisibility: TreeVisibility.Visible,\n\t\t\tvisible: true,\n\t\t\tfilterData: undefined\n\t\t};\n\t}\n\n\tsplice(\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsert: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IIndexTreeModelSpliceOptions<T, TFilterData> = {},\n\t): void {\n\t\tif (location.length === 0) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\tif (options.diffIdentityProvider) {\n\t\t\tthis.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n\t\t} else {\n\t\t\tthis.spliceSimple(location, deleteCount, toInsert, options);\n\t\t}\n\t}\n\n\tprivate spliceSmart(\n\t\tidentity: IIdentityProvider<T>,\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsertIterable: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\toptions: IIndexTreeModelSpliceOptions<T, TFilterData>,\n\t\trecurseLevels = options.diffDepth ?? 0,\n\t) {\n\t\tconst { parentNode } = this.getParentNodeWithListIndex(location);\n\t\tconst toInsert = [...toInsertIterable];\n\t\tconst index = location[location.length - 1];\n\t\tconst diff = new LcsDiff(\n\t\t\t{ getElements: () => parentNode.children.map(e => identity.getId(e.element).toString()) },\n\t\t\t{\n\t\t\t\tgetElements: () => [\n\t\t\t\t\t...parentNode.children.slice(0, index),\n\t\t\t\t\t...toInsert,\n\t\t\t\t\t...parentNode.children.slice(index + deleteCount),\n\t\t\t\t].map(e => identity.getId(e.element).toString())\n\t\t\t},\n\t\t).ComputeDiff(false);\n\n\t\t// if we were given a 'best effort' diff, use default behavior\n\t\tif (diff.quitEarly) {\n\t\t\treturn this.spliceSimple(location, deleteCount, toInsert, options);\n\t\t}\n\n\t\tconst locationPrefix = location.slice(0, -1);\n\t\tconst recurseSplice = (fromOriginal: number, fromModified: number, count: number) => {\n\t\t\tif (recurseLevels > 0) {\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tfromOriginal--;\n\t\t\t\t\tfromModified--;\n\t\t\t\t\tthis.spliceSmart(\n\t\t\t\t\t\tidentity,\n\t\t\t\t\t\t[...locationPrefix, fromOriginal, 0],\n\t\t\t\t\t\tNumber.MAX_SAFE_INTEGER,\n\t\t\t\t\t\ttoInsert[fromModified].children,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\trecurseLevels - 1,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n\t\tlet lastStartM = toInsert.length;\n\t\tfor (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n\t\t\trecurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n\t\t\tlastStartO = change.originalStart;\n\t\t\tlastStartM = change.modifiedStart - index;\n\n\t\t\tthis.spliceSimple(\n\t\t\t\t[...locationPrefix, lastStartO],\n\t\t\t\tchange.originalLength,\n\t\t\t\tIterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength),\n\t\t\t\toptions,\n\t\t\t);\n\t\t}\n\n\t\t// at this point, startO === startM === count since any remaining prefix should match\n\t\trecurseSplice(lastStartO, lastStartM, lastStartO);\n\t}\n\n\tprivate spliceSimple(\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsert: Iterable<ITreeElement<T>> = Iterable.empty(),\n\t\t{ onDidCreateNode, onDidDeleteNode }: IIndexTreeModelSpliceOptions<T, TFilterData>,\n\t) {\n\t\tconst { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n\t\tconst treeListElementsToInsert: ITreeNode<T, TFilterData>[] = [];\n\t\tconst nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? TreeVisibility.Visible : TreeVisibility.Hidden, revealed, treeListElementsToInsert, onDidCreateNode));\n\n\t\tconst lastIndex = location[location.length - 1];\n\t\tconst lastHadChildren = parentNode.children.length > 0;\n\n\t\t// figure out what's the visible child start index right before the\n\t\t// splice point\n\t\tlet visibleChildStartIndex = 0;\n\n\t\tfor (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n\t\t\tconst child = parentNode.children[i];\n\n\t\t\tif (child.visible) {\n\t\t\t\tvisibleChildStartIndex = child.visibleChildIndex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst nodesToInsert: IIndexTreeNode<T, TFilterData>[] = [];\n\t\tlet insertedVisibleChildrenCount = 0;\n\t\tlet renderNodeCount = 0;\n\n\t\tfor (const child of nodesToInsertIterator) {\n\t\t\tnodesToInsert.push(child);\n\t\t\trenderNodeCount += child.renderNodeCount;\n\n\t\t\tif (child.visible) {\n\t\t\t\tchild.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\tconst deletedNodes = parentNode.children.splice(lastIndex, deleteCount, ...nodesToInsert);\n\n\t\t// figure out what is the count of deleted visible children\n\t\tlet deletedVisibleChildrenCount = 0;\n\n\t\tfor (const child of deletedNodes) {\n\t\t\tif (child.visible) {\n\t\t\t\tdeletedVisibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\t// and adjust for all visible children after the splice point\n\t\tif (deletedVisibleChildrenCount !== 0) {\n\t\t\tfor (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n\t\t\t\tconst child = parentNode.children[i];\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tchild.visibleChildIndex -= deletedVisibleChildrenCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update parent's visible children count\n\t\tparentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n\n\t\tif (revealed && visible) {\n\t\t\tconst visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n\n\t\t\tthis._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n\t\t\tthis.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n\t\t}\n\n\t\tif (deletedNodes.length > 0 && onDidDeleteNode) {\n\t\t\tconst visit = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tonDidDeleteNode(node);\n\t\t\t\tnode.children.forEach(visit);\n\t\t\t};\n\n\t\t\tdeletedNodes.forEach(visit);\n\t\t}\n\n\t\tconst currentlyHasChildren = parentNode.children.length > 0;\n\t\tif (lastHadChildren !== currentlyHasChildren) {\n\t\t\tthis.setCollapsible(location.slice(0, -1), currentlyHasChildren);\n\t\t}\n\n\t\tthis._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\n\n\t\tlet node: IIndexTreeNode<T, TFilterData> | undefined = parentNode;\n\n\t\twhile (node) {\n\t\t\tif (node.visibility === TreeVisibility.Recurse) {\n\t\t\t\tthis.refilter();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\t}\n\n\trerender(location: number[]): void {\n\t\tif (location.length === 0) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\tconst { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n\n\t\tif (node.visible && revealed) {\n\t\t\tthis.list.splice(listIndex, 1, [node]);\n\t\t}\n\t}\n\n\tupdateElementHeight(location: number[], height: number): void {\n\t\tif (location.length === 0) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\tconst { listIndex } = this.getTreeNodeWithListIndex(location);\n\t\tthis.list.updateElementHeight(listIndex, height);\n\t}\n\n\thas(location: number[]): boolean {\n\t\treturn this.hasTreeNode(location);\n\t}\n\n\tgetListIndex(location: number[]): number {\n\t\tconst { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n\t\treturn visible && revealed ? listIndex : -1;\n\t}\n\n\tgetListRenderCount(location: number[]): number {\n\t\treturn this.getTreeNode(location).renderNodeCount;\n\t}\n\n\tisCollapsible(location: number[]): boolean {\n\t\treturn this.getTreeNode(location).collapsible;\n\t}\n\n\tsetCollapsible(location: number[], collapsible?: boolean): boolean {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (typeof collapsible === 'undefined') {\n\t\t\tcollapsible = !node.collapsible;\n\t\t}\n\n\t\tconst update: CollapsibleStateUpdate = { collapsible };\n\t\treturn this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n\t}\n\n\tisCollapsed(location: number[]): boolean {\n\t\treturn this.getTreeNode(location).collapsed;\n\t}\n\n\tsetCollapsed(location: number[], collapsed?: boolean, recursive?: boolean): boolean {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (typeof collapsed === 'undefined') {\n\t\t\tcollapsed = !node.collapsed;\n\t\t}\n\n\t\tconst update: CollapsedStateUpdate = { collapsed, recursive: recursive || false };\n\t\treturn this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n\t}\n\n\tprivate _setCollapseState(location: number[], update: CollapseStateUpdate): boolean {\n\t\tconst { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n\n\t\tconst result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n\n\t\tif (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n\t\t\tlet onlyVisibleChildIndex = -1;\n\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tif (onlyVisibleChildIndex > -1) {\n\t\t\t\t\t\tonlyVisibleChildIndex = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonlyVisibleChildIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (onlyVisibleChildIndex > -1) {\n\t\t\t\tthis._setCollapseState([...location, onlyVisibleChildIndex], update);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _setListNodeCollapseState(node: IIndexTreeNode<T, TFilterData>, listIndex: number, revealed: boolean, update: CollapseStateUpdate): boolean {\n\t\tconst result = this._setNodeCollapseState(node, update, false);\n\n\t\tif (!revealed || !node.visible || !result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst toInsert = this.updateNodeAfterCollapseChange(node);\n\t\tconst deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n\t\tthis.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n\n\t\treturn result;\n\t}\n\n\tprivate _setNodeCollapseState(node: IIndexTreeNode<T, TFilterData>, update: CollapseStateUpdate, deep: boolean): boolean {\n\t\tlet result: boolean;\n\n\t\tif (node === this.root) {\n\t\t\tresult = false;\n\t\t} else {\n\t\t\tif (isCollapsibleStateUpdate(update)) {\n\t\t\t\tresult = node.collapsible !== update.collapsible;\n\t\t\t\tnode.collapsible = update.collapsible;\n\t\t\t} else if (!node.collapsible) {\n\t\t\t\tresult = false;\n\t\t\t} else {\n\t\t\t\tresult = node.collapsed !== update.collapsed;\n\t\t\t\tnode.collapsed = update.collapsed;\n\t\t\t}\n\n\t\t\tif (result) {\n\t\t\t\tthis._onDidChangeCollapseState.fire({ node, deep });\n\t\t\t}\n\t\t}\n\n\t\tif (!isCollapsibleStateUpdate(update) && update.recursive) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tresult = this._setNodeCollapseState(child, update, true) || result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texpandTo(location: number[]): void {\n\t\tthis.eventBufferer.bufferEvents(() => {\n\t\t\tlet node = this.getTreeNode(location);\n\n\t\t\twhile (node.parent) {\n\t\t\t\tnode = node.parent;\n\t\t\t\tlocation = location.slice(0, location.length - 1);\n\n\t\t\t\tif (node.collapsed) {\n\t\t\t\t\tthis._setCollapseState(location, { collapsed: false, recursive: false });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\trefilter(): void {\n\t\tconst previousRenderNodeCount = this.root.renderNodeCount;\n\t\tconst toInsert = this.updateNodeAfterFilterChange(this.root);\n\t\tthis.list.splice(0, previousRenderNodeCount, toInsert);\n\t}\n\n\tprivate createTreeNode(\n\t\ttreeElement: ITreeElement<T>,\n\t\tparent: IIndexTreeNode<T, TFilterData>,\n\t\tparentVisibility: TreeVisibility,\n\t\trevealed: boolean,\n\t\ttreeListElements: ITreeNode<T, TFilterData>[],\n\t\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void\n\t): IIndexTreeNode<T, TFilterData> {\n\t\tconst node: IIndexTreeNode<T, TFilterData> = {\n\t\t\tparent,\n\t\t\telement: treeElement.element,\n\t\t\tchildren: [],\n\t\t\tdepth: parent.depth + 1,\n\t\t\tvisibleChildrenCount: 0,\n\t\t\tvisibleChildIndex: -1,\n\t\t\tcollapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n\t\t\tcollapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n\t\t\trenderNodeCount: 1,\n\t\t\tvisibility: TreeVisibility.Visible,\n\t\t\tvisible: true,\n\t\t\tfilterData: undefined\n\t\t};\n\n\t\tconst visibility = this._filterNode(node, parentVisibility);\n\t\tnode.visibility = visibility;\n\n\t\tif (revealed) {\n\t\t\ttreeListElements.push(node);\n\t\t}\n\n\t\tconst childElements = treeElement.children || Iterable.empty();\n\t\tconst childRevealed = revealed && visibility !== TreeVisibility.Hidden && !node.collapsed;\n\t\tconst childNodes = Iterable.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));\n\n\t\tlet visibleChildrenCount = 0;\n\t\tlet renderNodeCount = 1;\n\n\t\tfor (const child of childNodes) {\n\t\t\tnode.children.push(child);\n\t\t\trenderNodeCount += child.renderNodeCount;\n\n\t\t\tif (child.visible) {\n\t\t\t\tchild.visibleChildIndex = visibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\tnode.collapsible = node.collapsible || node.children.length > 0;\n\t\tnode.visibleChildrenCount = visibleChildrenCount;\n\t\tnode.visible = visibility === TreeVisibility.Recurse ? visibleChildrenCount > 0 : (visibility === TreeVisibility.Visible);\n\n\t\tif (!node.visible) {\n\t\t\tnode.renderNodeCount = 0;\n\n\t\t\tif (revealed) {\n\t\t\t\ttreeListElements.pop();\n\t\t\t}\n\t\t} else if (!node.collapsed) {\n\t\t\tnode.renderNodeCount = renderNodeCount;\n\t\t}\n\n\t\tif (onDidCreateNode) {\n\t\t\tonDidCreateNode(node);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate updateNodeAfterCollapseChange(node: IIndexTreeNode<T, TFilterData>): ITreeNode<T, TFilterData>[] {\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst result: ITreeNode<T, TFilterData>[] = [];\n\n\t\tthis._updateNodeAfterCollapseChange(node, result);\n\t\tthis._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n\t\treturn result;\n\t}\n\n\tprivate _updateNodeAfterCollapseChange(node: IIndexTreeNode<T, TFilterData>, result: ITreeNode<T, TFilterData>[]): number {\n\t\tif (node.visible === false) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult.push(node);\n\t\tnode.renderNodeCount = 1;\n\n\t\tif (!node.collapsed) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnode.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\treturn node.renderNodeCount;\n\t}\n\n\tprivate updateNodeAfterFilterChange(node: IIndexTreeNode<T, TFilterData>): ITreeNode<T, TFilterData>[] {\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst result: ITreeNode<T, TFilterData>[] = [];\n\n\t\tthis._updateNodeAfterFilterChange(node, node.visible ? TreeVisibility.Visible : TreeVisibility.Hidden, result);\n\t\tthis._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n\t\treturn result;\n\t}\n\n\tprivate _updateNodeAfterFilterChange(node: IIndexTreeNode<T, TFilterData>, parentVisibility: TreeVisibility, result: ITreeNode<T, TFilterData>[], revealed = true): boolean {\n\t\tlet visibility: TreeVisibility;\n\n\t\tif (node !== this.root) {\n\t\t\tvisibility = this._filterNode(node, parentVisibility);\n\n\t\t\tif (visibility === TreeVisibility.Hidden) {\n\t\t\t\tnode.visible = false;\n\t\t\t\tnode.renderNodeCount = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (revealed) {\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst resultStartLength = result.length;\n\t\tnode.renderNodeCount = node === this.root ? 0 : 1;\n\n\t\tlet hasVisibleDescendants = false;\n\t\tif (!node.collapsed || visibility! !== TreeVisibility.Hidden) {\n\t\t\tlet visibleChildIndex = 0;\n\n\t\t\tfor (const child of node.children) {\n\t\t\t\thasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility!, result, revealed && !node.collapsed) || hasVisibleDescendants;\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tchild.visibleChildIndex = visibleChildIndex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.visibleChildrenCount = visibleChildIndex;\n\t\t} else {\n\t\t\tnode.visibleChildrenCount = 0;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tnode.visible = visibility! === TreeVisibility.Recurse ? hasVisibleDescendants : (visibility! === TreeVisibility.Visible);\n\t\t}\n\n\t\tif (!node.visible) {\n\t\t\tnode.renderNodeCount = 0;\n\n\t\t\tif (revealed) {\n\t\t\t\tresult.pop();\n\t\t\t}\n\t\t} else if (!node.collapsed) {\n\t\t\tnode.renderNodeCount += result.length - resultStartLength;\n\t\t}\n\n\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\treturn node.visible;\n\t}\n\n\tprivate _updateAncestorsRenderNodeCount(node: IIndexTreeNode<T, TFilterData> | undefined, diff: number): void {\n\t\tif (diff === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (node) {\n\t\t\tnode.renderNodeCount += diff;\n\t\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t}\n\n\tprivate _filterNode(node: IIndexTreeNode<T, TFilterData>, parentVisibility: TreeVisibility): TreeVisibility {\n\t\tconst result = this.filter ? this.filter.filter(node.element, parentVisibility) : TreeVisibility.Visible;\n\n\t\tif (typeof result === 'boolean') {\n\t\t\tnode.filterData = undefined;\n\t\t\treturn result ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t\t} else if (isFilterResult<TFilterData>(result)) {\n\t\t\tnode.filterData = result.data;\n\t\t\treturn getVisibleState(result.visibility);\n\t\t} else {\n\t\t\tnode.filterData = undefined;\n\t\t\treturn getVisibleState(result);\n\t\t}\n\t}\n\n\t// cheap\n\tprivate hasTreeNode(location: number[], node: IIndexTreeNode<T, TFilterData> = this.root): boolean {\n\t\tif (!location || location.length === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.hasTreeNode(rest, node.children[index]);\n\t}\n\n\t// cheap\n\tprivate getTreeNode(location: number[], node: IIndexTreeNode<T, TFilterData> = this.root): IIndexTreeNode<T, TFilterData> {\n\t\tif (!location || location.length === 0) {\n\t\t\treturn node;\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\treturn this.getTreeNode(rest, node.children[index]);\n\t}\n\n\t// expensive\n\tprivate getTreeNodeWithListIndex(location: number[]): { node: IIndexTreeNode<T, TFilterData>, listIndex: number, revealed: boolean, visible: boolean } {\n\t\tif (location.length === 0) {\n\t\t\treturn { node: this.root, listIndex: -1, revealed: true, visible: false };\n\t\t}\n\n\t\tconst { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n\t\tconst index = location[location.length - 1];\n\n\t\tif (index < 0 || index > parentNode.children.length) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\tconst node = parentNode.children[index];\n\n\t\treturn { node, listIndex, revealed, visible: visible && node.visible };\n\t}\n\n\tprivate getParentNodeWithListIndex(location: number[], node: IIndexTreeNode<T, TFilterData> = this.root, listIndex: number = 0, revealed = true, visible = true): { parentNode: IIndexTreeNode<T, TFilterData>; listIndex: number; revealed: boolean; visible: boolean; } {\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\tthrow new TreeError(this.user, 'Invalid tree location');\n\t\t}\n\n\t\t// TODO@joao perf!\n\t\tfor (let i = 0; i < index; i++) {\n\t\t\tlistIndex += node.children[i].renderNodeCount;\n\t\t}\n\n\t\trevealed = revealed && !node.collapsed;\n\t\tvisible = visible && node.visible;\n\n\t\tif (rest.length === 0) {\n\t\t\treturn { parentNode: node, listIndex, revealed, visible };\n\t\t}\n\n\t\treturn this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n\t}\n\n\tgetNode(location: number[] = []): ITreeNode<T, TFilterData> {\n\t\treturn this.getTreeNode(location);\n\t}\n\n\t// TODO@joao perf!\n\tgetNodeLocation(node: ITreeNode<T, TFilterData>): number[] {\n\t\tconst location: number[] = [];\n\t\tlet indexTreeNode = node as IIndexTreeNode<T, TFilterData>; // typing woes\n\n\t\twhile (indexTreeNode.parent) {\n\t\t\tlocation.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n\t\t\tindexTreeNode = indexTreeNode.parent;\n\t\t}\n\n\t\treturn location.reverse();\n\t}\n\n\tgetParentNodeLocation(location: number[]): number[] | undefined {\n\t\tif (location.length === 0) {\n\t\t\treturn undefined;\n\t\t} else if (location.length === 1) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn tail2(location)[0];\n\t\t}\n\t}\n\n\tgetFirstElementChild(location: number[]): T | undefined {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (node.children.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn node.children[0].element;\n\t}\n\n\tgetLastElementAncestor(location: number[] = []): T | undefined {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (node.children.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._getLastElementAncestor(node);\n\t}\n\n\tprivate _getLastElementAncestor(node: ITreeNode<T, TFilterData>): T {\n\t\tif (node.children.length === 0) {\n\t\t\treturn node.element;\n\t\t}\n\n\t\treturn this._getLastElementAncestor(node.children[node.children.length - 1]);\n\t}\n}\n"]}