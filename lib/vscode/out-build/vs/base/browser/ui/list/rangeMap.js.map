{"version":3,"file":"rangeMap.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/base/browser/ui/list/rangeMap.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAahG;;;OAGG;IACH,SAAgB,cAAc,CAAC,KAAa,EAAE,MAAsB;QACnE,MAAM,MAAM,GAAmB,EAAE,CAAC;QAElC,KAAK,IAAI,CAAC,IAAI,MAAM,EAAE;YACrB,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE;gBAC/B,SAAS;aACT;YAED,IAAI,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE;gBAC9B,MAAM;aACN;YAED,MAAM,YAAY,GAAG,aAAK,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;YAErD,IAAI,aAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;gBAChC,SAAS;aACT;YAED,MAAM,CAAC,IAAI,CAAC;gBACX,KAAK,EAAE,YAAY;gBACnB,IAAI,EAAE,CAAC,CAAC,IAAI;aACZ,CAAC,CAAC;SACH;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAzBD,wCAyBC;IAED;;OAEG;IACH,SAAgB,KAAK,CAAC,EAAE,KAAK,EAAE,GAAG,EAAU,EAAE,IAAY;QACzD,OAAO,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,CAAC;IACjD,CAAC;IAFD,sBAEC;IAED;;;;;OAKG;IACH,SAAgB,WAAW,CAAC,MAAsB;QACjD,MAAM,MAAM,GAAmB,EAAE,CAAC;QAClC,IAAI,aAAa,GAAwB,IAAI,CAAC;QAE9C,KAAK,IAAI,KAAK,IAAI,MAAM,EAAE;YACzB,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;YAChC,MAAM,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC;YAC5B,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;YAExB,IAAI,aAAa,IAAI,IAAI,KAAK,aAAa,CAAC,IAAI,EAAE;gBACjD,aAAa,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;gBAC9B,SAAS;aACT;YAED,aAAa,GAAG,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE,IAAI,EAAE,CAAC;YAChD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;SAC3B;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAnBD,kCAmBC;IAED;;;OAGG;IACH,SAAS,MAAM,CAAC,GAAG,MAAwB;QAC1C,OAAO,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IAC9D,CAAC;IAED,MAAa,QAAQ;QAArB;YAES,WAAM,GAAmB,EAAE,CAAC;YAC5B,UAAK,GAAG,CAAC,CAAC;QAgGnB,CAAC;QA9FA,MAAM,CAAC,KAAa,EAAE,WAAmB,EAAE,QAAiB,EAAE;YAC7D,MAAM,IAAI,GAAG,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC;YACxC,MAAM,MAAM,GAAG,cAAc,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YACrE,MAAM,KAAK,GAAG,cAAc,CAAC,EAAE,KAAK,EAAE,KAAK,GAAG,WAAW,EAAE,GAAG,EAAE,MAAM,CAAC,iBAAiB,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC;iBACtG,GAAG,CAAe,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;YAE1E,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAe,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;gBACpD,KAAK,EAAE,EAAE,KAAK,EAAE,KAAK,GAAG,CAAC,EAAE,GAAG,EAAE,KAAK,GAAG,CAAC,GAAG,CAAC,EAAE;gBAC/C,IAAI,EAAE,IAAI,CAAC,IAAI;aACf,CAAC,CAAC,CAAC;YAEJ,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;YAC5C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5F,CAAC;QAED;;WAEG;QACH,IAAI,KAAK;YACR,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;YAE/B,IAAI,CAAC,GAAG,EAAE;gBACT,OAAO,CAAC,CAAC;aACT;YAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC;QACvC,CAAC;QAED;;WAEG;QACH,IAAI,IAAI;YACP,OAAO,IAAI,CAAC,KAAK,CAAC;QACnB,CAAC;QAED;;WAEG;QACH,OAAO,CAAC,QAAgB;YACvB,IAAI,QAAQ,GAAG,CAAC,EAAE;gBACjB,OAAO,CAAC,CAAC,CAAC;aACV;YAED,IAAI,KAAK,GAAG,CAAC,CAAC;YACd,IAAI,IAAI,GAAG,CAAC,CAAC;YAEb,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;gBAC9B,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;gBAClD,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;gBAE5C,IAAI,QAAQ,GAAG,OAAO,EAAE;oBACvB,OAAO,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;iBAC1D;gBAED,KAAK,IAAI,KAAK,CAAC;gBACf,IAAI,GAAG,OAAO,CAAC;aACf;YAED,OAAO,KAAK,CAAC;QACd,CAAC;QAED;;;WAGG;QACH,UAAU,CAAC,QAAgB;YAC1B,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACzD,CAAC;QAED;;WAEG;QACH,UAAU,CAAC,KAAa;YACvB,IAAI,KAAK,GAAG,CAAC,EAAE;gBACd,OAAO,CAAC,CAAC,CAAC;aACV;YAED,IAAI,QAAQ,GAAG,CAAC,CAAC;YACjB,IAAI,KAAK,GAAG,CAAC,CAAC;YAEd,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;gBAC9B,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;gBACvD,MAAM,QAAQ,GAAG,KAAK,GAAG,UAAU,CAAC;gBAEpC,IAAI,KAAK,GAAG,QAAQ,EAAE;oBACrB,OAAO,QAAQ,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;iBACjD;gBAED,QAAQ,IAAI,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC;gBACpC,KAAK,GAAG,QAAQ,CAAC;aACjB;YAED,OAAO,CAAC,CAAC,CAAC;QACX,CAAC;KACD;IAnGD,4BAmGC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange, Range } from 'vs/base/common/range';\n\nexport interface IItem {\n\tsize: number;\n}\n\nexport interface IRangedGroup {\n\trange: IRange;\n\tsize: number;\n}\n\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range: IRange, groups: IRangedGroup[]): IRangedGroup[] {\n\tconst result: IRangedGroup[] = [];\n\n\tfor (let r of groups) {\n\t\tif (range.start >= r.range.end) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (range.end < r.range.start) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst intersection = Range.intersect(range, r.range);\n\n\t\tif (Range.isEmpty(intersection)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push({\n\t\t\trange: intersection,\n\t\t\tsize: r.size\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Shifts a range by that `much`.\n */\nexport function shift({ start, end }: IRange, much: number): IRange {\n\treturn { start: start + much, end: end + much };\n}\n\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups: IRangedGroup[]): IRangedGroup[] {\n\tconst result: IRangedGroup[] = [];\n\tlet previousGroup: IRangedGroup | null = null;\n\n\tfor (let group of groups) {\n\t\tconst start = group.range.start;\n\t\tconst end = group.range.end;\n\t\tconst size = group.size;\n\n\t\tif (previousGroup && size === previousGroup.size) {\n\t\t\tpreviousGroup.range.end = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpreviousGroup = { range: { start, end }, size };\n\t\tresult.push(previousGroup);\n\t}\n\n\treturn result;\n}\n\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat(...groups: IRangedGroup[][]): IRangedGroup[] {\n\treturn consolidate(groups.reduce((r, g) => r.concat(g), []));\n}\n\nexport class RangeMap {\n\n\tprivate groups: IRangedGroup[] = [];\n\tprivate _size = 0;\n\n\tsplice(index: number, deleteCount: number, items: IItem[] = []): void {\n\t\tconst diff = items.length - deleteCount;\n\t\tconst before = groupIntersect({ start: 0, end: index }, this.groups);\n\t\tconst after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n\t\t\t.map<IRangedGroup>(g => ({ range: shift(g.range, diff), size: g.size }));\n\n\t\tconst middle = items.map<IRangedGroup>((item, i) => ({\n\t\t\trange: { start: index + i, end: index + i + 1 },\n\t\t\tsize: item.size\n\t\t}));\n\n\t\tthis.groups = concat(before, middle, after);\n\t\tthis._size = this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\n\t}\n\n\t/**\n\t * Returns the number of items in the range map.\n\t */\n\tget count(): number {\n\t\tconst len = this.groups.length;\n\n\t\tif (!len) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.groups[len - 1].range.end;\n\t}\n\n\t/**\n\t * Returns the sum of the sizes of all items in the range map.\n\t */\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Returns the index of the item at the given position.\n\t */\n\tindexAt(position: number): number {\n\t\tif (position < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet index = 0;\n\t\tlet size = 0;\n\n\t\tfor (let group of this.groups) {\n\t\t\tconst count = group.range.end - group.range.start;\n\t\t\tconst newSize = size + (count * group.size);\n\n\t\t\tif (position < newSize) {\n\t\t\t\treturn index + Math.floor((position - size) / group.size);\n\t\t\t}\n\n\t\t\tindex += count;\n\t\t\tsize = newSize;\n\t\t}\n\n\t\treturn index;\n\t}\n\n\t/**\n\t * Returns the index of the item right after the item at the\n\t * index of the given position.\n\t */\n\tindexAfter(position: number): number {\n\t\treturn Math.min(this.indexAt(position) + 1, this.count);\n\t}\n\n\t/**\n\t * Returns the start position of the item at the given index.\n\t */\n\tpositionAt(index: number): number {\n\t\tif (index < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet position = 0;\n\t\tlet count = 0;\n\n\t\tfor (let group of this.groups) {\n\t\t\tconst groupCount = group.range.end - group.range.start;\n\t\t\tconst newCount = count + groupCount;\n\n\t\t\tif (index < newCount) {\n\t\t\t\treturn position + ((index - count) * group.size);\n\t\t\t}\n\n\t\t\tposition += groupCount * group.size;\n\t\t\tcount = newCount;\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n"]}