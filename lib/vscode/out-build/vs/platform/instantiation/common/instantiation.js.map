{"version":3,"file":"instantiation.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/instantiation/common/instantiation.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAKhG,uBAAuB;IAEvB,IAAiB,KAAK,CAUrB;IAVD,WAAiB,KAAK;QAER,gBAAU,GAAG,IAAI,GAAG,EAAkC,CAAC;QAEvD,eAAS,GAAG,YAAY,CAAC;QACzB,qBAAe,GAAG,kBAAkB,CAAC;QAElD,SAAgB,sBAAsB,CAAC,IAAS;YAC/C,OAAO,IAAI,CAAC,MAAA,eAAe,CAAC,IAAI,EAAE,CAAC;QACpC,CAAC;QAFe,4BAAsB,yBAErC,CAAA;IACF,CAAC,EAVgB,KAAK,GAAL,aAAK,KAAL,aAAK,QAUrB;IA+CY,QAAA,qBAAqB,GAAG,eAAe,CAAwB,sBAAsB,CAAC,CAAC;IA2DpG,SAAS,sBAAsB,CAAC,EAAY,EAAE,MAAgB,EAAE,KAAa,EAAE,QAAiB;QAC/F,IAAK,MAAc,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,MAAM,EAAE;YAC/C,MAAc,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC;SACrE;aAAM;YACL,MAAc,CAAC,KAAK,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC;YAClE,MAAc,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC;SAC1C;IACF,CAAC;IAED;;OAEG;IACH,SAAgB,eAAe,CAAI,SAAiB;QAEnD,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YACpC,OAAO,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAE,CAAC;SACxC;QAED,MAAM,EAAE,GAAQ,UAAU,MAAgB,EAAE,GAAW,EAAE,KAAa;YACrE,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC3B,MAAM,IAAI,KAAK,CAAC,kEAAkE,CAAC,CAAC;aACpF;YACD,sBAAsB,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;QAClD,CAAC,CAAC;QAEF,EAAE,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC,SAAS,CAAC;QAE9B,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;QACpC,OAAO,EAAE,CAAC;IACX,CAAC;IAjBD,0CAiBC;IAED,SAAgB,sBAAsB,CAAmB,iBAAwC;QAChG,OAA6B,iBAAiB,CAAC;IAChD,CAAC;IAFD,wDAEC;IAED;;OAEG;IACH,SAAgB,QAAQ,CAAI,iBAAuC;QAElE,OAAO,UAAU,MAAgB,EAAE,GAAW,EAAE,KAAa;YAC5D,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC3B,MAAM,IAAI,KAAK,CAAC,8DAA8D,CAAC,CAAC;aAChF;YACD,sBAAsB,CAAC,iBAAiB,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;QAChE,CAAC,CAAC;IACH,CAAC;IARD,4BAQC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ServiceCollection } from './serviceCollection';\nimport * as descriptors from './descriptors';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>, index: number, optional: boolean }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature0<T> {\n\tnew(...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature1<A1, T> {\n\tnew <Services extends BrandedService[]>(first: A1, ...services: Services): T;\n}\n\nexport interface IConstructorSignature2<A1, A2, T> {\n\tnew(first: A1, second: A2, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature3<A1, A2, A3, T> {\n\tnew(first: A1, second: A2, third: A3, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature4<A1, A2, A3, A4, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature5<A1, A2, A3, A4, A5, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature6<A1, A2, A3, A4, A5, A6, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, ...services: BrandedService[]): T;\n}\n\nexport interface IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8, ...services: BrandedService[]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n\tget<T>(id: ServiceIdentifier<T>, isOptional: typeof optional): T | undefined;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\ntype GetLeadingNonServiceArgs<Args> =\n\tArgs extends [...BrandedService[]] ? []\n\t: Args extends [infer A1, ...BrandedService[]] ? [A1]\n\t: Args extends [infer A1, infer A2, ...BrandedService[]] ? [A1, A2]\n\t: Args extends [infer A1, infer A2, infer A3, ...BrandedService[]] ? [A1, A2, A3]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, ...BrandedService[]] ? [A1, A2, A3, A4]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, infer A5, ...BrandedService[]] ? [A1, A2, A3, A4, A5]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, ...BrandedService[]] ? [A1, A2, A3, A4, A5, A6]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, infer A7, ...BrandedService[]] ? [A1, A2, A3, A4, A5, A6, A7]\n\t: Args extends [infer A1, infer A2, infer A3, infer A4, infer A5, infer A6, infer A7, infer A8, ...BrandedService[]] ? [A1, A2, A3, A4, A5, A6, A7, A8]\n\t: never;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by\n\t * the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<A1, T>(descriptor: descriptors.SyncDescriptor1<A1, T>, a1: A1): T;\n\tcreateInstance<A1, A2, T>(descriptor: descriptors.SyncDescriptor2<A1, A2, T>, a1: A1, a2: A2): T;\n\tcreateInstance<A1, A2, A3, T>(descriptor: descriptors.SyncDescriptor3<A1, A2, A3, T>, a1: A1, a2: A2, a3: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(descriptor: descriptors.SyncDescriptor4<A1, A2, A3, A4, T>, a1: A1, a2: A2, a3: A3, a4: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(descriptor: descriptors.SyncDescriptor5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(descriptor: descriptors.SyncDescriptor6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(descriptor: descriptors.SyncDescriptor7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(descriptor: descriptors.SyncDescriptor8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): T;\n\n\tcreateInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(t: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t *\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherts all current services\n\t * and adds/overwrites the given services\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type T\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number, optional: boolean): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index, optional });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index, optional }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index, false);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\nexport function refineServiceDecorator<T1, T extends T1>(serviceIdentifier: ServiceIdentifier<T1>): ServiceIdentifier<T> {\n\treturn <ServiceIdentifier<T>>serviceIdentifier;\n}\n\n/**\n * Mark a service dependency as optional.\n */\nexport function optional<T>(serviceIdentifier: ServiceIdentifier<T>) {\n\n\treturn function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@optional-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(serviceIdentifier, target, index, true);\n\t};\n}\n"]}