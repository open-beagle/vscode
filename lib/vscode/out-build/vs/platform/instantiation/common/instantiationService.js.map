{"version":3,"file":"instantiationService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/instantiation/common/instantiationService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { illegalState } from 'vs/base/common/errors';\nimport { Graph } from 'vs/platform/instantiation/common/graph';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { ServiceIdentifier, IInstantiationService, ServicesAccessor, _util, optional } from 'vs/platform/instantiation/common/instantiation';\nimport { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';\nimport { IdleValue } from 'vs/base/common/async';\n\n// TRACING\nconst _enableTracing = false;\n\nclass CyclicDependencyError extends Error {\n\tconstructor(graph: Graph<any>) {\n\t\tsuper('cyclic dependency between services');\n\t\tthis.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n\t}\n}\n\nexport class InstantiationService implements IInstantiationService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly _services: ServiceCollection;\n\tprivate readonly _strict: boolean;\n\tprivate readonly _parent?: InstantiationService;\n\n\tconstructor(services: ServiceCollection = new ServiceCollection(), strict: boolean = false, parent?: InstantiationService) {\n\t\tthis._services = services;\n\t\tthis._strict = strict;\n\t\tthis._parent = parent;\n\n\t\tthis._services.set(IInstantiationService, this);\n\t}\n\n\tcreateChild(services: ServiceCollection): IInstantiationService {\n\t\treturn new InstantiationService(services, this._strict, this);\n\t}\n\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R {\n\t\tlet _trace = Trace.traceInvocation(fn);\n\t\tlet _done = false;\n\t\ttry {\n\t\t\tconst accessor: ServicesAccessor = {\n\t\t\t\tget: <T>(id: ServiceIdentifier<T>, isOptional?: typeof optional) => {\n\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\tif (!result && isOptional !== optional) {\n\t\t\t\t\t\tthrow new Error(`[invokeFunction] unknown service '${id}'`);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn fn(accessor, ...args);\n\t\t} finally {\n\t\t\t_done = true;\n\t\t\t_trace.stop();\n\t\t}\n\t}\n\n\tcreateInstance(ctorOrDescriptor: any | SyncDescriptor<any>, ...rest: any[]): any {\n\t\tlet _trace: Trace;\n\t\tlet result: any;\n\t\tif (ctorOrDescriptor instanceof SyncDescriptor) {\n\t\t\t_trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n\t\t} else {\n\t\t\t_trace = Trace.traceCreation(ctorOrDescriptor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor, rest, _trace);\n\t\t}\n\t\t_trace.stop();\n\t\treturn result;\n\t}\n\n\tprivate _createInstance<T>(ctor: any, args: any[] = [], _trace: Trace): T {\n\n\t\t// arguments defined by service decorators\n\t\tlet serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\t\tlet serviceArgs: any[] = [];\n\t\tfor (const dependency of serviceDependencies) {\n\t\t\tlet service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\t\t\tif (!service && this._strict && !dependency.optional) {\n\t\t\t\tthrow new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\n\t\t\t}\n\t\t\tserviceArgs.push(service);\n\t\t}\n\n\t\tlet firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n\n\t\t// check for argument mismatches, adjust static args if needed\n\t\tif (args.length !== firstServiceArgPos) {\n\t\t\tconsole.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n\n\t\t\tlet delta = firstServiceArgPos - args.length;\n\t\t\tif (delta > 0) {\n\t\t\t\targs = args.concat(new Array(delta));\n\t\t\t} else {\n\t\t\t\targs = args.slice(0, firstServiceArgPos);\n\t\t\t}\n\t\t}\n\n\t\t// now create the instance\n\t\treturn <T>new ctor(...[...args, ...serviceArgs]);\n\t}\n\n\tprivate _setServiceInstance<T>(id: ServiceIdentifier<T>, instance: T): void {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\tthis._services.set(id, instance);\n\t\t} else if (this._parent) {\n\t\t\tthis._parent._setServiceInstance(id, instance);\n\t\t} else {\n\t\t\tthrow new Error('illegalState - setting UNKNOWN service instance');\n\t\t}\n\t}\n\n\tprivate _getServiceInstanceOrDescriptor<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T> {\n\t\tlet instanceOrDesc = this._services.get(id);\n\t\tif (!instanceOrDesc && this._parent) {\n\t\t\treturn this._parent._getServiceInstanceOrDescriptor(id);\n\t\t} else {\n\t\t\treturn instanceOrDesc;\n\t\t}\n\t}\n\n\tprivate _getOrCreateServiceInstance<T>(id: ServiceIdentifier<T>, _trace: Trace): T {\n\t\tlet thing = this._getServiceInstanceOrDescriptor(id);\n\t\tif (thing instanceof SyncDescriptor) {\n\t\t\treturn this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n\t\t} else {\n\t\t\t_trace.branch(id, false);\n\t\t\treturn thing;\n\t\t}\n\t}\n\n\tprivate readonly _activeInstantiations = new Set<ServiceIdentifier<any>>();\n\n\n\tprivate _safeCreateAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\t\tif (this._activeInstantiations.has(id)) {\n\t\t\tthrow new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n\t\t}\n\t\tthis._activeInstantiations.add(id);\n\t\ttry {\n\t\t\treturn this._createAndCacheServiceInstance(id, desc, _trace);\n\t\t} finally {\n\t\t\tthis._activeInstantiations.delete(id);\n\t\t}\n\t}\n\n\tprivate _createAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\n\t\ttype Triple = { id: ServiceIdentifier<any>, desc: SyncDescriptor<any>, _trace: Trace; };\n\t\tconst graph = new Graph<Triple>(data => data.id.toString());\n\n\t\tlet cycleCount = 0;\n\t\tconst stack = [{ id, desc, _trace }];\n\t\twhile (stack.length) {\n\t\t\tconst item = stack.pop()!;\n\t\t\tgraph.lookupOrInsertNode(item);\n\n\t\t\t// a weak but working heuristic for cycle checks\n\t\t\tif (cycleCount++ > 1000) {\n\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t}\n\n\t\t\t// check all dependencies for existence and if they need to be created first\n\t\t\tfor (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\n\n\t\t\t\tlet instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\t\t\t\tif (!instanceOrDesc && !dependency.optional) {\n\t\t\t\t\tconsole.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\n\t\t\t\t}\n\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\tconst d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n\t\t\t\t\tgraph.insertEdge(item, d);\n\t\t\t\t\tstack.push(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst roots = graph.roots();\n\n\t\t\t// if there is no more roots but still\n\t\t\t// nodes in the graph we have a cycle\n\t\t\tif (roots.length === 0) {\n\t\t\t\tif (!graph.isEmpty()) {\n\t\t\t\t\tthrow new CyclicDependencyError(graph);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (const { data } of roots) {\n\t\t\t\t// Repeat the check for this still being a service sync descriptor. That's because\n\t\t\t\t// instantiating a dependency might have side-effect and recursively trigger instantiation\n\t\t\t\t// so that some dependencies are now fullfilled already.\n\t\t\t\tconst instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\t// create instance and overwrite the service collections\n\t\t\t\t\tconst instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\t\t\t\t\tthis._setServiceInstance(data.id, instance);\n\t\t\t\t}\n\t\t\t\tgraph.removeNode(data);\n\t\t\t}\n\t\t}\n\t\treturn <T>this._getServiceInstanceOrDescriptor(id);\n\t}\n\n\tprivate _createServiceInstanceWithOwner<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\treturn this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else if (this._parent) {\n\t\t\treturn this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else {\n\t\t\tthrow new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n\t\t}\n\t}\n\n\tprivate _createServiceInstance<T>(ctor: any, args: any[] = [], _supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (!_supportsDelayedInstantiation) {\n\t\t\t// eager instantiation\n\t\t\treturn this._createInstance(ctor, args, _trace);\n\n\t\t} else {\n\t\t\t// Return a proxy object that's backed by an idle value. That\n\t\t\t// strategy is to instantiate services in our idle time or when actually\n\t\t\t// needed but not when injected into a consumer\n\t\t\tconst idle = new IdleValue<any>(() => this._createInstance<T>(ctor, args, _trace));\n\t\t\treturn <T>new Proxy(Object.create(null), {\n\t\t\t\tget(target: any, key: PropertyKey): any {\n\t\t\t\t\tif (key in target) {\n\t\t\t\t\t\treturn target[key];\n\t\t\t\t\t}\n\t\t\t\t\tlet obj = idle.value;\n\t\t\t\t\tlet prop = obj[key];\n\t\t\t\t\tif (typeof prop !== 'function') {\n\t\t\t\t\t\treturn prop;\n\t\t\t\t\t}\n\t\t\t\t\tprop = prop.bind(obj);\n\t\t\t\t\ttarget[key] = prop;\n\t\t\t\t\treturn prop;\n\t\t\t\t},\n\t\t\t\tset(_target: T, p: PropertyKey, value: any): boolean {\n\t\t\t\t\tidle.value[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n//#region -- tracing ---\n\nconst enum TraceType {\n\tCreation, Invocation, Branch\n}\n\nclass Trace {\n\n\tprivate static readonly _None = new class extends Trace {\n\t\tconstructor() { super(-1, null); }\n\t\toverride stop() { }\n\t\toverride branch() { return this; }\n\t};\n\n\tstatic traceInvocation(ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || (ctor.toString() as string).substring(0, 42).replace(/\\n/g, ''));\n\t}\n\n\tstatic traceCreation(ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n\t}\n\n\tprivate static _totals: number = 0;\n\tprivate readonly _start: number = Date.now();\n\tprivate readonly _dep: [ServiceIdentifier<any>, boolean, Trace?][] = [];\n\n\tprivate constructor(\n\t\treadonly type: TraceType,\n\t\treadonly name: string | null\n\t) { }\n\n\tbranch(id: ServiceIdentifier<any>, first: boolean): Trace {\n\t\tlet child = new Trace(TraceType.Branch, id.toString());\n\t\tthis._dep.push([id, first, child]);\n\t\treturn child;\n\t}\n\n\tstop() {\n\t\tlet dur = Date.now() - this._start;\n\t\tTrace._totals += dur;\n\n\t\tlet causedCreation = false;\n\n\t\tfunction printChild(n: number, trace: Trace) {\n\t\t\tlet res: string[] = [];\n\t\t\tlet prefix = new Array(n + 1).join('\\t');\n\t\t\tfor (const [id, first, child] of trace._dep) {\n\t\t\t\tif (first && child) {\n\t\t\t\t\tcausedCreation = true;\n\t\t\t\t\tres.push(`${prefix}CREATES -> ${id}`);\n\t\t\t\t\tlet nested = printChild(n + 1, child);\n\t\t\t\t\tif (nested) {\n\t\t\t\t\t\tres.push(nested);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres.push(`${prefix}uses -> ${id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.join('\\n');\n\t\t}\n\n\t\tlet lines = [\n\t\t\t`${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,\n\t\t\t`${printChild(1, this)}`,\n\t\t\t`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n\t\t];\n\n\t\tif (dur > 2 || causedCreation) {\n\t\t\tconsole.log(lines.join('\\n'));\n\t\t}\n\t}\n}\n\n//#endregion\n"]}