{"version":3,"file":"extensionUrlTrustService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/extensionManagement/node/extensionUrlTrustService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as crypto from 'crypto';\nimport { IExtensionUrlTrustService } from 'vs/platform/extensionManagement/common/extensionUrlTrust';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IProductService } from 'vs/platform/product/common/productService';\n\nexport class ExtensionUrlTrustService implements IExtensionUrlTrustService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate trustedExtensionUrlPublicKeys = new Map<string, (crypto.KeyObject | string | null)[]>();\n\n\tconstructor(\n\t\t@IProductService private readonly productService: IProductService,\n\t\t@ILogService private readonly logService: ILogService\n\t) { }\n\n\tasync isExtensionUrlTrusted(extensionId: string, url: string): Promise<boolean> {\n\t\tif (!this.productService.trustedExtensionUrlPublicKeys) {\n\t\t\tthis.logService.trace('ExtensionUrlTrustService#isExtensionUrlTrusted', 'There are no configured trusted keys');\n\t\t\treturn false;\n\t\t}\n\n\t\tconst match = /^(.*)#([^#]+)$/.exec(url);\n\n\t\tif (!match) {\n\t\t\tthis.logService.trace('ExtensionUrlTrustService#isExtensionUrlTrusted', 'Uri has no fragment', url);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst [, originalUrl, fragment] = match;\n\n\t\tlet keys = this.trustedExtensionUrlPublicKeys.get(extensionId);\n\n\t\tif (!keys) {\n\t\t\tkeys = this.productService.trustedExtensionUrlPublicKeys[extensionId];\n\n\t\t\tif (!keys || keys.length === 0) {\n\t\t\t\tthis.logService.trace('ExtensionUrlTrustService#isExtensionUrlTrusted', 'Extension doesn\\'t have any trusted keys', extensionId);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.trustedExtensionUrlPublicKeys.set(extensionId, [...keys]);\n\t\t}\n\n\t\tconst fragmentBuffer = Buffer.from(decodeURIComponent(fragment), 'base64');\n\n\t\tif (fragmentBuffer.length <= 6) {\n\t\t\tthis.logService.trace('ExtensionUrlTrustService#isExtensionUrlTrusted', 'Uri fragment is not a signature', url);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst timestampBuffer = fragmentBuffer.slice(0, 6);\n\t\tconst timestamp = fragmentBuffer.readUIntBE(0, 6);\n\t\tconst diff = Date.now() - timestamp;\n\n\t\tif (diff < 0 || diff > 3_600_000) { // 1 hour\n\t\t\tthis.logService.trace('ExtensionUrlTrustService#isExtensionUrlTrusted', 'Signed uri has expired', url);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst signatureBuffer = fragmentBuffer.slice(6);\n\t\tconst verify = crypto.createVerify('SHA256');\n\t\tverify.write(timestampBuffer);\n\t\tverify.write(Buffer.from(originalUrl));\n\t\tverify.end();\n\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tlet key = keys[i];\n\n\t\t\tif (key === null) { // failed to be parsed before\n\t\t\t\tcontinue;\n\t\t\t} else if (typeof key === 'string') { // needs to be parsed\n\t\t\t\ttry {\n\t\t\t\t\tkey = crypto.createPublicKey({ key: Buffer.from(key, 'base64'), format: 'der', type: 'spki' });\n\t\t\t\t\tkeys[i] = key;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.logService.warn('ExtensionUrlTrustService#isExtensionUrlTrusted', `Failed to parse trusted extension uri public key #${i + 1} for ${extensionId}:`, err);\n\t\t\t\t\tkeys[i] = null;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (verify.verify(key, signatureBuffer)) {\n\t\t\t\tthis.logService.trace('ExtensionUrlTrustService#isExtensionUrlTrusted', 'Signed uri is valid', url);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tthis.logService.trace('ExtensionUrlTrustService#isExtensionUrlTrusted', 'Signed uri could not be verified', url);\n\t\treturn false;\n\t}\n}\n"]}