{"version":3,"file":"opener.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/opener/common/opener.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IASnF,QAAA,cAAc,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAiB,eAAe,CAAC,CAAC;IAuGlE,QAAA,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC;QAC9C,aAAa,EAAE,SAAS;QACxB,cAAc,KAAK,OAAO,sBAAU,CAAC,IAAI,CAAC,CAAC,CAAC;QAC5C,iBAAiB,KAAK,OAAO,sBAAU,CAAC,IAAI,CAAC,CAAC,CAAC;QAC/C,2BAA2B,KAAK,OAAO,sBAAU,CAAC,IAAI,CAAC,CAAC,CAAC;QACzD,wBAAwB,KAAK,CAAC;QAC9B,sBAAsB,KAAK,OAAO,sBAAU,CAAC,IAAI,CAAC,CAAC,CAAC;QACpD,KAAK,CAAC,IAAI,KAAK,OAAO,KAAK,CAAC,CAAC,CAAC;QAC9B,KAAK,CAAC,kBAAkB,CAAC,GAAQ,IAAI,OAAO,EAAE,QAAQ,EAAE,GAAG,EAAE,OAAO,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;KAC7D,CAAC,CAAC;IAErB,SAAgB,aAAa,CAAC,MAAoB,EAAE,MAAc;QACjE,IAAI,SAAG,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;YACtB,OAAO,CAAA,GAAA,0BAAgB,CAAA,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;SAC/C;aAAM;YACN,OAAO,CAAA,GAAA,8BAAoB,CAAA,CAAC,MAAM,EAAE,MAAM,GAAG,GAAG,CAAC,CAAC;SAClD;IACF,CAAC;IAND,sCAMC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\nimport { IEditorOptions } from 'vs/platform/editor/common/editor';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nexport const IOpenerService = createDecorator<IOpenerService>('openerService');\n\nexport type OpenInternalOptions = {\n\n\t/**\n\t * Signals that the intent is to open an editor to the side\n\t * of the currently active editor.\n\t */\n\treadonly openToSide?: boolean;\n\n\t/**\n\t * Extra editor options to apply in case an editor is used to open.\n\t */\n\treadonly editorOptions?: IEditorOptions;\n\n\t/**\n\t * Signals that the editor to open was triggered through a user\n\t * action, such as keyboard or mouse usage.\n\t */\n\treadonly fromUserGesture?: boolean;\n\n\t/**\n\t * Allow command links to be handled.\n\t */\n\treadonly allowCommands?: boolean;\n};\n\nexport type OpenExternalOptions = {\n\treadonly openExternal?: boolean;\n\treadonly allowTunneling?: boolean;\n\treadonly allowContributedOpeners?: boolean | string;\n};\n\nexport type OpenOptions = OpenInternalOptions & OpenExternalOptions;\n\nexport type ResolveExternalUriOptions = { readonly allowTunneling?: boolean };\n\nexport interface IResolvedExternalUri extends IDisposable {\n\tresolved: URI;\n}\n\nexport interface IOpener {\n\topen(resource: URI | string, options?: OpenInternalOptions | OpenExternalOptions): Promise<boolean>;\n}\n\nexport interface IExternalOpener {\n\topenExternal(href: string, ctx: { sourceUri: URI, preferredOpenerId?: string }, token: CancellationToken): Promise<boolean>;\n\tdispose?(): void;\n}\n\nexport interface IValidator {\n\tshouldOpen(resource: URI | string): Promise<boolean>;\n}\n\nexport interface IExternalUriResolver {\n\tresolveExternalUri(resource: URI, options?: OpenOptions): Promise<{ resolved: URI, dispose(): void } | undefined>;\n}\n\nexport interface IOpenerService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Register a participant that can handle the open() call.\n\t */\n\tregisterOpener(opener: IOpener): IDisposable;\n\n\t/**\n\t * Register a participant that can validate if the URI resource be opened.\n\t * Validators are run before openers.\n\t */\n\tregisterValidator(validator: IValidator): IDisposable;\n\n\t/**\n\t * Register a participant that can resolve an external URI resource to be opened.\n\t */\n\tregisterExternalUriResolver(resolver: IExternalUriResolver): IDisposable;\n\n\t/**\n\t * Sets the handler for opening externally. If not provided,\n\t * a default handler will be used.\n\t */\n\tsetDefaultExternalOpener(opener: IExternalOpener): void;\n\n\t/**\n\t * Registers a new opener external resources openers.\n\t */\n\tregisterExternalOpener(opener: IExternalOpener): IDisposable;\n\n\t/**\n\t * Opens a resource, like a webaddress, a document uri, or executes command.\n\t *\n\t * @param resource A resource\n\t * @return A promise that resolves when the opening is done.\n\t */\n\topen(resource: URI | string, options?: OpenInternalOptions | OpenExternalOptions): Promise<boolean>;\n\n\t/**\n\t * Resolve a resource to its external form.\n\t */\n\tresolveExternalUri(resource: URI, options?: ResolveExternalUriOptions): Promise<IResolvedExternalUri>;\n}\n\nexport const NullOpenerService = Object.freeze({\n\t_serviceBrand: undefined,\n\tregisterOpener() { return Disposable.None; },\n\tregisterValidator() { return Disposable.None; },\n\tregisterExternalUriResolver() { return Disposable.None; },\n\tsetDefaultExternalOpener() { },\n\tregisterExternalOpener() { return Disposable.None; },\n\tasync open() { return false; },\n\tasync resolveExternalUri(uri: URI) { return { resolved: uri, dispose() { } }; },\n} as IOpenerService);\n\nexport function matchesScheme(target: URI | string, scheme: string) {\n\tif (URI.isUri(target)) {\n\t\treturn equalsIgnoreCase(target.scheme, scheme);\n\t} else {\n\t\treturn startsWithIgnoreCase(target, scheme + ':');\n\t}\n}\n"]}