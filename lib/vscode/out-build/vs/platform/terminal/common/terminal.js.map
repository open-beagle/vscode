{"version":3,"file":"terminal.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/terminal/common/terminal.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAQhG,IAAY,gBAKX;IALD,WAAY,gBAAgB;QAC3B,yCAAqB,CAAA;QACrB,uCAAmB,CAAA;QACnB,+BAAW,CAAA;QACX,uCAAmB,CAAA;IACpB,CAAC,EALW,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAK3B;IAyCD,IAAY,mBAiBX;IAjBD,WAAY,mBAAmB;QAC9B;;WAEG;QACH,4CAAqB,CAAA;QACrB;;WAEG;QACH,0CAAmB,CAAA;QACnB;;WAEG;QACH,kCAAW,CAAA;QACX;;WAEG;QACH,8CAAuB,CAAA;IACxB,CAAC,EAjBW,mBAAmB,GAAnB,2BAAmB,KAAnB,2BAAmB,QAiB9B;IA8BY,QAAA,qBAAqB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAwB,sBAAsB,CAAC,CAAC;IAKvF,QAAA,WAAW,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAc,YAAY,CAAC,CAAC;IA4DtE,IAAY,kBAsBX;IAtBD,WAAY,kBAAkB;QAC7B;;WAEG;QACH,8EAAmB,CAAA;QACnB;;;WAGG;QACH,2FAAyB,CAAA;QACzB;;;;WAIG;QACH,2FAAwB,CAAA;QACxB;;;;WAIG;QACH,8FAA2B,CAAA;IAC5B,CAAC,EAtBW,kBAAkB,GAAlB,0BAAkB,KAAlB,0BAAkB,QAsB7B;IA6LD,IAAkB,uBASjB;IATD,WAAkB,uBAAuB;QACxC;;UAEE;QACF,2GAA6B,CAAA;QAC7B;;UAEE;QACF,oHAAiC,CAAA;IAClC,CAAC,EATiB,uBAAuB,GAAvB,+BAAuB,KAAvB,+BAAuB,QASxC;IAED,IAAkB,oBAqBjB;IArBD,WAAkB,oBAAoB;QACrC;;;WAGG;QACH,gGAA2B,CAAA;QAC3B;;;;;;;;WAQG;QACH,4FAAwB,CAAA;QACxB;;;WAGG;QACH,0FAAuB,CAAA;IACxB,CAAC,EArBiB,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAqBrC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { Event } from 'vs/base/common/event';\nimport { IProcessEnvironment, OperatingSystem } from 'vs/base/common/platform';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { IGetTerminalLayoutInfoArgs, IProcessDetails, IPtyHostProcessReplayEvent, ISetTerminalLayoutInfoArgs } from 'vs/platform/terminal/common/terminalProcess';\n\nexport enum WindowsShellType {\n\tCommandPrompt = 'cmd',\n\tPowerShell = 'pwsh',\n\tWsl = 'wsl',\n\tGitBash = 'gitbash'\n}\nexport type TerminalShellType = WindowsShellType | undefined;\nexport interface IRawTerminalInstanceLayoutInfo<T> {\n\trelativeSize: number;\n\tterminal: T;\n}\nexport type ITerminalInstanceLayoutInfoById = IRawTerminalInstanceLayoutInfo<number>;\nexport type ITerminalInstanceLayoutInfo = IRawTerminalInstanceLayoutInfo<IPtyHostAttachTarget>;\n\nexport interface IRawTerminalTabLayoutInfo<T> {\n\tisActive: boolean;\n\tactivePersistentProcessId: number | undefined;\n\tterminals: IRawTerminalInstanceLayoutInfo<T>[];\n}\n\nexport type ITerminalTabLayoutInfoById = IRawTerminalTabLayoutInfo<number>;\nexport type ITerminalTabLayoutInfo = IRawTerminalTabLayoutInfo<IPtyHostAttachTarget | null>;\n\nexport interface IRawTerminalsLayoutInfo<T> {\n\ttabs: IRawTerminalTabLayoutInfo<T>[];\n}\n\nexport interface IPtyHostAttachTarget {\n\tid: number;\n\tpid: number;\n\ttitle: string;\n\tcwd: string;\n\tworkspaceId: string;\n\tworkspaceName: string;\n\tisOrphan: boolean;\n\ticon: string | undefined;\n}\n\nexport type ITerminalsLayoutInfo = IRawTerminalsLayoutInfo<IPtyHostAttachTarget | null>;\nexport type ITerminalsLayoutInfoById = IRawTerminalsLayoutInfo<number>;\n\nexport interface IRawTerminalInstanceLayoutInfo<T> {\n\trelativeSize: number;\n\tterminal: T;\n}\n\nexport enum TerminalIpcChannels {\n\t/**\n\t * Communicates between the renderer process and shared process.\n\t */\n\tLocalPty = 'localPty',\n\t/**\n\t * Communicates between the shared process and the pty host process.\n\t */\n\tPtyHost = 'ptyHost',\n\t/**\n\t * Deals with logging from the pty host process.\n\t */\n\tLog = 'log',\n\t/**\n\t * Enables the detection of unresponsive pty hosts.\n\t */\n\tHeartbeat = 'heartbeat'\n}\n\nexport interface IOffProcessTerminalService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Fired when the ptyHost process becomes non-responsive, this should disable stdin for all\n\t * terminals using this pty host connection and mark them as disconnected.\n\t */\n\tonPtyHostUnresponsive: Event<void>;\n\t/**\n\t * Fired when the ptyHost process becomes responsive after being non-responsive. Allowing\n\t * previously disconnected terminals to reconnect.\n\t */\n\tonPtyHostResponsive: Event<void>;\n\t/**\n\t * Fired when the ptyHost has been restarted, this is used as a signal for listening terminals\n\t * that its pty has been lost and will remain disconnected.\n\t */\n\tonPtyHostRestart: Event<void>;\n\n\tattachToProcess(id: number): Promise<ITerminalChildProcess | undefined>;\n\tlistProcesses(): Promise<IProcessDetails[]>;\n\tgetDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;\n\tgetShellEnvironment(): Promise<IProcessEnvironment>;\n\tsetTerminalLayoutInfo(layoutInfo?: ITerminalsLayoutInfoById): Promise<void>;\n\tgetTerminalLayoutInfo(): Promise<ITerminalsLayoutInfo | undefined>;\n\treduceConnectionGraceTime(): Promise<void>;\n}\n\nexport const ILocalTerminalService = createDecorator<ILocalTerminalService>('localTerminalService');\nexport interface ILocalTerminalService extends IOffProcessTerminalService {\n\tcreateProcess(shellLaunchConfig: IShellLaunchConfig, cwd: string, cols: number, rows: number, env: IProcessEnvironment, windowsEnableConpty: boolean, shouldPersist: boolean): Promise<ITerminalChildProcess>;\n}\n\nexport const IPtyService = createDecorator<IPtyService>('ptyService');\nexport interface IPtyService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly onPtyHostExit?: Event<number>;\n\treadonly onPtyHostStart?: Event<void>;\n\treadonly onPtyHostUnresponsive?: Event<void>;\n\treadonly onPtyHostResponsive?: Event<void>;\n\treadonly onProcessData: Event<{ id: number, event: IProcessDataEvent | string }>;\n\treadonly onProcessExit: Event<{ id: number, event: number | undefined }>;\n\treadonly onProcessReady: Event<{ id: number, event: { pid: number, cwd: string } }>;\n\treadonly onProcessTitleChanged: Event<{ id: number, event: string }>;\n\treadonly onProcessShellTypeChanged: Event<{ id: number, event: TerminalShellType }>;\n\treadonly onProcessOverrideDimensions: Event<{ id: number, event: ITerminalDimensionsOverride | undefined }>;\n\treadonly onProcessResolvedShellLaunchConfig: Event<{ id: number, event: IShellLaunchConfig }>;\n\treadonly onProcessReplay: Event<{ id: number, event: IPtyHostProcessReplayEvent }>;\n\treadonly onProcessOrphanQuestion: Event<{ id: number }>;\n\n\trestartPtyHost?(): Promise<void>;\n\tshutdownAll?(): Promise<void>;\n\n\tcreateProcess(\n\t\tshellLaunchConfig: IShellLaunchConfig,\n\t\tcwd: string,\n\t\tcols: number,\n\t\trows: number,\n\t\tenv: IProcessEnvironment,\n\t\texecutableEnv: IProcessEnvironment,\n\t\twindowsEnableConpty: boolean,\n\t\tshouldPersist: boolean,\n\t\tworkspaceId: string,\n\t\tworkspaceName: string\n\t): Promise<number>;\n\tattachToProcess(id: number): Promise<void>;\n\tdetachFromProcess(id: number): Promise<void>;\n\n\t/**\n\t * Lists all orphaned processes, ie. those without a connected frontend.\n\t */\n\tlistProcesses(): Promise<IProcessDetails[]>;\n\n\tstart(id: number): Promise<ITerminalLaunchError | undefined>;\n\tshutdown(id: number, immediate: boolean): Promise<void>;\n\tinput(id: number, data: string): Promise<void>;\n\tresize(id: number, cols: number, rows: number): Promise<void>;\n\tgetInitialCwd(id: number): Promise<string>;\n\tgetCwd(id: number): Promise<string>;\n\tgetLatency(id: number): Promise<number>;\n\tacknowledgeDataEvent(id: number, charCount: number): Promise<void>;\n\tprocessBinary(id: number, data: string): Promise<void>;\n\t/** Confirm the process is _not_ an orphan. */\n\torphanQuestionReply(id: number): Promise<void>;\n\n\tgetDefaultSystemShell(osOverride?: OperatingSystem): Promise<string>;\n\tgetShellEnvironment(): Promise<IProcessEnvironment>;\n\tsetTerminalLayoutInfo(args: ISetTerminalLayoutInfoArgs): Promise<void>;\n\tgetTerminalLayoutInfo(args: IGetTerminalLayoutInfoArgs): Promise<ITerminalsLayoutInfo | undefined>;\n\treduceConnectionGraceTime(): Promise<void>;\n}\n\nexport enum HeartbeatConstants {\n\t/**\n\t * The duration between heartbeats\n\t */\n\tBeatInterval = 5000,\n\t/**\n\t * Defines a multiplier for BeatInterval for how long to wait before starting the second wait\n\t * timer.\n\t */\n\tFirstWaitMultiplier = 1.2,\n\t/**\n\t * Defines a multiplier for BeatInterval for how long to wait before telling the user about\n\t * non-responsiveness. The second timer is to avoid informing the user incorrectly when waking\n\t * the computer up from sleep\n\t */\n\tSecondWaitMultiplier = 1,\n\t/**\n\t * How long to wait before telling the user about non-responsiveness when they try to create a\n\t * process. This short circuits the standard wait timeouts to tell the user sooner and only\n\t * create process is handled to avoid additional perf overhead.\n\t */\n\tCreateProcessTimeout = 5000\n}\n\nexport interface IHeartbeatService {\n\treadonly onBeat: Event<void>;\n}\n\nexport interface IShellLaunchConfig {\n\t/**\n\t * The name of the terminal, if this is not set the name of the process will be used.\n\t */\n\tname?: string;\n\n\t/**\n\t * An string to follow the name of the terminal with, indicating a special kind of terminal\n\t */\n\tdescription?: string;\n\n\t/**\n\t * The shell executable (bash, cmd, etc.).\n\t */\n\texecutable?: string;\n\n\t/**\n\t * The CLI arguments to use with executable, a string[] is in argv format and will be escaped,\n\t * a string is in \"CommandLine\" pre-escaped format and will be used as is. The string option is\n\t * only supported on Windows and will throw an exception if used on macOS or Linux.\n\t */\n\targs?: string[] | string;\n\n\t/**\n\t * The current working directory of the terminal, this overrides the `terminal.integrated.cwd`\n\t * settings key.\n\t */\n\tcwd?: string | URI;\n\n\t/**\n\t * A custom environment for the terminal, if this is not set the environment will be inherited\n\t * from the VS Code process.\n\t */\n\tenv?: ITerminalEnvironment;\n\n\t/**\n\t * Whether to ignore a custom cwd from the `terminal.integrated.cwd` settings key (e.g. if the\n\t * shell is being launched by an extension).\n\t */\n\tignoreConfigurationCwd?: boolean;\n\n\t/** Whether to wait for a key press before closing the terminal. */\n\twaitOnExit?: boolean | string;\n\n\t/**\n\t * A string including ANSI escape sequences that will be written to the terminal emulator\n\t * _before_ the terminal process has launched, a trailing \\n is added at the end of the string.\n\t * This allows for example the terminal instance to display a styled message as the first line\n\t * of the terminal. Use \\x1b over \\033 or \\e for the escape control character.\n\t */\n\tinitialText?: string;\n\n\t/**\n\t * Custom PTY/pseudoterminal process to use.\n\t */\n\tcustomPtyImplementation?: (terminalId: number, cols: number, rows: number) => ITerminalChildProcess;\n\n\t/**\n\t * A UUID generated by the extension host process for terminals created on the extension host process.\n\t */\n\textHostTerminalId?: string;\n\n\t/**\n\t * This is a terminal that attaches to an already running terminal.\n\t */\n\tattachPersistentProcess?: { id: number; pid: number; title: string; cwd: string; icon?: string; };\n\n\t/**\n\t * Whether the terminal process environment should be exactly as provided in\n\t * `TerminalOptions.env`. When this is false (default), the environment will be based on the\n\t * window's environment and also apply configured platform settings like\n\t * `terminal.integrated.windows.env` on top. When this is true, the complete environment must be\n\t * provided as nothing will be inherited from the process or any configuration.\n\t */\n\tstrictEnv?: boolean;\n\n\t/**\n\t * When enabled the terminal will run the process as normal but not be surfaced to the user\n\t * until `Terminal.show` is called. The typical usage for this is when you need to run\n\t * something that may need interactivity but only want to tell the user about it when\n\t * interaction is needed. Note that the terminals will still be exposed to all extensions\n\t * as normal.\n\t */\n\thideFromUser?: boolean;\n\n\t/**\n\t * Whether this terminal is not a terminal that the user directly created and uses, but rather\n\t * a terminal used to drive some VS Code feature.\n\t */\n\tisFeatureTerminal?: boolean;\n\n\t/**\n\t * Whether this terminal was created by an extension.\n\t */\n\tisExtensionOwnedTerminal?: boolean;\n\n\t/**\n\t * The codicon ID to use for this terminal. If not specified it will use the default fallback\n\t * icon.\n\t */\n\ticon?: string;\n}\n\nexport interface IShellLaunchConfigDto {\n\tname?: string;\n\texecutable?: string;\n\targs?: string[] | string;\n\tcwd?: string | UriComponents;\n\tenv?: ITerminalEnvironment;\n\thideFromUser?: boolean;\n}\n\nexport interface ITerminalEnvironment {\n\t[key: string]: string | null | undefined;\n}\n\nexport interface ITerminalLaunchError {\n\tmessage: string;\n\tcode?: number;\n}\n\n/**\n * An interface representing a raw terminal child process, this contains a subset of the\n * child_process.ChildProcess node.js interface.\n */\nexport interface ITerminalChildProcess {\n\t/**\n\t * A unique identifier for the terminal process. Note that the uniqueness only applies to a\n\t * given pty service connection, IDs will be duplicated for remote and local terminals for\n\t * example. The ID will be 0 if it does not support reconnection.\n\t */\n\tid: number;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\tshouldPersist: boolean;\n\n\tonProcessData: Event<IProcessDataEvent | string>;\n\tonProcessExit: Event<number | undefined>;\n\tonProcessReady: Event<{ pid: number, cwd: string }>;\n\tonProcessTitleChanged: Event<string>;\n\tonProcessOverrideDimensions?: Event<ITerminalDimensionsOverride | undefined>;\n\tonProcessResolvedShellLaunchConfig?: Event<IShellLaunchConfig>;\n\tonProcessShellTypeChanged: Event<TerminalShellType>;\n\n\t/**\n\t * Starts the process.\n\t *\n\t * @returns undefined when the process was successfully started, otherwise an object containing\n\t * information on what went wrong.\n\t */\n\tstart(): Promise<ITerminalLaunchError | undefined>;\n\n\t/**\n\t * Detach the process from the UI and await reconnect.\n\t */\n\tdetach?(): void;\n\n\t/**\n\t * Shutdown the terminal process.\n\t *\n\t * @param immediate When true the process will be killed immediately, otherwise the process will\n\t * be given some time to make sure no additional data comes through.\n\t */\n\tshutdown(immediate: boolean): void;\n\tinput(data: string): void;\n\tprocessBinary(data: string): Promise<void>;\n\tresize(cols: number, rows: number): void;\n\n\t/**\n\t * Acknowledge a data event has been parsed by the terminal, this is used to implement flow\n\t * control to ensure remote processes to not get too far ahead of the client and flood the\n\t * connection.\n\t * @param charCount The number of characters being acknowledged.\n\t */\n\tacknowledgeDataEvent(charCount: number): void;\n\n\tgetInitialCwd(): Promise<string>;\n\tgetCwd(): Promise<string>;\n\tgetLatency(): Promise<number>;\n}\n\nexport const enum LocalReconnectConstants {\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t*/\n\tReconnectionGraceTime = 60000, // 60 seconds\n\t/**\n\t * Maximal grace time between the first and the last reconnection...\n\t*/\n\tReconnectionShortGraceTime = 6000, // 6 seconds\n}\n\nexport const enum FlowControlConstants {\n\t/**\n\t * The number of _unacknowledged_ chars to have been sent before the pty is paused in order for\n\t * the client to catch up.\n\t */\n\tHighWatermarkChars = 100000,\n\t/**\n\t * After flow control pauses the pty for the client the catch up, this is the number of\n\t * _unacknowledged_ chars to have been caught up to on the client before resuming the pty again.\n\t * This is used to attempt to prevent pauses in the flowing data; ideally while the pty is\n\t * paused the number of unacknowledged chars would always be greater than 0 or the client will\n\t * appear to stutter. In reality this balance is hard to accomplish though so heavy commands\n\t * will likely pause as latency grows, not flooding the connection is the important thing as\n\t * it's shared with other core functionality.\n\t */\n\tLowWatermarkChars = 5000,\n\t/**\n\t * The number characters that are accumulated on the client side before sending an ack event.\n\t * This must be less than or equal to LowWatermarkChars or the terminal max never unpause.\n\t */\n\tCharCountAckSize = 5000\n}\n\nexport interface IProcessDataEvent {\n\tdata: string;\n\ttrackCommit: boolean;\n\t/**\n\t * When trackCommit is set, this will be set to a promise that resolves when the data is parsed.\n\t */\n\twritePromise?: Promise<void>;\n}\n\nexport interface ITerminalDimensions {\n\t/**\n\t * The columns of the terminal.\n\t */\n\tcols: number;\n\n\t/**\n\t * The rows of the terminal.\n\t */\n\trows: number;\n}\n\nexport interface ITerminalDimensionsOverride extends Readonly<ITerminalDimensions> {\n\t/**\n\t * indicate that xterm must receive these exact dimensions, even if they overflow the ui!\n\t */\n\tforceExactSize?: boolean;\n}\n\nexport type SafeConfigProvider = <T>(key: string) => T | undefined;\n"]}