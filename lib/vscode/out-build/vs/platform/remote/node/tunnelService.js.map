{"version":3,"file":"tunnelService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/remote/node/tunnelService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from 'net';\nimport { Barrier } from 'vs/base/common/async';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { findFreePortFaster } from 'vs/base/node/ports';\nimport { NodeSocket } from 'vs/base/parts/ipc/node/ipc.net';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IProductService } from 'vs/platform/product/common/productService';\nimport { connectRemoteAgentTunnel, IConnectionOptions, IAddressProvider, ISocketFactory } from 'vs/platform/remote/common/remoteAgentConnection';\nimport { AbstractTunnelService, RemoteTunnel } from 'vs/platform/remote/common/tunnel';\nimport { nodeSocketFactory } from 'vs/platform/remote/node/nodeSocketFactory';\nimport { ISignService } from 'vs/platform/sign/common/sign';\n\nasync function createRemoteTunnel(options: IConnectionOptions, tunnelRemoteHost: string, tunnelRemotePort: number, tunnelLocalPort?: number): Promise<RemoteTunnel> {\n\tconst tunnel = new NodeRemoteTunnel(options, tunnelRemoteHost, tunnelRemotePort, tunnelLocalPort);\n\treturn tunnel.waitForReady();\n}\n\nclass NodeRemoteTunnel extends Disposable implements RemoteTunnel {\n\n\tpublic readonly tunnelRemotePort: number;\n\tpublic tunnelLocalPort!: number;\n\tpublic tunnelRemoteHost: string;\n\tpublic localAddress!: string;\n\tpublic readonly public = false;\n\n\tprivate readonly _options: IConnectionOptions;\n\tprivate readonly _server: net.Server;\n\tprivate readonly _barrier: Barrier;\n\n\tprivate readonly _listeningListener: () => void;\n\tprivate readonly _connectionListener: (socket: net.Socket) => void;\n\tprivate readonly _errorListener: () => void;\n\n\tprivate readonly _socketsDispose: Map<string, () => void> = new Map();\n\n\tconstructor(options: IConnectionOptions, tunnelRemoteHost: string, tunnelRemotePort: number, private readonly suggestedLocalPort?: number) {\n\t\tsuper();\n\t\tthis._options = options;\n\t\tthis._server = net.createServer();\n\t\tthis._barrier = new Barrier();\n\n\t\tthis._listeningListener = () => this._barrier.open();\n\t\tthis._server.on('listening', this._listeningListener);\n\n\t\tthis._connectionListener = (socket) => this._onConnection(socket);\n\t\tthis._server.on('connection', this._connectionListener);\n\n\t\t// If there is no error listener and there is an error it will crash the whole window\n\t\tthis._errorListener = () => { };\n\t\tthis._server.on('error', this._errorListener);\n\n\t\tthis.tunnelRemotePort = tunnelRemotePort;\n\t\tthis.tunnelRemoteHost = tunnelRemoteHost;\n\t}\n\n\tpublic override async dispose(): Promise<void> {\n\t\tsuper.dispose();\n\t\tthis._server.removeListener('listening', this._listeningListener);\n\t\tthis._server.removeListener('connection', this._connectionListener);\n\t\tthis._server.removeListener('error', this._errorListener);\n\t\tthis._server.close();\n\t\tconst disposers = Array.from(this._socketsDispose.values());\n\t\tdisposers.forEach(disposer => {\n\t\t\tdisposer();\n\t\t});\n\t}\n\n\tpublic async waitForReady(): Promise<this> {\n\t\t// try to get the same port number as the remote port number...\n\t\tlet localPort = await findFreePortFaster(this.suggestedLocalPort ?? this.tunnelRemotePort, 2, 1000);\n\n\t\t// if that fails, the method above returns 0, which works out fine below...\n\t\tlet address: string | net.AddressInfo | null = null;\n\t\taddress = (<net.AddressInfo>this._server.listen(localPort).address());\n\n\t\t// It is possible for findFreePortFaster to return a port that there is already a server listening on. This causes the previous listen call to error out.\n\t\tif (!address) {\n\t\t\tlocalPort = 0;\n\t\t\taddress = (<net.AddressInfo>this._server.listen(localPort).address());\n\t\t}\n\n\t\tthis.tunnelLocalPort = address.port;\n\n\t\tawait this._barrier.wait();\n\t\tthis.localAddress = `${this.tunnelRemoteHost === '127.0.0.1' ? '127.0.0.1' : 'localhost'}:${address.port}`;\n\t\treturn this;\n\t}\n\n\tprivate async _onConnection(localSocket: net.Socket): Promise<void> {\n\t\t// pause reading on the socket until we have a chance to forward its data\n\t\tlocalSocket.pause();\n\n\t\tconst protocol = await connectRemoteAgentTunnel(this._options, this.tunnelRemotePort);\n\t\tconst remoteSocket = (<NodeSocket>protocol.getSocket()).socket;\n\t\tconst dataChunk = protocol.readEntireBuffer();\n\t\tprotocol.dispose();\n\n\t\tif (dataChunk.byteLength > 0) {\n\t\t\tlocalSocket.write(dataChunk.buffer);\n\t\t}\n\n\t\tlocalSocket.on('end', () => {\n\t\t\tthis._socketsDispose.delete(localSocket.localAddress);\n\t\t\tremoteSocket.end();\n\t\t});\n\t\tlocalSocket.on('close', () => remoteSocket.end());\n\t\tlocalSocket.on('error', () => {\n\t\t\tthis._socketsDispose.delete(localSocket.localAddress);\n\t\t\tremoteSocket.destroy();\n\t\t});\n\n\t\tremoteSocket.on('end', () => localSocket.end());\n\t\tremoteSocket.on('close', () => localSocket.end());\n\t\tremoteSocket.on('error', () => {\n\t\t\tlocalSocket.destroy();\n\t\t});\n\n\t\tlocalSocket.pipe(remoteSocket);\n\t\tremoteSocket.pipe(localSocket);\n\t\tthis._socketsDispose.set(localSocket.localAddress, () => {\n\t\t\t// Need to end instead of unpipe, otherwise whatever is connected locally could end up \"stuck\" with whatever state it had until manually exited.\n\t\t\tlocalSocket.end();\n\t\t\tremoteSocket.end();\n\t\t});\n\t}\n}\n\nexport class BaseTunnelService extends AbstractTunnelService {\n\tpublic constructor(\n\t\tprivate readonly socketFactory: ISocketFactory,\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService private readonly signService: ISignService,\n\t\t@IProductService private readonly productService: IProductService\n\t) {\n\t\tsuper(logService);\n\t}\n\n\tprotected retainOrCreateTunnel(addressProvider: IAddressProvider, remoteHost: string, remotePort: number, localPort: number | undefined, elevateIfNeeded: boolean, isPublic: boolean): Promise<RemoteTunnel | undefined> | undefined {\n\t\tconst existing = this.getTunnelFromMap(remoteHost, remotePort);\n\t\tif (existing) {\n\t\t\t++existing.refcount;\n\t\t\treturn existing.value;\n\t\t}\n\n\t\tif (this._tunnelProvider) {\n\t\t\treturn this.createWithProvider(this._tunnelProvider, remoteHost, remotePort, localPort, elevateIfNeeded, isPublic);\n\t\t} else {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel without provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\t\tconst options: IConnectionOptions = {\n\t\t\t\tcommit: this.productService.commit,\n\t\t\t\tsocketFactory: this.socketFactory,\n\t\t\t\taddressProvider,\n\t\t\t\tsignService: this.signService,\n\t\t\t\tlogService: this.logService,\n\t\t\t\tipcLogger: null\n\t\t\t};\n\n\t\t\tconst tunnel = createRemoteTunnel(options, remoteHost, remotePort, localPort);\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created without provider.');\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t\treturn tunnel;\n\t\t}\n\t}\n}\n\nexport class TunnelService extends BaseTunnelService {\n\tpublic constructor(\n\t\t@ILogService logService: ILogService,\n\t\t@ISignService signService: ISignService,\n\t\t@IProductService productService: IProductService\n\t) {\n\t\tsuper(nodeSocketFactory, logService, signService, productService);\n\t}\n}\n"]}