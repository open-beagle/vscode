{"version":3,"file":"tunnel.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/remote/common/tunnel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { isWindows, OperatingSystem } from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IAddressProvider } from 'vs/platform/remote/common/remoteAgentConnection';\n\nexport const ITunnelService = createDecorator<ITunnelService>('tunnelService');\n\nexport interface RemoteTunnel {\n\treadonly tunnelRemotePort: number;\n\treadonly tunnelRemoteHost: string;\n\treadonly tunnelLocalPort?: number;\n\treadonly localAddress: string;\n\treadonly public: boolean;\n\tdispose(silent?: boolean): Promise<void>;\n}\n\nexport interface TunnelOptions {\n\tremoteAddress: { port: number, host: string; };\n\tlocalAddressPort?: number;\n\tlabel?: string;\n\tpublic?: boolean;\n}\n\nexport interface TunnelCreationOptions {\n\televationRequired?: boolean;\n}\n\nexport interface TunnelProviderFeatures {\n\televation: boolean;\n\tpublic: boolean;\n}\n\nexport interface ITunnelProvider {\n\tforwardPort(tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<RemoteTunnel | undefined> | undefined;\n}\n\nexport enum ProvidedOnAutoForward {\n\tNotify = 1,\n\tOpenBrowser = 2,\n\tOpenPreview = 3,\n\tSilent = 4,\n\tIgnore = 5\n}\n\nexport interface ProvidedPortAttributes {\n\tport: number;\n\tautoForwardAction: ProvidedOnAutoForward;\n}\n\nexport interface PortAttributesProvider {\n\tprovidePortAttributes(ports: number[], pid: number | undefined, commandLine: string | undefined, token: CancellationToken): Promise<ProvidedPortAttributes[]>;\n}\n\nexport interface ITunnel {\n\tremoteAddress: { port: number, host: string };\n\n\t/**\n\t * The complete local address(ex. localhost:1234)\n\t */\n\tlocalAddress: string;\n\n\tpublic?: boolean;\n\n\t/**\n\t * Implementers of Tunnel should fire onDidDispose when dispose is called.\n\t */\n\tonDidDispose: Event<void>;\n\n\tdispose(): Promise<void> | void;\n}\n\nexport interface ITunnelService {\n\treadonly _serviceBrand: undefined;\n\n\treadonly tunnels: Promise<readonly RemoteTunnel[]>;\n\treadonly canMakePublic: boolean;\n\treadonly onTunnelOpened: Event<RemoteTunnel>;\n\treadonly onTunnelClosed: Event<{ host: string, port: number; }>;\n\treadonly canElevate: boolean;\n\n\tcanTunnel(uri: URI): boolean;\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localPort?: number, elevateIfNeeded?: boolean, isPublic?: boolean): Promise<RemoteTunnel | undefined> | undefined;\n\tcloseTunnel(remoteHost: string, remotePort: number): Promise<void>;\n\tsetTunnelProvider(provider: ITunnelProvider | undefined, features: TunnelProviderFeatures): IDisposable;\n}\n\nexport function extractLocalHostUriMetaDataForPortMapping(uri: URI): { address: string, port: number; } | undefined {\n\tif (uri.scheme !== 'http' && uri.scheme !== 'https') {\n\t\treturn undefined;\n\t}\n\tconst localhostMatch = /^(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0):(\\d+)$/.exec(uri.authority);\n\tif (!localhostMatch) {\n\t\treturn undefined;\n\t}\n\treturn {\n\t\taddress: localhostMatch[1],\n\t\tport: +localhostMatch[2],\n\t};\n}\n\nexport const LOCALHOST_ADDRESSES = ['localhost', '127.0.0.1', '0:0:0:0:0:0:0:1', '::1'];\nexport function isLocalhost(host: string): boolean {\n\treturn LOCALHOST_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport const ALL_INTERFACES_ADDRESSES = ['0.0.0.0', '0:0:0:0:0:0:0:0', '::'];\nexport function isAllInterfaces(host: string): boolean {\n\treturn ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;\n}\n\nexport function isPortPrivileged(port: number, os?: OperatingSystem): boolean {\n\tif (os) {\n\t\treturn os !== OperatingSystem.Windows && (port < 1024);\n\t} else {\n\t\treturn !isWindows && (port < 1024);\n\t}\n}\n\nexport abstract class AbstractTunnelService implements ITunnelService {\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _onTunnelOpened: Emitter<RemoteTunnel> = new Emitter();\n\tpublic onTunnelOpened: Event<RemoteTunnel> = this._onTunnelOpened.event;\n\tprivate _onTunnelClosed: Emitter<{ host: string, port: number; }> = new Emitter();\n\tpublic onTunnelClosed: Event<{ host: string, port: number; }> = this._onTunnelClosed.event;\n\tprotected readonly _tunnels = new Map</*host*/ string, Map</* port */ number, { refcount: number, readonly value: Promise<RemoteTunnel | undefined>; }>>();\n\tprotected _tunnelProvider: ITunnelProvider | undefined;\n\tprotected _canElevate: boolean = false;\n\tprivate _canMakePublic: boolean = false;\n\n\tpublic constructor(\n\t\t@ILogService protected readonly logService: ILogService\n\t) { }\n\n\tsetTunnelProvider(provider: ITunnelProvider | undefined, features: TunnelProviderFeatures): IDisposable {\n\t\tthis._tunnelProvider = provider;\n\t\tif (!provider) {\n\t\t\t// clear features\n\t\t\tthis._canElevate = false;\n\t\t\tthis._canMakePublic = false;\n\t\t\treturn {\n\t\t\t\tdispose: () => { }\n\t\t\t};\n\t\t}\n\t\tthis._canElevate = features.elevation;\n\t\tthis._canMakePublic = features.public;\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\tthis._tunnelProvider = undefined;\n\t\t\t\tthis._canElevate = false;\n\t\t\t\tthis._canMakePublic = false;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic get canElevate(): boolean {\n\t\treturn this._canElevate;\n\t}\n\n\tpublic get canMakePublic() {\n\t\treturn this._canMakePublic;\n\t}\n\n\tpublic get tunnels(): Promise<readonly RemoteTunnel[]> {\n\t\treturn new Promise(async (resolve) => {\n\t\t\tconst tunnels: RemoteTunnel[] = [];\n\t\t\tconst tunnelArray = Array.from(this._tunnels.values());\n\t\t\tfor (let portMap of tunnelArray) {\n\t\t\t\tconst portArray = Array.from(portMap.values());\n\t\t\t\tfor (let x of portArray) {\n\t\t\t\t\tconst tunnelValue = await x.value;\n\t\t\t\t\tif (tunnelValue) {\n\t\t\t\t\t\ttunnels.push(tunnelValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve(tunnels);\n\t\t});\n\t}\n\n\tasync dispose(): Promise<void> {\n\t\tfor (const portMap of this._tunnels.values()) {\n\t\t\tfor (const { value } of portMap.values()) {\n\t\t\t\tawait value.then(tunnel => tunnel?.dispose());\n\t\t\t}\n\t\t\tportMap.clear();\n\t\t}\n\t\tthis._tunnels.clear();\n\t}\n\n\topenTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localPort?: number, elevateIfNeeded: boolean = false, isPublic: boolean = false): Promise<RemoteTunnel | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\t\tif (!addressProvider) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!remoteHost) {\n\t\t\tremoteHost = 'localhost';\n\t\t}\n\n\t\tconst resolvedTunnel = this.retainOrCreateTunnel(addressProvider, remoteHost, remotePort, localPort, elevateIfNeeded, isPublic);\n\t\tif (!resolvedTunnel) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel was not created.`);\n\t\t\treturn resolvedTunnel;\n\t\t}\n\n\t\treturn resolvedTunnel.then(tunnel => {\n\t\t\tif (!tunnel) {\n\t\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel is undefined.');\n\t\t\t\tthis.removeEmptyTunnelFromMap(remoteHost!, remotePort);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tthis.logService.trace('ForwardedPorts: (TunnelService) New tunnel established.');\n\t\t\tconst newTunnel = this.makeTunnel(tunnel);\n\t\t\tif (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {\n\t\t\t\tthis.logService.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.');\n\t\t\t}\n\t\t\tthis._onTunnelOpened.fire(newTunnel);\n\t\t\treturn newTunnel;\n\t\t});\n\t}\n\n\tprivate makeTunnel(tunnel: RemoteTunnel): RemoteTunnel {\n\t\treturn {\n\t\t\ttunnelRemotePort: tunnel.tunnelRemotePort,\n\t\t\ttunnelRemoteHost: tunnel.tunnelRemoteHost,\n\t\t\ttunnelLocalPort: tunnel.tunnelLocalPort,\n\t\t\tlocalAddress: tunnel.localAddress,\n\t\t\tpublic: tunnel.public,\n\t\t\tdispose: async () => {\n\t\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `);\n\t\t\t\tconst existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);\n\t\t\t\tif (existingHost) {\n\t\t\t\t\tconst existing = existingHost.get(tunnel.tunnelRemotePort);\n\t\t\t\t\tif (existing) {\n\t\t\t\t\t\texisting.refcount--;\n\t\t\t\t\t\tawait this.tryDisposeTunnel(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate async tryDisposeTunnel(remoteHost: string, remotePort: number, tunnel: { refcount: number, readonly value: Promise<RemoteTunnel | undefined> }): Promise<void> {\n\t\tif (tunnel.refcount <= 0) {\n\t\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`);\n\t\t\tconst disposePromise: Promise<void> = tunnel.value.then(async (tunnel) => {\n\t\t\t\tif (tunnel) {\n\t\t\t\t\tawait tunnel.dispose(true);\n\t\t\t\t\tthis._onTunnelClosed.fire({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort });\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (this._tunnels.has(remoteHost)) {\n\t\t\t\tthis._tunnels.get(remoteHost)!.delete(remotePort);\n\t\t\t}\n\t\t\treturn disposePromise;\n\t\t}\n\t}\n\n\tasync closeTunnel(remoteHost: string, remotePort: number): Promise<void> {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `);\n\t\tconst portMap = this._tunnels.get(remoteHost);\n\t\tif (portMap && portMap.has(remotePort)) {\n\t\t\tconst value = portMap.get(remotePort)!;\n\t\t\tvalue.refcount = 0;\n\t\t\tawait this.tryDisposeTunnel(remoteHost, remotePort, value);\n\t\t}\n\t}\n\n\tprotected addTunnelToMap(remoteHost: string, remotePort: number, tunnel: Promise<RemoteTunnel | undefined>) {\n\t\tif (!this._tunnels.has(remoteHost)) {\n\t\t\tthis._tunnels.set(remoteHost, new Map());\n\t\t}\n\t\tthis._tunnels.get(remoteHost)!.set(remotePort, { refcount: 1, value: tunnel });\n\t}\n\n\tprivate async removeEmptyTunnelFromMap(remoteHost: string, remotePort: number) {\n\t\tconst hostMap = this._tunnels.get(remoteHost);\n\t\tif (hostMap) {\n\t\t\tconst tunnel = hostMap.get(remotePort);\n\t\t\tconst tunnelResult = await tunnel;\n\t\t\tif (!tunnelResult) {\n\t\t\t\thostMap.delete(remotePort);\n\t\t\t}\n\t\t\tif (hostMap.size === 0) {\n\t\t\t\tthis._tunnels.delete(remoteHost);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getTunnelFromMap(remoteHost: string, remotePort: number): { refcount: number, readonly value: Promise<RemoteTunnel | undefined> } | undefined {\n\t\tlet hosts = [remoteHost];\n\t\t// Order matters. We want the original host to be first.\n\t\tif (isLocalhost(remoteHost)) {\n\t\t\thosts.push(...LOCALHOST_ADDRESSES);\n\t\t\t// For localhost, we add the all interfaces hosts because if the tunnel is already available at all interfaces,\n\t\t\t// then of course it is available at localhost.\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t} else if (isAllInterfaces(remoteHost)) {\n\t\t\thosts.push(...ALL_INTERFACES_ADDRESSES);\n\t\t}\n\n\t\tconst existingPortMaps = hosts.map(host => this._tunnels.get(host));\n\t\tfor (const map of existingPortMaps) {\n\t\t\tconst existingTunnel = map?.get(remotePort);\n\t\t\tif (existingTunnel) {\n\t\t\t\treturn existingTunnel;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tcanTunnel(uri: URI): boolean {\n\t\treturn !!extractLocalHostUriMetaDataForPortMapping(uri);\n\t}\n\n\tprotected abstract retainOrCreateTunnel(addressProvider: IAddressProvider, remoteHost: string, remotePort: number, localPort: number | undefined, elevateIfNeeded: boolean, isPublic: boolean): Promise<RemoteTunnel | undefined> | undefined;\n\n\tprotected createWithProvider(tunnelProvider: ITunnelProvider, remoteHost: string, remotePort: number, localPort: number | undefined, elevateIfNeeded: boolean, isPublic: boolean): Promise<RemoteTunnel | undefined> | undefined {\n\t\tthis.logService.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`);\n\n\t\tconst preferredLocalPort = localPort === undefined ? remotePort : localPort;\n\t\tconst creationInfo = { elevationRequired: elevateIfNeeded ? isPortPrivileged(preferredLocalPort) : false };\n\t\tconst tunnelOptions: TunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort, public: isPublic };\n\t\tconst tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);\n\t\tthis.logService.trace('ForwardedPorts: (TunnelService) Tunnel created by provider.');\n\t\tif (tunnel) {\n\t\t\tthis.addTunnelToMap(remoteHost, remotePort, tunnel);\n\t\t}\n\t\treturn tunnel;\n\t}\n}\n\n\n"]}