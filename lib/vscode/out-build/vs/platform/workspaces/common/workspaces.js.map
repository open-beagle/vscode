{"version":3,"sources":["vs/platform/workspaces/common/workspaces.ts"],"names":[],"mappings":"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","file":"workspaces.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { localize } from 'vs/nls';\nimport { IWorkspaceFolder, IWorkspace, WorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { isWindows, isLinux, isMacintosh } from 'vs/base/common/platform';\nimport { extname, isAbsolute } from 'vs/base/common/path';\nimport { extname as resourceExtname, extUriBiasedIgnorePathCase, IExtUri } from 'vs/base/common/resources';\nimport * as jsonEdit from 'vs/base/common/jsonEdit';\nimport * as json from 'vs/base/common/json';\nimport { Schemas } from 'vs/base/common/network';\nimport { normalizeDriveLetter } from 'vs/base/common/labels';\nimport { toSlashes } from 'vs/base/common/extpath';\nimport { FormattingOptions } from 'vs/base/common/jsonFormatter';\nimport { getRemoteAuthority } from 'vs/platform/remote/common/remoteHosts';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { Event } from 'vs/base/common/event';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\n\nexport const WORKSPACE_EXTENSION = 'code-workspace';\nconst WORKSPACE_SUFFIX = `.${WORKSPACE_EXTENSION}`;\nexport const WORKSPACE_FILTER = [{ name: localize('codeWorkspace', \"Code Workspace\"), extensions: [WORKSPACE_EXTENSION] }];\nexport const UNTITLED_WORKSPACE_NAME = 'workspace.json';\n\nexport function hasWorkspaceFileExtension(path: string | URI) {\n\tconst ext = (typeof path === 'string') ? extname(path) : resourceExtname(path);\n\n\treturn ext === WORKSPACE_SUFFIX;\n}\n\nexport const IWorkspacesService = createDecorator<IWorkspacesService>('workspacesService');\n\nexport interface IWorkspacesService {\n\n\treadonly _serviceBrand: undefined;\n\n\t// Workspaces Management\n\tenterWorkspace(path: URI): Promise<IEnterWorkspaceResult | null>;\n\tcreateUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier>;\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\tgetWorkspaceIdentifier(workspacePath: URI): Promise<IWorkspaceIdentifier>;\n\n\t// Workspaces History\n\treadonly onDidChangeRecentlyOpened: Event<void>;\n\taddRecentlyOpened(recents: IRecent[]): Promise<void>;\n\tremoveRecentlyOpened(workspaces: URI[]): Promise<void>;\n\tclearRecentlyOpened(): Promise<void>;\n\tgetRecentlyOpened(): Promise<IRecentlyOpened>;\n\n\t// Dirty Workspaces\n\tgetDirtyWorkspaces(): Promise<Array<IWorkspaceIdentifier | URI>>;\n}\n\n//#region Workspaces Recently Opened\n\nexport interface IRecentlyOpened {\n\tworkspaces: Array<IRecentWorkspace | IRecentFolder>;\n\tfiles: IRecentFile[];\n}\n\nexport type IRecent = IRecentWorkspace | IRecentFolder | IRecentFile;\n\nexport interface IRecentWorkspace {\n\tworkspace: IWorkspaceIdentifier;\n\tlabel?: string;\n\tremoteAuthority?: string;\n}\n\nexport interface IRecentFolder {\n\tfolderUri: URI;\n\tlabel?: string;\n\tremoteAuthority?: string;\n}\n\nexport interface IRecentFile {\n\tfileUri: URI;\n\tlabel?: string;\n\tremoteAuthority?: string;\n}\n\nexport function isRecentWorkspace(curr: IRecent): curr is IRecentWorkspace {\n\treturn curr.hasOwnProperty('workspace');\n}\n\nexport function isRecentFolder(curr: IRecent): curr is IRecentFolder {\n\treturn curr.hasOwnProperty('folderUri');\n}\n\nexport function isRecentFile(curr: IRecent): curr is IRecentFile {\n\treturn curr.hasOwnProperty('fileUri');\n}\n\n//#endregion\n\n//#region Identifiers / Payload\n\nexport interface IBaseWorkspaceIdentifier {\n\n\t/**\n\t * Every workspace (multi-root, single folder or empty)\n\t * has a unique identifier. It is not possible to open\n\t * a workspace with the same `id` in multiple windows\n\t */\n\tid: string;\n}\n\n/**\n * A single folder workspace identifier is a path to a folder + id.\n */\nexport interface ISingleFolderWorkspaceIdentifier extends IBaseWorkspaceIdentifier {\n\n\t/**\n\t * Folder path as `URI`.\n\t */\n\turi: URI;\n}\n\nexport interface ISerializedSingleFolderWorkspaceIdentifier extends IBaseWorkspaceIdentifier {\n\turi: UriComponents;\n}\n\nexport function isSingleFolderWorkspaceIdentifier(obj: unknown): obj is ISingleFolderWorkspaceIdentifier {\n\tconst singleFolderIdentifier = obj as ISingleFolderWorkspaceIdentifier | undefined;\n\n\treturn typeof singleFolderIdentifier?.id === 'string' && URI.isUri(singleFolderIdentifier.uri);\n}\n\n/**\n * A multi-root workspace identifier is a path to a workspace file + id.\n */\nexport interface IWorkspaceIdentifier extends IBaseWorkspaceIdentifier {\n\n\t/**\n\t * Workspace config file path as `URI`.\n\t */\n\tconfigPath: URI;\n}\n\nexport interface ISerializedWorkspaceIdentifier extends IBaseWorkspaceIdentifier {\n\tconfigPath: UriComponents;\n}\n\nexport function toWorkspaceIdentifier(workspace: IWorkspace): IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | undefined {\n\n\t// Multi root\n\tif (workspace.configuration) {\n\t\treturn {\n\t\t\tid: workspace.id,\n\t\t\tconfigPath: workspace.configuration\n\t\t};\n\t}\n\n\t// Single folder\n\tif (workspace.folders.length === 1) {\n\t\treturn {\n\t\t\tid: workspace.id,\n\t\t\turi: workspace.folders[0].uri\n\t\t};\n\t}\n\n\t// Empty workspace\n\treturn undefined;\n}\n\nexport function isWorkspaceIdentifier(obj: unknown): obj is IWorkspaceIdentifier {\n\tconst workspaceIdentifier = obj as IWorkspaceIdentifier | undefined;\n\n\treturn typeof workspaceIdentifier?.id === 'string' && URI.isUri(workspaceIdentifier.configPath);\n}\n\nexport function reviveIdentifier(identifier: undefined): undefined;\nexport function reviveIdentifier(identifier: ISerializedWorkspaceIdentifier): IWorkspaceIdentifier;\nexport function reviveIdentifier(identifier: ISerializedSingleFolderWorkspaceIdentifier): ISingleFolderWorkspaceIdentifier;\nexport function reviveIdentifier(identifier: IEmptyWorkspaceIdentifier): IEmptyWorkspaceIdentifier;\nexport function reviveIdentifier(identifier: ISerializedWorkspaceIdentifier | ISerializedSingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier | undefined): IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier | undefined;\nexport function reviveIdentifier(identifier: ISerializedWorkspaceIdentifier | ISerializedSingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier | undefined): IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier | undefined {\n\n\t// Single Folder\n\tconst singleFolderIdentifierCandidate = identifier as ISerializedSingleFolderWorkspaceIdentifier | undefined;\n\tif (singleFolderIdentifierCandidate?.uri) {\n\t\treturn { id: singleFolderIdentifierCandidate.id, uri: URI.revive(singleFolderIdentifierCandidate.uri) };\n\t}\n\n\t// Multi folder\n\tconst workspaceIdentifierCandidate = identifier as ISerializedWorkspaceIdentifier | undefined;\n\tif (workspaceIdentifierCandidate?.configPath) {\n\t\treturn { id: workspaceIdentifierCandidate.id, configPath: URI.revive(workspaceIdentifierCandidate.configPath) };\n\t}\n\n\t// Empty\n\tif (identifier?.id) {\n\t\treturn { id: identifier.id };\n\t}\n\n\treturn undefined;\n}\n\nexport function isUntitledWorkspace(path: URI, environmentService: IEnvironmentService): boolean {\n\treturn extUriBiasedIgnorePathCase.isEqualOrParent(path, environmentService.untitledWorkspacesHome);\n}\n\nexport interface IEmptyWorkspaceIdentifier extends IBaseWorkspaceIdentifier { }\n\nexport type IWorkspaceInitializationPayload = IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier;\n\n//#endregion\n\n//#region Workspace File Utilities\n\nexport function isStoredWorkspaceFolder(obj: unknown): obj is IStoredWorkspaceFolder {\n\treturn isRawFileWorkspaceFolder(obj) || isRawUriWorkspaceFolder(obj);\n}\n\nexport function isRawFileWorkspaceFolder(obj: unknown): obj is IRawFileWorkspaceFolder {\n\tconst candidate = obj as IRawFileWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.path === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nexport function isRawUriWorkspaceFolder(obj: unknown): obj is IRawUriWorkspaceFolder {\n\tconst candidate = obj as IRawUriWorkspaceFolder | undefined;\n\n\treturn typeof candidate?.uri === 'string' && (!candidate.name || typeof candidate.name === 'string');\n}\n\nexport interface IRawFileWorkspaceFolder {\n\tpath: string;\n\tname?: string;\n}\n\nexport interface IRawUriWorkspaceFolder {\n\turi: string;\n\tname?: string;\n}\n\nexport type IStoredWorkspaceFolder = IRawFileWorkspaceFolder | IRawUriWorkspaceFolder;\n\nexport interface IResolvedWorkspace extends IWorkspaceIdentifier {\n\tfolders: IWorkspaceFolder[];\n\tremoteAuthority?: string;\n}\n\nexport interface IStoredWorkspace {\n\tfolders: IStoredWorkspaceFolder[];\n\tremoteAuthority?: string;\n}\n\nexport interface IWorkspaceFolderCreationData {\n\turi: URI;\n\tname?: string;\n}\n\nexport interface IUntitledWorkspaceInfo {\n\tworkspace: IWorkspaceIdentifier;\n\tremoteAuthority?: string;\n}\n\nexport interface IEnterWorkspaceResult {\n\tworkspace: IWorkspaceIdentifier;\n\tbackupPath?: string;\n}\n\n/**\n * Given a folder URI and the workspace config folder, computes the IStoredWorkspaceFolder using\n* a relative or absolute path or a uri.\n * Undefined is returned if the folderURI and the targetConfigFolderURI don't have the same schema or authority\n *\n * @param folderURI a workspace folder\n * @param forceAbsolute if set, keep the path absolute\n * @param folderName a workspace name\n * @param targetConfigFolderURI the folder where the workspace is living in\n * @param useSlashForPath if set, use forward slashes for file paths on windows\n */\nexport function getStoredWorkspaceFolder(folderURI: URI, forceAbsolute: boolean, folderName: string | undefined, targetConfigFolderURI: URI, useSlashForPath = !isWindows, extUri: IExtUri): IStoredWorkspaceFolder {\n\tif (folderURI.scheme !== targetConfigFolderURI.scheme) {\n\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t}\n\n\tlet folderPath = !forceAbsolute ? extUri.relativePath(targetConfigFolderURI, folderURI) : undefined;\n\tif (folderPath !== undefined) {\n\t\tif (folderPath.length === 0) {\n\t\t\tfolderPath = '.';\n\t\t} else if (isWindows && folderURI.scheme === Schemas.file && !useSlashForPath) {\n\t\t\t// Windows gets special treatment:\n\t\t\t// - use backslahes unless slash is used by other existing folders\n\t\t\tfolderPath = folderPath.replace(/\\//g, '\\\\');\n\t\t}\n\t} else {\n\n\t\t// use absolute path\n\t\tif (folderURI.scheme === Schemas.file) {\n\t\t\tfolderPath = folderURI.fsPath;\n\t\t\tif (isWindows) {\n\t\t\t\t// Windows gets special treatment:\n\t\t\t\t// - normalize all paths to get nice casing of drive letters\n\t\t\t\t// - use backslahes unless slash is used by other existing folders\n\t\t\t\tfolderPath = normalizeDriveLetter(folderPath);\n\t\t\t\tif (useSlashForPath) {\n\t\t\t\t\tfolderPath = toSlashes(folderPath);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!extUri.isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {\n\t\t\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t\t\t}\n\t\t\tfolderPath = folderURI.path;\n\t\t}\n\t}\n\n\treturn { name: folderName, path: folderPath };\n}\n\nexport function toWorkspaceFolders(configuredFolders: IStoredWorkspaceFolder[], workspaceConfigFile: URI, extUri: IExtUri): WorkspaceFolder[] {\n\tlet result: WorkspaceFolder[] = [];\n\tlet seen: Set<string> = new Set();\n\n\tconst relativeTo = extUri.dirname(workspaceConfigFile);\n\tfor (let configuredFolder of configuredFolders) {\n\t\tlet uri: URI | null = null;\n\t\tif (isRawFileWorkspaceFolder(configuredFolder)) {\n\t\t\tif (configuredFolder.path) {\n\t\t\t\turi = extUri.resolvePath(relativeTo, configuredFolder.path);\n\t\t\t}\n\t\t} else if (isRawUriWorkspaceFolder(configuredFolder)) {\n\t\t\ttry {\n\t\t\t\turi = URI.parse(configuredFolder.uri);\n\t\t\t\t// this makes sure all workspace folder are absolute\n\t\t\t\tif (uri.path[0] !== '/') {\n\t\t\t\t\turi = uri.with({ path: '/' + uri.path });\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(e);\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tif (uri) {\n\t\t\t// remove duplicates\n\t\t\tlet comparisonKey = extUri.getComparisonKey(uri);\n\t\t\tif (!seen.has(comparisonKey)) {\n\t\t\t\tseen.add(comparisonKey);\n\n\t\t\t\tconst name = configuredFolder.name || extUri.basenameOrAuthority(uri);\n\t\t\t\tresult.push(new WorkspaceFolder({ uri, name, index: result.length }, configuredFolder));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Rewrites the content of a workspace file to be saved at a new location.\n * Throws an exception if file is not a valid workspace file\n */\nexport function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents: string, configPathURI: URI, isFromUntitledWorkspace: boolean, targetConfigPathURI: URI, extUri: IExtUri) {\n\tlet storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);\n\n\tconst sourceConfigFolder = extUri.dirname(configPathURI);\n\tconst targetConfigFolder = extUri.dirname(targetConfigPathURI);\n\n\tconst rewrittenFolders: IStoredWorkspaceFolder[] = [];\n\tconst slashForPath = useSlashForPath(storedWorkspace.folders);\n\n\tfor (const folder of storedWorkspace.folders) {\n\t\tconst folderURI = isRawFileWorkspaceFolder(folder) ? extUri.resolvePath(sourceConfigFolder, folder.path) : URI.parse(folder.uri);\n\t\tlet absolute;\n\t\tif (isFromUntitledWorkspace) {\n\t\t\t// if it was an untitled workspace, try to make paths relative\n\t\t\tabsolute = false;\n\t\t} else {\n\t\t\t// for existing workspaces, preserve whether a path was absolute or relative\n\t\t\tabsolute = !isRawFileWorkspaceFolder(folder) || isAbsolute(folder.path);\n\t\t}\n\t\trewrittenFolders.push(getStoredWorkspaceFolder(folderURI, absolute, folder.name, targetConfigFolder, slashForPath, extUri));\n\t}\n\n\t// Preserve as much of the existing workspace as possible by using jsonEdit\n\t// and only changing the folders portion.\n\tconst formattingOptions: FormattingOptions = { insertSpaces: false, tabSize: 4, eol: (isLinux || isMacintosh) ? '\\n' : '\\r\\n' };\n\tconst edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, formattingOptions);\n\tlet newContent = jsonEdit.applyEdits(rawWorkspaceContents, edits);\n\n\tif (storedWorkspace.remoteAuthority === getRemoteAuthority(targetConfigPathURI)) {\n\t\t// unsaved remote workspaces have the remoteAuthority set. Remove it when no longer nexessary.\n\t\tnewContent = jsonEdit.applyEdits(newContent, jsonEdit.removeProperty(newContent, ['remoteAuthority'], formattingOptions));\n\t}\n\n\treturn newContent;\n}\n\nfunction doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\n\t// Parse workspace file\n\tlet storedWorkspace: IStoredWorkspace = json.parse(contents); // use fault tolerant parser\n\n\t// Filter out folders which do not have a path or uri set\n\tif (storedWorkspace && Array.isArray(storedWorkspace.folders)) {\n\t\tstoredWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n\t} else {\n\t\tthrow new Error(`${path} looks like an invalid workspace file.`);\n\t}\n\n\treturn storedWorkspace;\n}\n\nexport function useSlashForPath(storedFolders: IStoredWorkspaceFolder[]): boolean {\n\tif (isWindows) {\n\t\treturn storedFolders.some(folder => isRawFileWorkspaceFolder(folder) && folder.path.indexOf('/') >= 0);\n\t}\n\n\treturn true;\n}\n\n//#endregion\n\n//#region Workspace Storage\n\ninterface ISerializedRecentWorkspace {\n\tworkspace: {\n\t\tid: string;\n\t\tconfigPath: string;\n\t}\n\tlabel?: string;\n\tremoteAuthority?: string;\n}\n\ninterface ISerializedRecentFolder {\n\tfolderUri: string;\n\tlabel?: string;\n\tremoteAuthority?: string;\n}\n\ninterface ISerializedRecentFile {\n\tfileUri: string;\n\tlabel?: string;\n\tremoteAuthority?: string;\n}\n\ninterface ISerializedRecentlyOpenedLegacy {\n\tworkspaces3: Array<{ id: string; configURIPath: string; } | string>; // workspace or URI.toString() // added in 1.32\n\tworkspaceLabels?: Array<string | null>; // added in 1.33\n\tfiles2: string[]; // files as URI.toString() // added in 1.32\n\tfileLabels?: Array<string | null>; // added in 1.33\n}\n\ninterface ISerializedRecentlyOpened {\n\tentries: Array<ISerializedRecentWorkspace | ISerializedRecentFolder | ISerializedRecentFile>; // since 1.55\n}\n\nexport type RecentlyOpenedStorageData = object;\n\nfunction isSerializedRecentWorkspace(data: any): data is ISerializedRecentWorkspace {\n\treturn data.workspace && typeof data.workspace === 'object' && typeof data.workspace.id === 'string' && typeof data.workspace.configPath === 'string';\n}\n\nfunction isSerializedRecentFolder(data: any): data is ISerializedRecentFolder {\n\treturn typeof data.folderUri === 'string';\n}\n\nfunction isSerializedRecentFile(data: any): data is ISerializedRecentFile {\n\treturn typeof data.fileUri === 'string';\n}\n\n\nexport function restoreRecentlyOpened(data: RecentlyOpenedStorageData | undefined, logService: ILogService): IRecentlyOpened {\n\tconst result: IRecentlyOpened = { workspaces: [], files: [] };\n\tif (data) {\n\t\tconst restoreGracefully = function <T>(entries: T[], func: (entry: T, index: number) => void) {\n\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tfunc(entries[i], i);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogService.warn(`Error restoring recent entry ${JSON.stringify(entries[i])}: ${e.toString()}. Skip entry.`);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst storedRecents = data as ISerializedRecentlyOpened;\n\t\tif (Array.isArray(storedRecents.entries)) {\n\t\t\trestoreGracefully(storedRecents.entries, (entry) => {\n\t\t\t\tconst label = entry.label;\n\t\t\t\tconst remoteAuthority = entry.remoteAuthority;\n\n\t\t\t\tif (isSerializedRecentWorkspace(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, workspace: { id: entry.workspace.id, configPath: URI.parse(entry.workspace.configPath) } });\n\t\t\t\t} else if (isSerializedRecentFolder(entry)) {\n\t\t\t\t\tresult.workspaces.push({ label, remoteAuthority, folderUri: URI.parse(entry.folderUri) });\n\t\t\t\t} else if (isSerializedRecentFile(entry)) {\n\t\t\t\t\tresult.files.push({ label, remoteAuthority, fileUri: URI.parse(entry.fileUri) });\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst storedRecents2 = data as ISerializedRecentlyOpenedLegacy;\n\t\t\tif (Array.isArray(storedRecents2.workspaces3)) {\n\t\t\t\trestoreGracefully(storedRecents2.workspaces3, (workspace, i) => {\n\t\t\t\t\tconst label: string | undefined = (Array.isArray(storedRecents2.workspaceLabels) && storedRecents2.workspaceLabels[i]) || undefined;\n\t\t\t\t\tif (typeof workspace === 'object' && typeof workspace.id === 'string' && typeof workspace.configURIPath === 'string') {\n\t\t\t\t\t\tresult.workspaces.push({ label, workspace: { id: workspace.id, configPath: URI.parse(workspace.configURIPath) } });\n\t\t\t\t\t} else if (typeof workspace === 'string') {\n\t\t\t\t\t\tresult.workspaces.push({ label, folderUri: URI.parse(workspace) });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (Array.isArray(storedRecents2.files2)) {\n\t\t\t\trestoreGracefully(storedRecents2.files2, (file, i) => {\n\t\t\t\t\tconst label: string | undefined = (Array.isArray(storedRecents2.fileLabels) && storedRecents2.fileLabels[i]) || undefined;\n\t\t\t\t\tif (typeof file === 'string') {\n\t\t\t\t\t\tresult.files.push({ label, fileUri: URI.parse(file) });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function toStoreData(recents: IRecentlyOpened): RecentlyOpenedStorageData {\n\tconst serialized: ISerializedRecentlyOpened = { entries: [] };\n\n\tfor (const recent of recents.workspaces) {\n\t\tif (isRecentFolder(recent)) {\n\t\t\tserialized.entries.push({ folderUri: recent.folderUri.toString(), label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t\t} else {\n\t\t\tserialized.entries.push({ workspace: { id: recent.workspace.id, configPath: recent.workspace.configPath.toString() }, label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t\t}\n\t}\n\n\tfor (const recent of recents.files) {\n\t\tserialized.entries.push({ fileUri: recent.fileUri.toString(), label: recent.label, remoteAuthority: recent.remoteAuthority });\n\t}\n\treturn serialized;\n}\n\n//#endregion\n"]}