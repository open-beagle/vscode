{"version":3,"file":"backupMainService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/backup/electron-main/backupMainService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { createHash } from 'crypto';\nimport { join } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { writeFileSync, writeFile, readdir, exists, rimraf, RimRafMode } from 'vs/base/node/pfs';\nimport { IBackupMainService, IWorkspaceBackupInfo, isWorkspaceBackupInfo } from 'vs/platform/backup/electron-main/backup';\nimport { IBackupWorkspacesFormat, IEmptyWindowBackupInfo } from 'vs/platform/backup/node/backup';\nimport { IEnvironmentMainService } from 'vs/platform/environment/electron-main/environmentMainService';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IFilesConfiguration, HotExitConfiguration } from 'vs/platform/files/common/files';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IWorkspaceIdentifier, isWorkspaceIdentifier } from 'vs/platform/workspaces/common/workspaces';\nimport { URI } from 'vs/base/common/uri';\nimport { isEqual } from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport { extUriBiasedIgnorePathCase } from 'vs/base/common/resources';\n\nexport class BackupMainService implements IBackupMainService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprotected backupHome: string;\n\tprotected workspacesJsonPath: string;\n\n\tprivate workspaces: IWorkspaceBackupInfo[] = [];\n\tprivate folders: URI[] = [];\n\tprivate emptyWindows: IEmptyWindowBackupInfo[] = [];\n\n\t// Comparers for paths and resources that will\n\t// - ignore path casing on Windows/macOS\n\t// - respect path casing on Linux\n\tprivate readonly backupUriComparer = extUriBiasedIgnorePathCase;\n\tprivate readonly backupPathComparer = { isEqual: (pathA: string, pathB: string) => isEqual(pathA, pathB, !isLinux) };\n\n\tconstructor(\n\t\t@IEnvironmentMainService environmentMainService: IEnvironmentMainService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tthis.backupHome = environmentMainService.backupHome;\n\t\tthis.workspacesJsonPath = environmentMainService.backupWorkspacesPath;\n\t}\n\n\tasync initialize(): Promise<void> {\n\t\tlet backups: IBackupWorkspacesFormat;\n\t\ttry {\n\t\t\tbackups = JSON.parse(await fs.promises.readFile(this.workspacesJsonPath, 'utf8')); // invalid JSON or permission issue can happen here\n\t\t} catch (error) {\n\t\t\tbackups = Object.create(null);\n\t\t}\n\n\t\t// read empty workspaces backups first\n\t\tif (backups.emptyWorkspaceInfos) {\n\t\t\tthis.emptyWindows = await this.validateEmptyWorkspaces(backups.emptyWorkspaceInfos);\n\t\t}\n\n\t\t// read workspace backups\n\t\tlet rootWorkspaces: IWorkspaceBackupInfo[] = [];\n\t\ttry {\n\t\t\tif (Array.isArray(backups.rootURIWorkspaces)) {\n\t\t\t\trootWorkspaces = backups.rootURIWorkspaces.map(workspace => ({ workspace: { id: workspace.id, configPath: URI.parse(workspace.configURIPath) }, remoteAuthority: workspace.remoteAuthority }));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// ignore URI parsing exceptions\n\t\t}\n\n\t\tthis.workspaces = await this.validateWorkspaces(rootWorkspaces);\n\n\t\t// read folder backups\n\t\tlet workspaceFolders: URI[] = [];\n\t\ttry {\n\t\t\tif (Array.isArray(backups.folderURIWorkspaces)) {\n\t\t\t\tworkspaceFolders = backups.folderURIWorkspaces.map(folder => URI.parse(folder));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// ignore URI parsing exceptions\n\t\t}\n\n\t\tthis.folders = await this.validateFolders(workspaceFolders);\n\n\t\t// save again in case some workspaces or folders have been removed\n\t\tawait this.save();\n\t}\n\n\tgetWorkspaceBackups(): IWorkspaceBackupInfo[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.workspaces.slice(0); // return a copy\n\t}\n\n\tgetFolderBackupPaths(): URI[] {\n\t\tif (this.isHotExitOnExitAndWindowClose()) {\n\t\t\t// Only non-folder windows are restored on main process launch when\n\t\t\t// hot exit is configured as onExitAndWindowClose.\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.folders.slice(0); // return a copy\n\t}\n\n\tisHotExitEnabled(): boolean {\n\t\treturn this.getHotExitConfig() !== HotExitConfiguration.OFF;\n\t}\n\n\tprivate isHotExitOnExitAndWindowClose(): boolean {\n\t\treturn this.getHotExitConfig() === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE;\n\t}\n\n\tprivate getHotExitConfig(): string {\n\t\tconst config = this.configurationService.getValue<IFilesConfiguration>();\n\n\t\treturn config?.files?.hotExit || HotExitConfiguration.ON_EXIT;\n\t}\n\n\tgetEmptyWindowBackupPaths(): IEmptyWindowBackupInfo[] {\n\t\treturn this.emptyWindows.slice(0); // return a copy\n\t}\n\n\tregisterWorkspaceBackupSync(workspaceInfo: IWorkspaceBackupInfo, migrateFrom?: string): string {\n\t\tif (!this.workspaces.some(workspace => workspaceInfo.workspace.id === workspace.workspace.id)) {\n\t\t\tthis.workspaces.push(workspaceInfo);\n\t\t\tthis.saveSync();\n\t\t}\n\n\t\tconst backupPath = this.getBackupPath(workspaceInfo.workspace.id);\n\n\t\tif (migrateFrom) {\n\t\t\tthis.moveBackupFolderSync(backupPath, migrateFrom);\n\t\t}\n\n\t\treturn backupPath;\n\t}\n\n\tprivate moveBackupFolderSync(backupPath: string, moveFromPath: string): void {\n\n\t\t// Target exists: make sure to convert existing backups to empty window backups\n\t\tif (fs.existsSync(backupPath)) {\n\t\t\tthis.convertToEmptyWindowBackupSync(backupPath);\n\t\t}\n\n\t\t// When we have data to migrate from, move it over to the target location\n\t\tif (fs.existsSync(moveFromPath)) {\n\t\t\ttry {\n\t\t\t\tfs.renameSync(moveFromPath, backupPath);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`Backup: Could not move backup folder to new location: ${error.toString()}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tunregisterWorkspaceBackupSync(workspace: IWorkspaceIdentifier): void {\n\t\tconst id = workspace.id;\n\t\tconst index = this.workspaces.findIndex(workspace => workspace.workspace.id === id);\n\t\tif (index !== -1) {\n\t\t\tthis.workspaces.splice(index, 1);\n\t\t\tthis.saveSync();\n\t\t}\n\t}\n\n\tregisterFolderBackupSync(folderUri: URI): string {\n\t\tif (!this.folders.some(folder => this.backupUriComparer.isEqual(folderUri, folder))) {\n\t\t\tthis.folders.push(folderUri);\n\t\t\tthis.saveSync();\n\t\t}\n\n\t\treturn this.getBackupPath(this.getFolderHash(folderUri));\n\t}\n\n\tunregisterFolderBackupSync(folderUri: URI): void {\n\t\tconst index = this.folders.findIndex(folder => this.backupUriComparer.isEqual(folderUri, folder));\n\t\tif (index !== -1) {\n\t\t\tthis.folders.splice(index, 1);\n\t\t\tthis.saveSync();\n\t\t}\n\t}\n\n\tregisterEmptyWindowBackupSync(backupFolderCandidate?: string, remoteAuthority?: string): string {\n\n\t\t// Generate a new folder if this is a new empty workspace\n\t\tconst backupFolder = backupFolderCandidate || this.getRandomEmptyWindowId();\n\t\tif (!this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, backupFolder))) {\n\t\t\tthis.emptyWindows.push({ backupFolder, remoteAuthority });\n\t\t\tthis.saveSync();\n\t\t}\n\n\t\treturn this.getBackupPath(backupFolder);\n\t}\n\n\tunregisterEmptyWindowBackupSync(backupFolder: string): void {\n\t\tconst index = this.emptyWindows.findIndex(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, backupFolder));\n\t\tif (index !== -1) {\n\t\t\tthis.emptyWindows.splice(index, 1);\n\t\t\tthis.saveSync();\n\t\t}\n\t}\n\n\tprivate getBackupPath(oldFolderHash: string): string {\n\t\treturn join(this.backupHome, oldFolderHash);\n\t}\n\n\tprivate async validateWorkspaces(rootWorkspaces: IWorkspaceBackupInfo[]): Promise<IWorkspaceBackupInfo[]> {\n\t\tif (!Array.isArray(rootWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst seenIds: Set<string> = new Set();\n\t\tconst result: IWorkspaceBackupInfo[] = [];\n\n\t\t// Validate Workspaces\n\t\tfor (let workspaceInfo of rootWorkspaces) {\n\t\t\tconst workspace = workspaceInfo.workspace;\n\t\t\tif (!isWorkspaceIdentifier(workspace)) {\n\t\t\t\treturn []; // wrong format, skip all entries\n\t\t\t}\n\n\t\t\tif (!seenIds.has(workspace.id)) {\n\t\t\t\tseenIds.add(workspace.id);\n\n\t\t\t\tconst backupPath = this.getBackupPath(workspace.id);\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the workspace has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (workspace.configPath.scheme !== Schemas.file || await exists(workspace.configPath.fsPath)) {\n\t\t\t\t\t\tresult.push(workspaceInfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the workspace has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateFolders(folderWorkspaces: URI[]): Promise<URI[]> {\n\t\tif (!Array.isArray(folderWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: URI[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\t\tfor (let folderURI of folderWorkspaces) {\n\t\t\tconst key = this.backupUriComparer.getComparisonKey(folderURI);\n\t\t\tif (!seenIds.has(key)) {\n\t\t\t\tseenIds.add(key);\n\n\t\t\t\tconst backupPath = this.getBackupPath(this.getFolderHash(folderURI));\n\t\t\t\tconst hasBackups = await this.doHasBackups(backupPath);\n\n\t\t\t\t// If the folder has no backups, ignore it\n\t\t\t\tif (hasBackups) {\n\t\t\t\t\tif (folderURI.scheme !== Schemas.file || await exists(folderURI.fsPath)) {\n\t\t\t\t\t\tresult.push(folderURI);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the folder has backups, but the target workspace is missing, convert backups to empty ones\n\t\t\t\t\t\tawait this.convertToEmptyWindowBackup(backupPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async validateEmptyWorkspaces(emptyWorkspaces: IEmptyWindowBackupInfo[]): Promise<IEmptyWindowBackupInfo[]> {\n\t\tif (!Array.isArray(emptyWorkspaces)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IEmptyWindowBackupInfo[] = [];\n\t\tconst seenIds: Set<string> = new Set();\n\n\t\t// Validate Empty Windows\n\t\tfor (let backupInfo of emptyWorkspaces) {\n\t\t\tconst backupFolder = backupInfo.backupFolder;\n\t\t\tif (typeof backupFolder !== 'string') {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (!seenIds.has(backupFolder)) {\n\t\t\t\tseenIds.add(backupFolder);\n\n\t\t\t\tconst backupPath = this.getBackupPath(backupFolder);\n\t\t\t\tif (await this.doHasBackups(backupPath)) {\n\t\t\t\t\tresult.push(backupInfo);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.deleteStaleBackup(backupPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async deleteStaleBackup(backupPath: string): Promise<void> {\n\t\ttry {\n\t\t\tif (await exists(backupPath)) {\n\t\t\t\tawait rimraf(backupPath, RimRafMode.MOVE);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not delete stale backup: ${error.toString()}`);\n\t\t}\n\t}\n\n\tprivate async convertToEmptyWindowBackup(backupPath: string): Promise<boolean> {\n\n\t\t// New empty window backup\n\t\tlet newBackupFolder = this.getRandomEmptyWindowId();\n\t\twhile (this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, newBackupFolder))) {\n\t\t\tnewBackupFolder = this.getRandomEmptyWindowId();\n\t\t}\n\n\t\t// Rename backupPath to new empty window backup path\n\t\tconst newEmptyWindowBackupPath = this.getBackupPath(newBackupFolder);\n\t\ttry {\n\t\t\tawait fs.promises.rename(backupPath, newEmptyWindowBackupPath);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not rename backup folder: ${error.toString()}`);\n\t\t\treturn false;\n\t\t}\n\t\tthis.emptyWindows.push({ backupFolder: newBackupFolder });\n\n\t\treturn true;\n\t}\n\n\tprivate convertToEmptyWindowBackupSync(backupPath: string): boolean {\n\n\t\t// New empty window backup\n\t\tlet newBackupFolder = this.getRandomEmptyWindowId();\n\t\twhile (this.emptyWindows.some(emptyWindow => !!emptyWindow.backupFolder && this.backupPathComparer.isEqual(emptyWindow.backupFolder, newBackupFolder))) {\n\t\t\tnewBackupFolder = this.getRandomEmptyWindowId();\n\t\t}\n\n\t\t// Rename backupPath to new empty window backup path\n\t\tconst newEmptyWindowBackupPath = this.getBackupPath(newBackupFolder);\n\t\ttry {\n\t\t\tfs.renameSync(backupPath, newEmptyWindowBackupPath);\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not rename backup folder: ${error.toString()}`);\n\t\t\treturn false;\n\t\t}\n\t\tthis.emptyWindows.push({ backupFolder: newBackupFolder });\n\n\t\treturn true;\n\t}\n\n\tasync getDirtyWorkspaces(): Promise<Array<IWorkspaceIdentifier | URI>> {\n\t\tconst dirtyWorkspaces: Array<IWorkspaceIdentifier | URI> = [];\n\n\t\t// Workspaces with backups\n\t\tfor (const workspace of this.workspaces) {\n\t\t\tif ((await this.hasBackups(workspace))) {\n\t\t\t\tdirtyWorkspaces.push(workspace.workspace);\n\t\t\t}\n\t\t}\n\n\t\t// Folders with backups\n\t\tfor (const folder of this.folders) {\n\t\t\tif ((await this.hasBackups(folder))) {\n\t\t\t\tdirtyWorkspaces.push(folder);\n\t\t\t}\n\t\t}\n\n\t\treturn dirtyWorkspaces;\n\t}\n\n\tprivate hasBackups(backupLocation: IWorkspaceBackupInfo | IEmptyWindowBackupInfo | URI): Promise<boolean> {\n\t\tlet backupPath: string;\n\n\t\t// Folder\n\t\tif (URI.isUri(backupLocation)) {\n\t\t\tbackupPath = this.getBackupPath(this.getFolderHash(backupLocation));\n\t\t}\n\n\t\t// Workspace\n\t\telse if (isWorkspaceBackupInfo(backupLocation)) {\n\t\t\tbackupPath = this.getBackupPath(backupLocation.workspace.id);\n\t\t}\n\n\t\t// Empty\n\t\telse {\n\t\t\tbackupPath = backupLocation.backupFolder;\n\t\t}\n\n\t\treturn this.doHasBackups(backupPath);\n\t}\n\n\tprivate async doHasBackups(backupPath: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst backupSchemas = await readdir(backupPath);\n\n\t\t\tfor (const backupSchema of backupSchemas) {\n\t\t\t\ttry {\n\t\t\t\t\tconst backupSchemaChildren = await readdir(join(backupPath, backupSchema));\n\t\t\t\t\tif (backupSchemaChildren.length > 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// invalid folder\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// backup path does not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate saveSync(): void {\n\t\ttry {\n\t\t\twriteFileSync(this.workspacesJsonPath, JSON.stringify(this.serializeBackups()));\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not save workspaces.json: ${error.toString()}`);\n\t\t}\n\t}\n\n\tprivate async save(): Promise<void> {\n\t\ttry {\n\t\t\tawait writeFile(this.workspacesJsonPath, JSON.stringify(this.serializeBackups()));\n\t\t} catch (error) {\n\t\t\tthis.logService.error(`Backup: Could not save workspaces.json: ${error.toString()}`);\n\t\t}\n\t}\n\n\tprivate serializeBackups(): IBackupWorkspacesFormat {\n\t\treturn {\n\t\t\trootURIWorkspaces: this.workspaces.map(workspace => ({ id: workspace.workspace.id, configURIPath: workspace.workspace.configPath.toString(), remoteAuthority: workspace.remoteAuthority })),\n\t\t\tfolderURIWorkspaces: this.folders.map(folder => folder.toString()),\n\t\t\temptyWorkspaceInfos: this.emptyWindows\n\t\t};\n\t}\n\n\tprivate getRandomEmptyWindowId(): string {\n\t\treturn (Date.now() + Math.round(Math.random() * 1000)).toString();\n\t}\n\n\tprotected getFolderHash(folderUri: URI): string {\n\t\tlet key: string;\n\n\t\tif (folderUri.scheme === Schemas.file) {\n\t\t\t// for backward compatibility, use the fspath as key\n\t\t\tkey = isLinux ? folderUri.fsPath : folderUri.fsPath.toLowerCase();\n\t\t} else {\n\t\t\tkey = folderUri.toString().toLowerCase();\n\t\t}\n\n\t\treturn createHash('md5').update(key).digest('hex');\n\t}\n}\n"]}