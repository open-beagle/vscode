{"version":3,"file":"errorTelemetry.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/telemetry/common/errorTelemetry.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch } from 'vs/base/common/arrays';\nimport * as Errors from 'vs/base/common/errors';\nimport { toDisposable, DisposableStore } from 'vs/base/common/lifecycle';\nimport { safeStringify } from 'vs/base/common/objects';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\n\ntype ErrorEventFragment = {\n\tcallstack: { classification: 'CallstackOrException', purpose: 'PerformanceAndHealth' };\n\tmsg?: { classification: 'CallstackOrException', purpose: 'PerformanceAndHealth' };\n\tfile?: { classification: 'CallstackOrException', purpose: 'PerformanceAndHealth' };\n\tline?: { classification: 'CallstackOrException', purpose: 'PerformanceAndHealth', isMeasurement: true };\n\tcolumn?: { classification: 'CallstackOrException', purpose: 'PerformanceAndHealth', isMeasurement: true };\n\tuncaught_error_name?: { classification: 'CallstackOrException', purpose: 'PerformanceAndHealth' };\n\tuncaught_error_msg?: { classification: 'CallstackOrException', purpose: 'PerformanceAndHealth' };\n\tcount?: { classification: 'CallstackOrException', purpose: 'PerformanceAndHealth', isMeasurement: true };\n};\nexport interface ErrorEvent {\n\tcallstack: string;\n\tmsg?: string;\n\tfile?: string;\n\tline?: number;\n\tcolumn?: number;\n\tuncaught_error_name?: string;\n\tuncaught_error_msg?: string;\n\tcount?: number;\n}\n\nexport namespace ErrorEvent {\n\texport function compare(a: ErrorEvent, b: ErrorEvent) {\n\t\tif (a.callstack < b.callstack) {\n\t\t\treturn -1;\n\t\t} else if (a.callstack > b.callstack) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nexport default abstract class BaseErrorTelemetry {\n\n\tpublic static ERROR_FLUSH_TIMEOUT: number = 5 * 1000;\n\n\tprivate _telemetryService: ITelemetryService;\n\tprivate _flushDelay: number;\n\tprivate _flushHandle: any = -1;\n\tprivate _buffer: ErrorEvent[] = [];\n\tprotected readonly _disposables = new DisposableStore();\n\n\tconstructor(telemetryService: ITelemetryService, flushDelay = BaseErrorTelemetry.ERROR_FLUSH_TIMEOUT) {\n\t\tthis._telemetryService = telemetryService;\n\t\tthis._flushDelay = flushDelay;\n\n\t\t// (1) check for unexpected but handled errors\n\t\tconst unbind = Errors.errorHandler.addListener((err) => this._onErrorEvent(err));\n\t\tthis._disposables.add(toDisposable(unbind));\n\n\t\t// (2) install implementation-specific error listeners\n\t\tthis.installErrorListeners();\n\t}\n\n\tdispose() {\n\t\tclearTimeout(this._flushHandle);\n\t\tthis._flushBuffer();\n\t\tthis._disposables.dispose();\n\t}\n\n\tprotected installErrorListeners(): void {\n\t\t// to override\n\t}\n\n\tprivate _onErrorEvent(err: any): void {\n\n\t\tif (!err) {\n\t\t\treturn;\n\t\t}\n\n\t\t// unwrap nested errors from loader\n\t\tif (err.detail && err.detail.stack) {\n\t\t\terr = err.detail;\n\t\t}\n\n\t\t// work around behavior in workerServer.ts that breaks up Error.stack\n\t\tlet callstack = Array.isArray(err.stack) ? err.stack.join('\\n') : err.stack;\n\t\tlet msg = err.message ? err.message : safeStringify(err);\n\n\t\t// errors without a stack are not useful telemetry\n\t\tif (!callstack) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enqueue({ msg, callstack });\n\t}\n\n\tprotected _enqueue(e: ErrorEvent): void {\n\n\t\tconst idx = binarySearch(this._buffer, e, ErrorEvent.compare);\n\t\tif (idx < 0) {\n\t\t\te.count = 1;\n\t\t\tthis._buffer.splice(~idx, 0, e);\n\t\t} else {\n\t\t\tif (!this._buffer[idx].count) {\n\t\t\t\tthis._buffer[idx].count = 0;\n\t\t\t}\n\t\t\tthis._buffer[idx].count! += 1;\n\t\t}\n\n\t\tif (this._flushHandle === -1) {\n\t\t\tthis._flushHandle = setTimeout(() => {\n\t\t\t\tthis._flushBuffer();\n\t\t\t\tthis._flushHandle = -1;\n\t\t\t}, this._flushDelay);\n\t\t}\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tfor (let error of this._buffer) {\n\t\t\ttype UnhandledErrorClassification = {} & ErrorEventFragment;\n\t\t\tthis._telemetryService.publicLogError2<ErrorEvent, UnhandledErrorClassification>('UnhandledError', error);\n\t\t}\n\t\tthis._buffer.length = 0;\n\t}\n}\n"]}