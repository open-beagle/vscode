{"version":3,"file":"services.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/ipc/electron-sandbox/services.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAUhG,MAAe,iBAAiB;QAC/B,YACC,WAAmB,EACnB,OAA+F,EAC/F,MAAc;YAEd,MAAM,OAAO,GAAG,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YAE/C,IAAI,uCAAuC,CAAC,OAAO,CAAC,EAAE;gBACrD,OAAO,IAAI,OAAO,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;aAC9C;YAED,OAAO,kBAAY,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,YAAY,CAAC,CAAC;QAC/D,CAAC;KACD;IAcD,SAAS,uCAAuC,CAAI,GAAY;QAC/D,MAAM,SAAS,GAAG,GAA4D,CAAC;QAE/E,OAAO,CAAC,CAAC,CAAA,SAAS,aAAT,SAAS,uBAAT,SAAS,CAAE,iBAAiB,CAAA,CAAC;IACvC,CAAC;IAED,sBAAsB;IAET,QAAA,mBAAmB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAsB,oBAAoB,CAAC,CAAC;IAQ9F,IAAM,4BAA4B,GAAlC,MAAM,4BAAgC,SAAQ,iBAAoB;QACjE,YAAY,WAAmB,EAAE,OAA+F,EAAuB,UAA+B;YACrL,KAAK,CAAC,WAAW,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;QACzC,CAAC;KACD,CAAA;IAJK,4BAA4B;QACkG,WAAA,2BAAmB,CAAA;OADjJ,4BAA4B,CAIjC;IAED,SAAgB,gCAAgC,CAAI,EAAwB,EAAE,WAAmB,EAAE,OAAoF;QACtL,CAAA,GAAA,8BAAiB,CAAA,CAAC,EAAE,EAAE,IAAI,4BAAc,CAAC,4BAA4B,EAAE,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,4BAA4B,CAAC,CAAC,CAAC;IACxI,CAAC;IAFD,4EAEC;IAED,YAAY;IAEZ,wBAAwB;IAEX,QAAA,qBAAqB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAwB,sBAAsB,CAAC,CAAC;IAQpG,IAAM,8BAA8B,GAApC,MAAM,8BAAkC,SAAQ,iBAAoB;QACnE,YAAY,WAAmB,EAAE,OAA+F,EAAyB,UAAiC;YACzL,KAAK,CAAC,WAAW,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;QACzC,CAAC;KACD,CAAA;IAJK,8BAA8B;QACgG,WAAA,6BAAqB,CAAA;OADnJ,8BAA8B,CAInC;IAED,SAAgB,kCAAkC,CAAI,EAAwB,EAAE,WAAmB,EAAE,OAAoF;QACxL,CAAA,GAAA,8BAAiB,CAAA,CAAC,EAAE,EAAE,IAAI,4BAAc,CAAC,8BAA8B,EAAE,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,4BAA4B,CAAC,CAAC,CAAC;IAC1I,CAAC;IAFD,gFAEC;;AAED,YAAY","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChannel, IServerChannel, ProxyChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { createDecorator, ServiceIdentifier } from 'vs/platform/instantiation/common/instantiation';\n\ntype ChannelClientCtor<T> = { new(channel: IChannel): T };\ntype Remote = { getChannel(channelName: string): IChannel; };\n\nabstract class RemoteServiceStub<T> {\n\tconstructor(\n\t\tchannelName: string,\n\t\toptions: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined,\n\t\tremote: Remote\n\t) {\n\t\tconst channel = remote.getChannel(channelName);\n\n\t\tif (isRemoteServiceWithChannelClientOptions(options)) {\n\t\t\treturn new options.channelClientCtor(channel);\n\t\t}\n\n\t\treturn ProxyChannel.toService(channel, options?.proxyOptions);\n\t}\n}\n\nexport interface IBaseRemoteServiceOptions {\n\treadonly supportsDelayedInstantiation?: boolean;\n}\n\nexport interface IRemoteServiceWithChannelClientOptions<T> extends IBaseRemoteServiceOptions {\n\treadonly channelClientCtor: ChannelClientCtor<T>;\n}\n\nexport interface IRemoteServiceWithProxyOptions extends IBaseRemoteServiceOptions {\n\treadonly proxyOptions?: ProxyChannel.ICreateProxyServiceOptions;\n}\n\nfunction isRemoteServiceWithChannelClientOptions<T>(obj: unknown): obj is IRemoteServiceWithChannelClientOptions<T> {\n\tconst candidate = obj as IRemoteServiceWithChannelClientOptions<T> | undefined;\n\n\treturn !!candidate?.channelClientCtor;\n}\n\n//#region Main Process\n\nexport const IMainProcessService = createDecorator<IMainProcessService>('mainProcessService');\n\nexport interface IMainProcessService {\n\treadonly _serviceBrand: undefined;\n\tgetChannel(channelName: string): IChannel;\n\tregisterChannel(channelName: string, channel: IServerChannel<string>): void;\n}\n\nclass MainProcessRemoteServiceStub<T> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @IMainProcessService ipcService: IMainProcessService) {\n\t\tsuper(channelName, options, ipcService);\n\t}\n}\n\nexport function registerMainProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(MainProcessRemoteServiceStub, [channelName, options], options?.supportsDelayedInstantiation));\n}\n\n//#endregion\n\n//#region Shared Process\n\nexport const ISharedProcessService = createDecorator<ISharedProcessService>('sharedProcessService');\n\nexport interface ISharedProcessService {\n\treadonly _serviceBrand: undefined;\n\tgetChannel(channelName: string): IChannel;\n\tregisterChannel(channelName: string, channel: IServerChannel<string>): void;\n}\n\nclass SharedProcessRemoteServiceStub<T> extends RemoteServiceStub<T> {\n\tconstructor(channelName: string, options: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions | undefined, @ISharedProcessService ipcService: ISharedProcessService) {\n\t\tsuper(channelName, options, ipcService);\n\t}\n}\n\nexport function registerSharedProcessRemoteService<T>(id: ServiceIdentifier<T>, channelName: string, options?: IRemoteServiceWithChannelClientOptions<T> | IRemoteServiceWithProxyOptions): void {\n\tregisterSingleton(id, new SyncDescriptor(SharedProcessRemoteServiceStub, [channelName, options], options?.supportsDelayedInstantiation));\n}\n\n//#endregion\n"]}