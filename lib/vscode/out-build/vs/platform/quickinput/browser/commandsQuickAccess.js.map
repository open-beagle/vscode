{"version":3,"sources":["vs/platform/quickinput/browser/commandsQuickAccess.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IA8BhG,IAAsB,mCAAmC,GAAzD,MAAsB,mCAAoC,SAAQ,6CAA4C;QAU7G,YACC,OAAoC,EACI,oBAA2C,EAC9C,iBAAqC,EACxC,cAA+B,EAC7B,gBAAmC,EAChC,mBAAyC;YAEhF,KAAK,CAAC,mCAAmC,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YANnB,yBAAoB,GAApB,oBAAoB,CAAuB;YAC9C,sBAAiB,GAAjB,iBAAiB,CAAoB;YACxC,mBAAc,GAAd,cAAc,CAAiB;YAC7B,qBAAgB,GAAhB,gBAAgB,CAAmB;YAChC,wBAAmB,GAAnB,mBAAmB,CAAsB;YAVhE,oBAAe,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC,CAAC;YAc5G,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACxB,CAAC;QAES,KAAK,CAAC,QAAQ,CAAC,MAAc,EAAE,WAA4B,EAAE,KAAwB;YAE9F,qCAAqC;YACrC,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;YAEvE,IAAI,KAAK,CAAC,uBAAuB,EAAE;gBAClC,OAAO,EAAE,CAAC;aACV;YAED,SAAS;YACT,MAAM,oBAAoB,GAAwB,EAAE,CAAC;YACrD,KAAK,MAAM,WAAW,IAAI,eAAe,EAAE;gBAC1C,MAAM,eAAe,GAAG,CAAA,GAAA,2BAAmB,CAAA,CAAC,mCAAmC,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;gBACxH,MAAM,eAAe,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,CAAA,GAAA,2BAAmB,CAAA,CAAC,mCAAmC,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBAEtK,oCAAoC;gBACpC,IAAI,eAAe,IAAI,eAAe,EAAE;oBACvC,WAAW,CAAC,UAAU,GAAG;wBACxB,KAAK,EAAE,eAAe;wBACtB,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,SAAS;qBAC5D,CAAC;oBAEF,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;iBACvC;gBAED,8CAA8C;qBACzC,IAAI,MAAM,KAAK,WAAW,CAAC,SAAS,EAAE;oBAC1C,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;iBACvC;aACD;YAED,yDAAyD;YACzD,MAAM,iBAAiB,GAAG,IAAI,GAAG,EAA6B,CAAC;YAC/D,KAAK,MAAM,WAAW,IAAI,oBAAoB,EAAE;gBAC/C,MAAM,uBAAuB,GAAG,iBAAiB,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBACzE,IAAI,uBAAuB,EAAE;oBAC5B,WAAW,CAAC,WAAW,GAAG,WAAW,CAAC,SAAS,CAAC;oBAChD,uBAAuB,CAAC,WAAW,GAAG,uBAAuB,CAAC,SAAS,CAAC;iBACxE;qBAAM;oBACN,iBAAiB,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;iBACtD;aACD;YAED,mDAAmD;YACnD,oBAAoB,CAAC,IAAI,CAAC,CAAC,YAAY,EAAE,YAAY,EAAE,EAAE;gBACxD,MAAM,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;gBAC1E,MAAM,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;gBAE1E,IAAI,eAAe,IAAI,eAAe,EAAE;oBACvC,OAAO,eAAe,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,8CAA8C;iBACjG;gBAED,IAAI,eAAe,EAAE;oBACpB,OAAO,CAAC,CAAC,CAAC,CAAC,2DAA2D;iBACtE;gBAED,IAAI,eAAe,EAAE;oBACpB,OAAO,CAAC,CAAC,CAAC,qDAAqD;iBAC/D;gBAED,oDAAoD;gBACpD,OAAO,YAAY,CAAC,KAAK,CAAC,aAAa,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;YAC7D,CAAC,CAAC,CAAC;YAEH,MAAM,YAAY,GAAmD,EAAE,CAAC;YAExE,IAAI,YAAY,GAAG,KAAK,CAAC;YACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACrD,MAAM,WAAW,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;gBAC5C,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;gBAClF,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC;oBAC7B,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAoC,EAAE,IAAU,EAAE,WAAW,CAAC,KAAK,EAAE,UAAU,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;oBAC1G,WAAW,CAAC,KAAK,CAAC;gBAEnB,2BAA2B;gBAC3B,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE;oBAChE,YAAY,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAc,EAAE,IAAe,CAAC,EAAE,CAAC,CAAC;oBAC3F,YAAY,GAAG,IAAI,CAAC;iBACpB;gBAED,4BAA4B;gBAC5B,IAAI,CAAC,KAAK,CAAC,IAAI,YAAY,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE;oBACjF,YAAY,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAe,EAAE,IAAgB,CAAC,EAAE,CAAC,CAAC;oBAC7F,YAAY,GAAG,KAAK,CAAC,CAAC,YAAY;iBAClC;gBAED,UAAU;gBACV,YAAY,CAAC,IAAI,iCACb,WAAW,KACd,SAAS,EACT,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS,IAAI,WAAW,CAAC,YAAY,KAAK,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,EACvH,UAAU,EACV,MAAM,EAAE,KAAK,IAAI,EAAE;wBAElB,iBAAiB;wBACjB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;wBAEjD,aAAa;wBACb,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAsE,yBAAyB,EAAE;4BAChI,EAAE,EAAE,WAAW,CAAC,SAAS;4BACzB,IAAI,EAAE,YAAY;yBAClB,CAAC,CAAC;wBAEH,MAAM;wBACN,IAAI;4BACH,MAAM,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;yBAChE;wBAAC,OAAO,KAAK,EAAE;4BACf,IAAI,CAAC,CAAA,GAAA,+BAAsB,CAAA,CAAC,KAAK,CAAC,EAAE;gCACnC,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAW,EAAE,IAA0C,EAAE,WAAW,CAAC,KAAK,EAAE,CAAA,GAAA,6BAAc,CAAA,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;6BAC5I;yBACD;oBACF,CAAC,IACA,CAAC;aACH;YAED,OAAO,YAAY,CAAC;QACrB,CAAC;KAMD,CAAA;IA/IO,0CAAM,GAAG,GAAG,CAAC;IAEL,+CAAW,GAAG,CAAA,GAAA,YAAE,CAAA,CAAC,uBAAa,EAAE,sBAAY,EAAE,oCAA0B,CAAC,CAAC;IAJpE,mCAAmC;QAYtD,WAAA,qCAAqB,CAAA;QACrB,WAAA,+BAAkB,CAAA;QAClB,WAAA,0BAAe,CAAA;QACf,WAAA,6BAAiB,CAAA;QACjB,WAAA,mCAAoB,CAAA;OAhBD,mCAAmC,CAiJxD;IAjJqB,kFAAmC;IAiKzD,IAAa,eAAe,GAA5B,MAAa,eAAgB,SAAQ,sBAAU;QAY9C,YACmC,cAA+B,EACzB,oBAA2C;YAEnF,KAAK,EAAE,CAAC;YAH0B,mBAAc,GAAd,cAAc,CAAiB;YACzB,yBAAoB,GAApB,oBAAoB,CAAuB;YAJ5E,oCAA+B,GAAG,CAAC,CAAC;YAQ3C,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC3B,IAAI,CAAC,IAAI,EAAE,CAAC;YAEZ,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC1B,CAAC;QAEO,iBAAiB;YACxB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,oBAAoB,CAAC,wBAAwB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC,CAAC;QACtG,CAAC;QAEO,mBAAmB;YAC1B,IAAI,CAAC,+BAA+B,GAAG,eAAe,CAAC,iCAAiC,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAEpH,IAAI,eAAe,CAAC,KAAK,IAAI,eAAe,CAAC,KAAK,CAAC,KAAK,KAAK,IAAI,CAAC,+BAA+B,EAAE;gBAClG,eAAe,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,+BAA+B,CAAC;gBAEnE,eAAe,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;aAC/C;QACF,CAAC;QAEO,IAAI;YACX,MAAM,GAAG,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,cAAc,iBAAsB,CAAC;YACzF,IAAI,eAAsD,CAAC;YAC3D,IAAI,GAAG,EAAE;gBACR,IAAI;oBACH,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBAClC;gBAAC,OAAO,KAAK,EAAE;oBACf,eAAe;iBACf;aACD;YAED,MAAM,KAAK,GAAG,eAAe,CAAC,KAAK,GAAG,IAAI,cAAQ,CAAiB,IAAI,CAAC,+BAA+B,EAAE,CAAC,CAAC,CAAC;YAC5G,IAAI,eAAe,EAAE;gBACpB,IAAI,OAAyC,CAAC;gBAC9C,IAAI,eAAe,CAAC,OAAO,EAAE;oBAC5B,OAAO,GAAG,eAAe,CAAC,OAAO,CAAC;iBAClC;qBAAM;oBACN,OAAO,GAAG,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;iBACpE;gBACD,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;aAC5D;YAED,eAAe,CAAC,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,eAAe,CAAC,gBAAgB,kBAAuB,eAAe,CAAC,OAAO,CAAC,CAAC;QACzI,CAAC;QAED,IAAI,CAAC,SAAiB;YACrB,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;gBAC3B,OAAO;aACP;YAED,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,eAAe,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,yBAAyB;YAE1F,eAAe,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAChD,CAAC;QAED,IAAI,CAAC,SAAiB;;YACrB,OAAO,MAAA,eAAe,CAAC,KAAK,0CAAE,IAAI,CAAC,SAAS,CAAC,CAAC;QAC/C,CAAC;QAED,MAAM,CAAC,SAAS,CAAC,cAA+B;YAC/C,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;gBAC3B,OAAO;aACP;YAED,MAAM,eAAe,GAA8B,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC;YAClF,eAAe,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CAAC,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;YAE5F,cAAc,CAAC,KAAK,CAAC,eAAe,CAAC,cAAc,EAAE,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,+BAA0C,CAAC;YAC/H,cAAc,CAAC,KAAK,CAAC,eAAe,CAAC,gBAAgB,EAAE,eAAe,CAAC,OAAO,+BAA0C,CAAC;QAC1H,CAAC;QAED,MAAM,CAAC,iCAAiC,CAAC,oBAA2C;;YACnF,MAAM,MAAM,GAAsC,oBAAoB,CAAC,QAAQ,EAAE,CAAC;YAElF,MAAM,8BAA8B,GAAG,MAAA,MAAA,MAAM,CAAC,SAAS,0CAAE,cAAc,0CAAE,OAAO,CAAC;YACjF,IAAI,OAAO,8BAA8B,KAAK,QAAQ,EAAE;gBACvD,OAAO,8BAA8B,CAAC;aACtC;YAED,OAAO,eAAe,CAAC,+BAA+B,CAAC;QACxD,CAAC;QAED,MAAM,CAAC,YAAY,CAAC,oBAA2C,EAAE,cAA+B;YAC/F,MAAM,oBAAoB,GAAG,eAAe,CAAC,iCAAiC,CAAC,oBAAoB,CAAC,CAAC;YACrG,eAAe,CAAC,KAAK,GAAG,IAAI,cAAQ,CAAiB,oBAAoB,CAAC,CAAC;YAC3E,eAAe,CAAC,OAAO,GAAG,CAAC,CAAC;YAE5B,eAAe,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;QAC3C,CAAC;KACD,CAAA;IAzGgB,+CAA+B,GAAG,EAAE,CAAC;IAE7B,8BAAc,GAAG,0BAA0B,CAAC;IAC5C,gCAAgB,GAAG,4BAA4B,CAAC;IAGzD,uBAAO,GAAG,CAAC,CAAC;IARf,eAAe;QAazB,WAAA,yBAAe,CAAA;QACf,WAAA,qCAAqB,CAAA;OAdX,eAAe,CA2G3B;IA3GY,0CAAe","file":"commandsQuickAccess.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { IQuickPickSeparator } from 'vs/platform/quickinput/common/quickInput';\nimport { PickerQuickAccessProvider, IPickerQuickAccessItem, IPickerQuickAccessProviderOptions } from 'vs/platform/quickinput/browser/pickerQuickAccess';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { DisposableStore, Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { or, matchesPrefix, matchesWords, matchesContiguousSubString } from 'vs/base/common/filters';\nimport { withNullAsUndefined } from 'vs/base/common/types';\nimport { LRUCache } from 'vs/base/common/map';\nimport { IStorageService, StorageScope, StorageTarget } from 'vs/platform/storage/common/storage';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { IKeybindingService } from 'vs/platform/keybinding/common/keybinding';\nimport { ICommandService } from 'vs/platform/commands/common/commands';\nimport { WorkbenchActionExecutedEvent, WorkbenchActionExecutedClassification } from 'vs/base/common/actions';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { isPromiseCanceledError } from 'vs/base/common/errors';\nimport { INotificationService } from 'vs/platform/notification/common/notification';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\n\nexport interface ICommandQuickPick extends IPickerQuickAccessItem {\n\tcommandId: string;\n\tcommandAlias?: string;\n}\n\nexport interface ICommandsQuickAccessOptions extends IPickerQuickAccessProviderOptions<ICommandQuickPick> {\n\tshowAlias: boolean;\n}\n\nexport abstract class AbstractCommandsQuickAccessProvider extends PickerQuickAccessProvider<ICommandQuickPick> implements IDisposable {\n\n\tstatic PREFIX = '>';\n\n\tprivate static WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);\n\n\tprivate readonly commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));\n\n\tprotected override readonly options: ICommandsQuickAccessOptions;\n\n\tconstructor(\n\t\toptions: ICommandsQuickAccessOptions,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IKeybindingService private readonly keybindingService: IKeybindingService,\n\t\t@ICommandService private readonly commandService: ICommandService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@INotificationService private readonly notificationService: INotificationService\n\t) {\n\t\tsuper(AbstractCommandsQuickAccessProvider.PREFIX, options);\n\n\t\tthis.options = options;\n\t}\n\n\tprotected async getPicks(filter: string, disposables: DisposableStore, token: CancellationToken): Promise<Array<ICommandQuickPick | IQuickPickSeparator>> {\n\n\t\t// Ask subclass for all command picks\n\t\tconst allCommandPicks = await this.getCommandPicks(disposables, token);\n\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Filter\n\t\tconst filteredCommandPicks: ICommandQuickPick[] = [];\n\t\tfor (const commandPick of allCommandPicks) {\n\t\t\tconst labelHighlights = withNullAsUndefined(AbstractCommandsQuickAccessProvider.WORD_FILTER(filter, commandPick.label));\n\t\t\tconst aliasHighlights = commandPick.commandAlias ? withNullAsUndefined(AbstractCommandsQuickAccessProvider.WORD_FILTER(filter, commandPick.commandAlias)) : undefined;\n\n\t\t\t// Add if matching in label or alias\n\t\t\tif (labelHighlights || aliasHighlights) {\n\t\t\t\tcommandPick.highlights = {\n\t\t\t\t\tlabel: labelHighlights,\n\t\t\t\t\tdetail: this.options.showAlias ? aliasHighlights : undefined\n\t\t\t\t};\n\n\t\t\t\tfilteredCommandPicks.push(commandPick);\n\t\t\t}\n\n\t\t\t// Also add if we have a 100% command ID match\n\t\t\telse if (filter === commandPick.commandId) {\n\t\t\t\tfilteredCommandPicks.push(commandPick);\n\t\t\t}\n\t\t}\n\n\t\t// Add description to commands that have duplicate labels\n\t\tconst mapLabelToCommand = new Map<string, ICommandQuickPick>();\n\t\tfor (const commandPick of filteredCommandPicks) {\n\t\t\tconst existingCommandForLabel = mapLabelToCommand.get(commandPick.label);\n\t\t\tif (existingCommandForLabel) {\n\t\t\t\tcommandPick.description = commandPick.commandId;\n\t\t\t\texistingCommandForLabel.description = existingCommandForLabel.commandId;\n\t\t\t} else {\n\t\t\t\tmapLabelToCommand.set(commandPick.label, commandPick);\n\t\t\t}\n\t\t}\n\n\t\t// Sort by MRU order and fallback to name otherwise\n\t\tfilteredCommandPicks.sort((commandPickA, commandPickB) => {\n\t\t\tconst commandACounter = this.commandsHistory.peek(commandPickA.commandId);\n\t\t\tconst commandBCounter = this.commandsHistory.peek(commandPickB.commandId);\n\n\t\t\tif (commandACounter && commandBCounter) {\n\t\t\t\treturn commandACounter > commandBCounter ? -1 : 1; // use more recently used command before older\n\t\t\t}\n\n\t\t\tif (commandACounter) {\n\t\t\t\treturn -1; // first command was used, so it wins over the non used one\n\t\t\t}\n\n\t\t\tif (commandBCounter) {\n\t\t\t\treturn 1; // other command was used so it wins over the command\n\t\t\t}\n\n\t\t\t// both commands were never used, so we sort by name\n\t\t\treturn commandPickA.label.localeCompare(commandPickB.label);\n\t\t});\n\n\t\tconst commandPicks: Array<ICommandQuickPick | IQuickPickSeparator> = [];\n\n\t\tlet addSeparator = false;\n\t\tfor (let i = 0; i < filteredCommandPicks.length; i++) {\n\t\t\tconst commandPick = filteredCommandPicks[i];\n\t\t\tconst keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);\n\t\t\tconst ariaLabel = keybinding ?\n\t\t\t\tlocalize('commandPickAriaLabelWithKeybinding', \"{0}, {1}\", commandPick.label, keybinding.getAriaLabel()) :\n\t\t\t\tcommandPick.label;\n\n\t\t\t// Separator: recently used\n\t\t\tif (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {\n\t\t\t\tcommandPicks.push({ type: 'separator', label: localize('recentlyUsed', \"recently used\") });\n\t\t\t\taddSeparator = true;\n\t\t\t}\n\n\t\t\t// Separator: other commands\n\t\t\tif (i !== 0 && addSeparator && !this.commandsHistory.peek(commandPick.commandId)) {\n\t\t\t\tcommandPicks.push({ type: 'separator', label: localize('morecCommands', \"other commands\") });\n\t\t\t\taddSeparator = false; // only once\n\t\t\t}\n\n\t\t\t// Command\n\t\t\tcommandPicks.push({\n\t\t\t\t...commandPick,\n\t\t\t\tariaLabel,\n\t\t\t\tdetail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : undefined,\n\t\t\t\tkeybinding,\n\t\t\t\taccept: async () => {\n\n\t\t\t\t\t// Add to history\n\t\t\t\t\tthis.commandsHistory.push(commandPick.commandId);\n\n\t\t\t\t\t// Telementry\n\t\t\t\t\tthis.telemetryService.publicLog2<WorkbenchActionExecutedEvent, WorkbenchActionExecutedClassification>('workbenchActionExecuted', {\n\t\t\t\t\t\tid: commandPick.commandId,\n\t\t\t\t\t\tfrom: 'quick open'\n\t\t\t\t\t});\n\n\t\t\t\t\t// Run\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.commandService.executeCommand(commandPick.commandId);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (!isPromiseCanceledError(error)) {\n\t\t\t\t\t\t\tthis.notificationService.error(localize('canNotRun', \"Command '{0}' resulted in an error ({1})\", commandPick.label, toErrorMessage(error)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn commandPicks;\n\t}\n\n\t/**\n\t * Subclasses to provide the actual command entries.\n\t */\n\tprotected abstract getCommandPicks(disposables: DisposableStore, token: CancellationToken): Promise<Array<ICommandQuickPick>>;\n}\n\ninterface ISerializedCommandHistory {\n\tusesLRU?: boolean;\n\tentries: { key: string; value: number }[];\n}\n\ninterface ICommandsQuickAccessConfiguration {\n\tworkbench: {\n\t\tcommandPalette: {\n\t\t\thistory: number;\n\t\t\tpreserveInput: boolean;\n\t\t}\n\t};\n}\n\nexport class CommandsHistory extends Disposable {\n\n\tstatic readonly DEFAULT_COMMANDS_HISTORY_LENGTH = 50;\n\n\tprivate static readonly PREF_KEY_CACHE = 'commandPalette.mru.cache';\n\tprivate static readonly PREF_KEY_COUNTER = 'commandPalette.mru.counter';\n\n\tprivate static cache: LRUCache<string, number> | undefined;\n\tprivate static counter = 1;\n\n\tprivate configuredCommandsHistoryLength = 0;\n\n\tconstructor(\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\n\t\tthis.updateConfiguration();\n\t\tthis.load();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(() => this.updateConfiguration()));\n\t}\n\n\tprivate updateConfiguration(): void {\n\t\tthis.configuredCommandsHistoryLength = CommandsHistory.getConfiguredCommandHistoryLength(this.configurationService);\n\n\t\tif (CommandsHistory.cache && CommandsHistory.cache.limit !== this.configuredCommandsHistoryLength) {\n\t\t\tCommandsHistory.cache.limit = this.configuredCommandsHistoryLength;\n\n\t\t\tCommandsHistory.saveState(this.storageService);\n\t\t}\n\t}\n\n\tprivate load(): void {\n\t\tconst raw = this.storageService.get(CommandsHistory.PREF_KEY_CACHE, StorageScope.GLOBAL);\n\t\tlet serializedCache: ISerializedCommandHistory | undefined;\n\t\tif (raw) {\n\t\t\ttry {\n\t\t\t\tserializedCache = JSON.parse(raw);\n\t\t\t} catch (error) {\n\t\t\t\t// invalid data\n\t\t\t}\n\t\t}\n\n\t\tconst cache = CommandsHistory.cache = new LRUCache<string, number>(this.configuredCommandsHistoryLength, 1);\n\t\tif (serializedCache) {\n\t\t\tlet entries: { key: string; value: number }[];\n\t\t\tif (serializedCache.usesLRU) {\n\t\t\t\tentries = serializedCache.entries;\n\t\t\t} else {\n\t\t\t\tentries = serializedCache.entries.sort((a, b) => a.value - b.value);\n\t\t\t}\n\t\t\tentries.forEach(entry => cache.set(entry.key, entry.value));\n\t\t}\n\n\t\tCommandsHistory.counter = this.storageService.getNumber(CommandsHistory.PREF_KEY_COUNTER, StorageScope.GLOBAL, CommandsHistory.counter);\n\t}\n\n\tpush(commandId: string): void {\n\t\tif (!CommandsHistory.cache) {\n\t\t\treturn;\n\t\t}\n\n\t\tCommandsHistory.cache.set(commandId, CommandsHistory.counter++); // set counter to command\n\n\t\tCommandsHistory.saveState(this.storageService);\n\t}\n\n\tpeek(commandId: string): number | undefined {\n\t\treturn CommandsHistory.cache?.peek(commandId);\n\t}\n\n\tstatic saveState(storageService: IStorageService): void {\n\t\tif (!CommandsHistory.cache) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst serializedCache: ISerializedCommandHistory = { usesLRU: true, entries: [] };\n\t\tCommandsHistory.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));\n\n\t\tstorageService.store(CommandsHistory.PREF_KEY_CACHE, JSON.stringify(serializedCache), StorageScope.GLOBAL, StorageTarget.USER);\n\t\tstorageService.store(CommandsHistory.PREF_KEY_COUNTER, CommandsHistory.counter, StorageScope.GLOBAL, StorageTarget.USER);\n\t}\n\n\tstatic getConfiguredCommandHistoryLength(configurationService: IConfigurationService): number {\n\t\tconst config = <ICommandsQuickAccessConfiguration>configurationService.getValue();\n\n\t\tconst configuredCommandHistoryLength = config.workbench?.commandPalette?.history;\n\t\tif (typeof configuredCommandHistoryLength === 'number') {\n\t\t\treturn configuredCommandHistoryLength;\n\t\t}\n\n\t\treturn CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH;\n\t}\n\n\tstatic clearHistory(configurationService: IConfigurationService, storageService: IStorageService): void {\n\t\tconst commandHistoryLength = CommandsHistory.getConfiguredCommandHistoryLength(configurationService);\n\t\tCommandsHistory.cache = new LRUCache<string, number>(commandHistoryLength);\n\t\tCommandsHistory.counter = 1;\n\n\t\tCommandsHistory.saveState(storageService);\n\t}\n}\n\n"]}