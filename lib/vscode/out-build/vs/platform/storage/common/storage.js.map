{"version":3,"file":"storage.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/storage/common/storage.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { Event, Emitter, PauseableEmitter } from 'vs/base/common/event';\nimport { Disposable, dispose, MutableDisposable } from 'vs/base/common/lifecycle';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\nimport { IWorkspaceInitializationPayload } from 'vs/platform/workspaces/common/workspaces';\nimport { InMemoryStorageDatabase, IStorage, Storage } from 'vs/base/parts/storage/common/storage';\nimport { Promises, RunOnceScheduler, runWhenIdle } from 'vs/base/common/async';\n\nexport const IS_NEW_KEY = '__$__isNewStorageMarker';\nconst TARGET_KEY = '__$__targetStorageMarker';\n\nexport const IStorageService = createDecorator<IStorageService>('storageService');\n\nexport enum WillSaveStateReason {\n\n\t/**\n\t * No specific reason to save state.\n\t */\n\tNONE,\n\n\t/**\n\t * A hint that the workbench is about to shutdown.\n\t */\n\tSHUTDOWN\n}\n\nexport interface IWillSaveStateEvent {\n\treason: WillSaveStateReason;\n}\n\nexport interface IStorageService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted whenever data is updated or deleted.\n\t */\n\treadonly onDidChangeValue: Event<IStorageValueChangeEvent>;\n\n\t/**\n\t * Emitted whenever target of a storage entry changes.\n\t */\n\treadonly onDidChangeTarget: Event<IStorageTargetChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is about to persist. This is the right time\n\t * to persist data to ensure it is stored before the application shuts\n\t * down.\n\t *\n\t * The will save state event allows to optionally ask for the reason of\n\t * saving the state, e.g. to find out if the state is saved due to a\n\t * shutdown.\n\t *\n\t * Note: this event may be fired many times, not only on shutdown to prevent\n\t * loss of state in situations where the shutdown is not sufficient to\n\t * persist the data properly.\n\t */\n\treadonly onWillSaveState: Event<IWillSaveStateEvent>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only or all workspaces.\n\t */\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `boolean`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only or all workspaces.\n\t */\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided `defaultValue` if the element is `null` or `undefined`.\n\t * The element will be converted to a `number` using `parseInt` with a\n\t * base of `10`.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only or all workspaces.\n\t */\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;\n\n\t/**\n\t * Store a value under the given key to storage. The value will be\n\t * converted to a `string`. Storing either `undefined` or `null` will\n\t * remove the entry under the key.\n\t *\n\t * @param scope allows to define the scope of the storage operation\n\t * to either the current workspace only or all workspaces.\n\t *\n\t * @param target allows to define the target of the storage operation\n\t * to either the current machine or user.\n\t */\n\tstore(key: string, value: string | boolean | number | undefined | null, scope: StorageScope, target: StorageTarget): Promise<void> | void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only or all workspaces.\n\t */\n\tremove(key: string, scope: StorageScope): void;\n\n\t/**\n\t * Returns all the keys used in the storage for the provided `scope`\n\t * and `target`.\n\t *\n\t * Note: this will NOT return all keys stored in the storage layer.\n\t * Some keys may not have an associated `StorageTarget` and thus\n\t * will be excluded from the results.\n\t *\n\t * @param scope allows to define the scope for the keys\n\t * to either the current workspace only or all workspaces.\n\t *\n\t * @param target allows to define the target for the keys\n\t * to either the current machine or user.\n\t */\n\tkeys(scope: StorageScope, target: StorageTarget): string[];\n\n\t/**\n\t * Log the contents of the storage to the console.\n\t */\n\tlogStorage(): void;\n\n\t/**\n\t * Migrate the storage contents to another workspace.\n\t */\n\tmigrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void>;\n\n\t/**\n\t * Whether the storage for the given scope was created during this session or\n\t * existed before.\n\t */\n\tisNew(scope: StorageScope): boolean;\n\n\t/**\n\t * Allows to flush state, e.g. in cases where a shutdown is\n\t * imminent. This will send out the `onWillSaveState` to ask\n\t * everyone for latest state.\n\t *\n\t * @returns a `Promise` that can be awaited on when all updates\n\t * to the underlying storage have been flushed.\n\t */\n\tflush(): Promise<void>;\n}\n\nexport const enum StorageScope {\n\n\t/**\n\t * The stored data will be scoped to all workspaces.\n\t */\n\tGLOBAL,\n\n\t/**\n\t * The stored data will be scoped to the current workspace.\n\t */\n\tWORKSPACE\n}\n\nexport const enum StorageTarget {\n\n\t/**\n\t * The stored data is user specific and applies across machines.\n\t */\n\tUSER,\n\n\t/**\n\t * The stored data is machine specific.\n\t */\n\tMACHINE\n}\n\nexport interface IStorageValueChangeEvent {\n\n\t/**\n\t * The scope for the storage entry that changed\n\t * or was removed.\n\t */\n\treadonly scope: StorageScope;\n\n\t/**\n\t * The `key` of the storage entry that was changed\n\t * or was removed.\n\t */\n\treadonly key: string;\n\n\t/**\n\t * The `target` can be `undefined` if a key is being\n\t * removed.\n\t */\n\treadonly target: StorageTarget | undefined;\n}\n\nexport interface IStorageTargetChangeEvent {\n\n\t/**\n\t * The scope for the target that changed. Listeners\n\t * should use `keys(scope, target)` to get an updated\n\t * list of keys for the given `scope` and `target`.\n\t */\n\treadonly scope: StorageScope;\n}\n\ninterface IKeyTargets {\n\t[key: string]: StorageTarget\n}\n\nexport interface IStorageServiceOptions {\n\tflushInterval: number;\n}\n\nexport abstract class AbstractStorageService extends Disposable implements IStorageService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate static DEFAULT_FLUSH_INTERVAL = 60 * 1000; // every minute\n\n\tprivate readonly _onDidChangeValue = this._register(new PauseableEmitter<IStorageValueChangeEvent>());\n\treadonly onDidChangeValue = this._onDidChangeValue.event;\n\n\tprivate readonly _onDidChangeTarget = this._register(new PauseableEmitter<IStorageTargetChangeEvent>());\n\treadonly onDidChangeTarget = this._onDidChangeTarget.event;\n\n\tprivate readonly _onWillSaveState = this._register(new Emitter<IWillSaveStateEvent>());\n\treadonly onWillSaveState = this._onWillSaveState.event;\n\n\tprivate initializationPromise: Promise<void> | undefined;\n\n\tprivate readonly flushWhenIdleScheduler = this._register(new RunOnceScheduler(() => this.doFlushWhenIdle(), this.options.flushInterval));\n\tprivate readonly runFlushWhenIdle = this._register(new MutableDisposable());\n\n\tconstructor(private options: IStorageServiceOptions = { flushInterval: AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {\n\t\tsuper();\n\t}\n\n\tprivate doFlushWhenIdle(): void {\n\t\tthis.runFlushWhenIdle.value = runWhenIdle(() => {\n\t\t\tif (this.shouldFlushWhenIdle()) {\n\t\t\t\tthis.flush();\n\t\t\t}\n\n\t\t\t// repeat\n\t\t\tthis.flushWhenIdleScheduler.schedule();\n\t\t});\n\t}\n\n\tprotected shouldFlushWhenIdle(): boolean {\n\t\treturn true;\n\t}\n\n\tprotected stopFlushWhenIdle(): void {\n\t\tdispose([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);\n\t}\n\n\tinitialize(): Promise<void> {\n\t\tif (!this.initializationPromise) {\n\t\t\tthis.initializationPromise = (async () => {\n\n\t\t\t\t// Ask subclasses to initialize storage\n\t\t\t\tawait this.doInitialize();\n\n\t\t\t\t// On some OS we do not get enough time to persist state on shutdown (e.g. when\n\t\t\t\t// Windows restarts after applying updates). In other cases, VSCode might crash,\n\t\t\t\t// so we periodically save state to reduce the chance of loosing any state.\n\t\t\t\t// In the browser we do not have support for long running unload sequences. As such,\n\t\t\t\t// we cannot ask for saving state in that moment, because that would result in a\n\t\t\t\t// long running operation.\n\t\t\t\t// Instead, periodically ask customers to save save. The library will be clever enough\n\t\t\t\t// to only save state that has actually changed.\n\t\t\t\tthis.flushWhenIdleScheduler.schedule();\n\t\t\t})();\n\t\t}\n\n\t\treturn this.initializationPromise;\n\t}\n\n\tprotected emitDidChangeValue(scope: StorageScope, key: string): void {\n\n\t\t// Specially handle `TARGET_KEY`\n\t\tif (key === TARGET_KEY) {\n\n\t\t\t// Clear our cached version which is now out of date\n\t\t\tif (scope === StorageScope.GLOBAL) {\n\t\t\t\tthis._globalKeyTargets = undefined;\n\t\t\t} else if (scope === StorageScope.WORKSPACE) {\n\t\t\t\tthis._workspaceKeyTargets = undefined;\n\t\t\t}\n\n\t\t\t// Emit as `didChangeTarget` event\n\t\t\tthis._onDidChangeTarget.fire({ scope });\n\t\t}\n\n\t\t// Emit any other key to outside\n\t\telse {\n\t\t\tthis._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key] });\n\t\t}\n\t}\n\n\tprotected emitWillSaveState(reason: WillSaveStateReason): void {\n\t\tthis._onWillSaveState.fire({ reason });\n\t}\n\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope): string | undefined;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined {\n\t\treturn this.getStorage(scope)?.get(key, fallbackValue);\n\t}\n\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope): boolean | undefined;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined {\n\t\treturn this.getStorage(scope)?.getBoolean(key, fallbackValue);\n\t}\n\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope): number | undefined;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined {\n\t\treturn this.getStorage(scope)?.getNumber(key, fallbackValue);\n\t}\n\n\tstore(key: string, value: string | boolean | number | undefined | null, scope: StorageScope, target: StorageTarget): void {\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tthis.remove(key, scope);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, target);\n\n\t\t\t// Store actual value\n\t\t\tthis.getStorage(scope)?.set(key, value);\n\t\t});\n\t}\n\n\tremove(key: string, scope: StorageScope): void {\n\n\t\t// Update our datastructures but send events only after\n\t\tthis.withPausedEmitters(() => {\n\n\t\t\t// Update key-target map\n\t\t\tthis.updateKeyTarget(key, scope, undefined);\n\n\t\t\t// Remove actual key\n\t\t\tthis.getStorage(scope)?.delete(key);\n\t\t});\n\t}\n\n\tprivate withPausedEmitters(fn: Function): void {\n\n\t\t// Pause emitters\n\t\tthis._onDidChangeValue.pause();\n\t\tthis._onDidChangeTarget.pause();\n\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\n\t\t\t// Resume emitters\n\t\t\tthis._onDidChangeValue.resume();\n\t\t\tthis._onDidChangeTarget.resume();\n\t\t}\n\t}\n\n\tkeys(scope: StorageScope, target: StorageTarget): string[] {\n\t\tconst keys: string[] = [];\n\n\t\tconst keyTargets = this.getKeyTargets(scope);\n\t\tfor (const key of Object.keys(keyTargets)) {\n\t\t\tconst keyTarget = keyTargets[key];\n\t\t\tif (keyTarget === target) {\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\tprivate updateKeyTarget(key: string, scope: StorageScope, target: StorageTarget | undefined): void {\n\n\t\t// Add\n\t\tconst keyTargets = this.getKeyTargets(scope);\n\t\tif (typeof target === 'number') {\n\t\t\tif (keyTargets[key] !== target) {\n\t\t\t\tkeyTargets[key] = target;\n\t\t\t\tthis.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets));\n\t\t\t}\n\t\t}\n\n\t\t// Remove\n\t\telse {\n\t\t\tif (typeof keyTargets[key] === 'number') {\n\t\t\t\tdelete keyTargets[key];\n\t\t\t\tthis.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _workspaceKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get workspaceKeyTargets(): IKeyTargets {\n\t\tif (!this._workspaceKeyTargets) {\n\t\t\tthis._workspaceKeyTargets = this.loadKeyTargets(StorageScope.WORKSPACE);\n\t\t}\n\n\t\treturn this._workspaceKeyTargets;\n\t}\n\n\tprivate _globalKeyTargets: IKeyTargets | undefined = undefined;\n\tprivate get globalKeyTargets(): IKeyTargets {\n\t\tif (!this._globalKeyTargets) {\n\t\t\tthis._globalKeyTargets = this.loadKeyTargets(StorageScope.GLOBAL);\n\t\t}\n\n\t\treturn this._globalKeyTargets;\n\t}\n\n\tprivate getKeyTargets(scope: StorageScope): IKeyTargets {\n\t\treturn scope === StorageScope.GLOBAL ? this.globalKeyTargets : this.workspaceKeyTargets;\n\t}\n\n\tprivate loadKeyTargets(scope: StorageScope): { [key: string]: StorageTarget } {\n\t\tconst keysRaw = this.get(TARGET_KEY, scope);\n\t\tif (keysRaw) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(keysRaw);\n\t\t\t} catch (error) {\n\t\t\t\t// Fail gracefully\n\t\t\t}\n\t\t}\n\n\t\treturn Object.create(null);\n\t}\n\n\tisNew(scope: StorageScope): boolean {\n\t\treturn this.getBoolean(IS_NEW_KEY, scope) === true;\n\t}\n\n\tasync flush(): Promise<void> {\n\n\t\t// Signal event to collect changes\n\t\tthis._onWillSaveState.fire({ reason: WillSaveStateReason.NONE });\n\n\t\t// Await flush\n\t\tawait Promises.settled([\n\t\t\tthis.getStorage(StorageScope.GLOBAL)?.whenFlushed() ?? Promise.resolve(),\n\t\t\tthis.getStorage(StorageScope.WORKSPACE)?.whenFlushed() ?? Promise.resolve()\n\t\t]);\n\t}\n\n\tasync logStorage(): Promise<void> {\n\t\tconst globalItems = this.getStorage(StorageScope.GLOBAL)?.items ?? new Map<string, string>();\n\t\tconst workspaceItems = this.getStorage(StorageScope.WORKSPACE)?.items ?? new Map<string, string>();\n\n\t\treturn logStorage(\n\t\t\tglobalItems,\n\t\t\tworkspaceItems,\n\t\t\tthis.getLogDetails(StorageScope.GLOBAL) ?? '',\n\t\t\tthis.getLogDetails(StorageScope.WORKSPACE) ?? ''\n\t\t);\n\t}\n\n\t// --- abstract\n\n\tprotected abstract doInitialize(): Promise<void>;\n\n\tprotected abstract getStorage(scope: StorageScope): IStorage | undefined;\n\n\tprotected abstract getLogDetails(scope: StorageScope): string | undefined;\n\n\tabstract migrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void>;\n}\n\nexport class InMemoryStorageService extends AbstractStorageService {\n\n\tprivate globalStorage = new Storage(new InMemoryStorageDatabase());\n\tprivate workspaceStorage = new Storage(new InMemoryStorageDatabase());\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._register(this.workspaceStorage.onDidChangeStorage(key => this.emitDidChangeValue(StorageScope.WORKSPACE, key)));\n\t\tthis._register(this.globalStorage.onDidChangeStorage(key => this.emitDidChangeValue(StorageScope.GLOBAL, key)));\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage {\n\t\treturn scope === StorageScope.GLOBAL ? this.globalStorage : this.workspaceStorage;\n\t}\n\n\tprotected getLogDetails(scope: StorageScope): string | undefined {\n\t\treturn scope === StorageScope.GLOBAL ? 'inMemory (global)' : 'inMemory (workspace)';\n\t}\n\n\tprotected async doInitialize(): Promise<void> { }\n\n\tasync migrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void> {\n\t\t// not supported\n\t}\n}\n\nexport async function logStorage(global: Map<string, string>, workspace: Map<string, string>, globalPath: string, workspacePath: string): Promise<void> {\n\tconst safeParse = (value: string) => {\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (error) {\n\t\t\treturn value;\n\t\t}\n\t};\n\n\tconst globalItems = new Map<string, string>();\n\tconst globalItemsParsed = new Map<string, string>();\n\tglobal.forEach((value, key) => {\n\t\tglobalItems.set(key, value);\n\t\tglobalItemsParsed.set(key, safeParse(value));\n\t});\n\n\tconst workspaceItems = new Map<string, string>();\n\tconst workspaceItemsParsed = new Map<string, string>();\n\tworkspace.forEach((value, key) => {\n\t\tworkspaceItems.set(key, value);\n\t\tworkspaceItemsParsed.set(key, safeParse(value));\n\t});\n\n\tconsole.group(`Storage: Global (path: ${globalPath})`);\n\tlet globalValues: { key: string, value: string }[] = [];\n\tglobalItems.forEach((value, key) => {\n\t\tglobalValues.push({ key, value });\n\t});\n\tconsole.table(globalValues);\n\tconsole.groupEnd();\n\n\tconsole.log(globalItemsParsed);\n\n\tconsole.group(`Storage: Workspace (path: ${workspacePath})`);\n\tlet workspaceValues: { key: string, value: string }[] = [];\n\tworkspaceItems.forEach((value, key) => {\n\t\tworkspaceValues.push({ key, value });\n\t});\n\tconsole.table(workspaceValues);\n\tconsole.groupEnd();\n\n\tconsole.log(workspaceItemsParsed);\n}\n"]}