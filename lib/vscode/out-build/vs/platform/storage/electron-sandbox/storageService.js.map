{"version":3,"file":"storageService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/storage/electron-sandbox/storageService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { MutableDisposable } from 'vs/base/common/lifecycle';\nimport { StorageScope, WillSaveStateReason, AbstractStorageService } from 'vs/platform/storage/common/storage';\nimport { Storage, IStorage } from 'vs/base/parts/storage/common/storage';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { IEmptyWorkspaceIdentifier, ISingleFolderWorkspaceIdentifier, IWorkspaceIdentifier, IWorkspaceInitializationPayload } from 'vs/platform/workspaces/common/workspaces';\nimport { Promises } from 'vs/base/common/async';\nimport { mark } from 'vs/base/common/performance';\nimport { IMainProcessService } from 'vs/platform/ipc/electron-sandbox/services';\nimport { StorageDatabaseChannelClient } from 'vs/platform/storage/common/storageIpc';\nimport { joinPath } from 'vs/base/common/resources';\n\nexport class NativeStorageService extends AbstractStorageService {\n\n\t// Global Storage is readonly and shared across windows\n\tprivate readonly globalStorage: IStorage;\n\n\t// Workspace Storage is scoped to a window but can change\n\t// in the current window, when entering a workspace!\n\tprivate workspaceStorage: IStorage | undefined = undefined;\n\tprivate workspaceStorageId: string | undefined = undefined;\n\tprivate workspaceStorageDisposable = this._register(new MutableDisposable());\n\n\tconstructor(\n\t\tworkspace: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier | undefined,\n\t\tprivate readonly mainProcessService: IMainProcessService,\n\t\tprivate readonly environmentService: IEnvironmentService\n\t) {\n\t\tsuper();\n\n\t\tthis.globalStorage = this.createGlobalStorage();\n\t\tthis.workspaceStorage = this.createWorkspaceStorage(workspace);\n\t}\n\n\tprivate createGlobalStorage(): IStorage {\n\t\tconst storageDataBaseClient = new StorageDatabaseChannelClient(this.mainProcessService.getChannel('storage'), undefined);\n\n\t\tconst globalStorage = new Storage(storageDataBaseClient.globalStorage);\n\n\t\tthis._register(globalStorage.onDidChangeStorage(key => this.emitDidChangeValue(StorageScope.GLOBAL, key)));\n\n\t\treturn globalStorage;\n\t}\n\n\tprivate createWorkspaceStorage(workspace: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier): IStorage;\n\tprivate createWorkspaceStorage(workspace: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier | undefined): IStorage | undefined;\n\tprivate createWorkspaceStorage(workspace: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier | undefined): IStorage | undefined {\n\t\tconst storageDataBaseClient = new StorageDatabaseChannelClient(this.mainProcessService.getChannel('storage'), workspace);\n\n\t\tif (storageDataBaseClient.workspaceStorage) {\n\t\t\tconst workspaceStorage = new Storage(storageDataBaseClient.workspaceStorage);\n\n\t\t\tthis.workspaceStorageDisposable.value = workspaceStorage.onDidChangeStorage(key => this.emitDidChangeValue(StorageScope.WORKSPACE, key));\n\t\t\tthis.workspaceStorageId = workspace?.id;\n\n\t\t\treturn workspaceStorage;\n\t\t} else {\n\t\t\tthis.workspaceStorageDisposable.clear();\n\t\t\tthis.workspaceStorageId = undefined;\n\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprotected async doInitialize(): Promise<void> {\n\n\t\t// Init all storage locations\n\t\tmark('code/willInitStorage');\n\t\ttry {\n\t\t\tawait Promises.settled([\n\t\t\t\tthis.globalStorage.init(),\n\t\t\t\tthis.workspaceStorage?.init() ?? Promise.resolve()\n\t\t\t]);\n\t\t} finally {\n\t\t\tmark('code/didInitStorage');\n\t\t}\n\t}\n\n\tprotected getStorage(scope: StorageScope): IStorage | undefined {\n\t\treturn scope === StorageScope.GLOBAL ? this.globalStorage : this.workspaceStorage;\n\t}\n\n\tprotected getLogDetails(scope: StorageScope): string | undefined {\n\t\treturn scope === StorageScope.GLOBAL ? this.environmentService.globalStorageHome.fsPath : this.workspaceStorageId ? `${joinPath(this.environmentService.workspaceStorageHome, this.workspaceStorageId, 'state.vscdb').fsPath}` : undefined;\n\t}\n\n\tasync close(): Promise<void> {\n\n\t\t// Stop periodic scheduler and idle runner as we now collect state normally\n\t\tthis.stopFlushWhenIdle();\n\n\t\t// Signal as event so that clients can still store data\n\t\tthis.emitWillSaveState(WillSaveStateReason.SHUTDOWN);\n\n\t\t// Do it\n\t\tawait Promises.settled([\n\t\t\tthis.globalStorage.close(),\n\t\t\tthis.workspaceStorage?.close() ?? Promise.resolve()\n\t\t]);\n\t}\n\n\tasync migrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void> {\n\n\t\t// Keep current workspace storage items around to restore\n\t\tconst oldWorkspaceStorage = this.workspaceStorage;\n\t\tconst oldItems = oldWorkspaceStorage?.items ?? new Map();\n\n\t\t// Close current which will change to new workspace storage\n\t\tif (oldWorkspaceStorage) {\n\t\t\tawait oldWorkspaceStorage.close();\n\t\t\toldWorkspaceStorage.dispose();\n\t\t}\n\n\t\t// Create new workspace storage & init\n\t\tthis.workspaceStorage = this.createWorkspaceStorage(toWorkspace);\n\t\tawait this.workspaceStorage.init();\n\n\t\t// Copy over previous keys\n\t\tfor (const [key, value] of oldItems) {\n\t\t\tthis.workspaceStorage.set(key, value);\n\t\t}\n\t}\n}\n"]}