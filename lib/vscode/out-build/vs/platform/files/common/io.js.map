{"version":3,"sources":["vs/platform/files/common/io.ts"],"names":[],"mappings":"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","file":"io.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { URI } from 'vs/base/common/uri';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IFileSystemProviderWithOpenReadWriteCloseCapability, FileReadStreamOptions, createFileSystemProviderError, FileSystemProviderErrorCode, ensureFileSystemProviderError } from 'vs/platform/files/common/files';\nimport { canceled } from 'vs/base/common/errors';\nimport { IErrorTransformer, IDataTransformer, WriteableStream } from 'vs/base/common/stream';\nimport product from 'vs/platform/product/common/product';\n\nexport interface ICreateReadStreamOptions extends FileReadStreamOptions {\n\n\t/**\n\t * The size of the buffer to use before sending to the stream.\n\t */\n\tbufferSize: number;\n\n\t/**\n\t * Allows to massage any possibly error that happens during reading.\n\t */\n\terrorTransformer?: IErrorTransformer;\n}\n\n/**\n * A helper to read a file from a provider with open/read/close capability into a stream.\n */\nexport async function readFileIntoStream<T>(\n\tprovider: IFileSystemProviderWithOpenReadWriteCloseCapability,\n\tresource: URI,\n\ttarget: WriteableStream<T>,\n\ttransformer: IDataTransformer<VSBuffer, T>,\n\toptions: ICreateReadStreamOptions,\n\ttoken: CancellationToken\n): Promise<void> {\n\tlet error: Error | undefined = undefined;\n\n\ttry {\n\t\tawait doReadFileIntoStream(provider, resource, target, transformer, options, token);\n\t} catch (err) {\n\t\terror = err;\n\t} finally {\n\t\tif (error && options.errorTransformer) {\n\t\t\terror = options.errorTransformer(error);\n\t\t}\n\n\t\tif (typeof error !== 'undefined') {\n\t\t\ttarget.error(error);\n\t\t}\n\n\t\ttarget.end();\n\t}\n}\n\nasync function doReadFileIntoStream<T>(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, target: WriteableStream<T>, transformer: IDataTransformer<VSBuffer, T>, options: ICreateReadStreamOptions, token: CancellationToken): Promise<void> {\n\n\t// Check for cancellation\n\tthrowIfCancelled(token);\n\n\t// open handle through provider\n\tconst handle = await provider.open(resource, { create: false });\n\n\ttry {\n\n\t\t// Check for cancellation\n\t\tthrowIfCancelled(token);\n\n\t\tlet totalBytesRead = 0;\n\t\tlet bytesRead = 0;\n\t\tlet allowedRemainingBytes = (options && typeof options.length === 'number') ? options.length : undefined;\n\n\t\tlet buffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n\t\tlet posInFile = options && typeof options.position === 'number' ? options.position : 0;\n\t\tlet posInBuffer = 0;\n\t\tdo {\n\t\t\t// read from source (handle) at current position (pos) into buffer (buffer) at\n\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\tbytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\tposInFile += bytesRead;\n\t\t\tposInBuffer += bytesRead;\n\t\t\ttotalBytesRead += bytesRead;\n\n\t\t\tif (typeof allowedRemainingBytes === 'number') {\n\t\t\t\tallowedRemainingBytes -= bytesRead;\n\t\t\t}\n\n\t\t\t// when buffer full, create a new one and emit it through stream\n\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\tawait target.write(transformer(buffer));\n\n\t\t\t\tbuffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n\t\t\t\tposInBuffer = 0;\n\t\t\t}\n\t\t} while (bytesRead > 0 && (typeof allowedRemainingBytes !== 'number' || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));\n\n\t\t// wrap up with last buffer (also respect maxBytes if provided)\n\t\tif (posInBuffer > 0) {\n\t\t\tlet lastChunkLength = posInBuffer;\n\t\t\tif (typeof allowedRemainingBytes === 'number') {\n\t\t\t\tlastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);\n\t\t\t}\n\n\t\t\ttarget.write(transformer(buffer.slice(0, lastChunkLength)));\n\t\t}\n\t} catch (error) {\n\t\tthrow ensureFileSystemProviderError(error);\n\t} finally {\n\t\tawait provider.close(handle);\n\t}\n}\n\nfunction throwIfCancelled(token: CancellationToken): boolean {\n\tif (token.isCancellationRequested) {\n\t\tthrow canceled();\n\t}\n\n\treturn true;\n}\n\nfunction throwIfTooLarge(totalBytesRead: number, options: ICreateReadStreamOptions): boolean {\n\n\t// Return early if file is too large to load and we have configured limits\n\tif (options?.limits) {\n\t\tif (typeof options.limits.memory === 'number' && totalBytesRead > options.limits.memory) {\n\t\t\tthrow createFileSystemProviderError(localize('fileTooLargeForHeapError', \"To open a file of this size, you need to restart and allow {0} to use more memory\", product.nameShort), FileSystemProviderErrorCode.FileExceedsMemoryLimit);\n\t\t}\n\n\t\tif (typeof options.limits.size === 'number' && totalBytesRead > options.limits.size) {\n\t\t\tthrow createFileSystemProviderError(localize('fileTooLargeError', \"File is too large to open\"), FileSystemProviderErrorCode.FileTooLarge);\n\t\t}\n\t}\n\n\treturn true;\n}\n"]}