{"version":3,"file":"ipcFileSystemProvider.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/files/common/ipcFileSystemProvider.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAmBhG;;;OAGG;IACH,MAAsB,qBAAsB,SAAQ,sBAAU;QAwB7D,YAA6B,OAAiB;YAC7C,KAAK,EAAE,CAAC;YADoB,YAAO,GAAP,OAAO,CAAU;YAlB7B,YAAO,GAAW,CAAA,GAAA,mBAAY,CAAA,EAAE,CAAC;YAEjC,iBAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAA0B,CAAC,CAAC;YAC7E,oBAAe,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;YAE3C,0BAAqB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAU,CAAC,CAAC;YAC7D,oBAAe,GAAG,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC;YAE3C,6BAAwB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;YACvE,4BAAuB,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC;YAE/D,kBAAa,GAAG;gDACgC;yCACR;wCACA;4CACC,CAAC;YAMjD,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC1B,CAAC;QAND,IAAI,YAAY,KAAqC,OAAO,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;QAQzE,iBAAiB;YACxB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAA4B,YAAY,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,aAAa,CAAC,EAAE;gBAC3G,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;oBACjC,MAAM,MAAM,GAAG,aAAa,CAAC;oBAC7B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,SAAG,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;iBAC1G;qBAAM;oBACN,MAAM,KAAK,GAAG,aAAa,CAAC;oBAC5B,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACvC;YACF,CAAC,CAAC,CAAC,CAAC;QACL,CAAC;QAES,gBAAgB,CAAC,eAAwB;YAClD,IAAI,eAAe,EAAE;gBACpB,IAAI,CAAC,aAAa,gCAAoD,CAAC;aACvE;iBAAM;gBACN,IAAI,CAAC,aAAa,IAAI,6BAAiD,CAAC;aACxE;YAED,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC/C,CAAC;QAED,uBAAuB;QAEvB,IAAI,CAAC,QAAa;YACjB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC9C,CAAC;QAED,IAAI,CAAC,QAAa,EAAE,IAAqB;YACxC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,KAAK,CAAC,EAAU;YACf,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACzC,CAAC;QAED,KAAK,CAAC,IAAI,CAAC,EAAU,EAAE,GAAW,EAAE,IAAgB,EAAE,MAAc,EAAE,MAAc;YACnF,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAuB,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC;YAElG,oEAAoE;YACpE,iEAAiE;YACjE,oEAAoE;YACpE,6BAA6B;YAC7B,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,SAAS,CAAC,EAAE,MAAM,CAAC,CAAC;YAEnD,OAAO,SAAS,CAAC;QAClB,CAAC;QAED,KAAK,CAAC,QAAQ,CAAC,QAAa;YAC3B,MAAM,IAAI,GAAa,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;YAEvE,OAAO,IAAI,CAAC,MAAM,CAAC;QACpB,CAAC;QAED,cAAc,CAAC,QAAa,EAAE,IAA2B,EAAE,KAAwB;YAClF,MAAM,MAAM,GAAG,CAAA,GAAA,2BAAkB,CAAA,CAAa,IAAI,CAAC,EAAE,CAAC,iBAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,iBAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;YAErH,kEAAkE;YAClE,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAuC,gBAAgB,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC,EAAE;gBAEjI,OAAO;gBACP,IAAI,gBAAgB,YAAY,iBAAQ,EAAE;oBACzC,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;iBACtC;gBAED,eAAe;qBACV;oBACJ,IAAI,gBAAgB,KAAK,KAAK,EAAE;wBAC/B,MAAM,CAAC,GAAG,EAAE,CAAC;qBACb;yBAAM;wBAEN,4DAA4D;wBAC5D,2DAA2D;wBAC3D,2DAA2D;wBAC3D,qCAAqC;wBACrC,IAAI,KAAK,GAAG,gBAAgB,CAAC;wBAC7B,IAAI,CAAC,CAAC,KAAK,YAAY,KAAK,CAAC,EAAE;4BAC9B,KAAK,GAAG,IAAI,KAAK,CAAC,CAAA,GAAA,6BAAc,CAAA,CAAC,KAAK,CAAC,CAAC,CAAC;yBACzC;wBAED,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;wBACpB,MAAM,CAAC,GAAG,EAAE,CAAC;qBACb;oBAED,qDAAqD;oBACrD,QAAQ,CAAC,OAAO,EAAE,CAAC;iBACnB;YACF,CAAC,CAAC,CAAC;YAEH,uBAAuB;YACvB,KAAK,CAAC,uBAAuB,CAAC,GAAG,EAAE;gBAElC,kDAAkD;gBAClD,gCAAgC;gBAChC,MAAM,CAAC,KAAK,CAAC,CAAA,GAAA,iBAAQ,CAAA,EAAE,CAAC,CAAC;gBACzB,MAAM,CAAC,GAAG,EAAE,CAAC;gBAEb,8DAA8D;gBAC9D,6DAA6D;gBAC7D,oBAAoB;gBACpB,QAAQ,CAAC,OAAO,EAAE,CAAC;YACpB,CAAC,CAAC,CAAC;YAEH,OAAO,MAAM,CAAC;QACf,CAAC;QAED,KAAK,CAAC,EAAU,EAAE,GAAW,EAAE,IAAgB,EAAE,MAAc,EAAE,MAAc;YAC9E,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,iBAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;QACnF,CAAC;QAED,SAAS,CAAC,QAAa,EAAE,OAAmB,EAAE,IAAsB;YACnE,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,EAAE,iBAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;QACjF,CAAC;QAED,MAAM,CAAC,QAAa,EAAE,IAAuB;YAC5C,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;QACtD,CAAC;QAED,KAAK,CAAC,QAAa;YAClB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC/C,CAAC;QAED,OAAO,CAAC,QAAa;YACpB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;QACjD,CAAC;QAED,MAAM,CAAC,QAAa,EAAE,MAAW,EAAE,IAA0B;YAC5D,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,CAAC,QAAa,EAAE,MAAW,EAAE,IAA0B;YAC1D,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;QAC5D,CAAC;QAED,KAAK,CAAC,QAAa,EAAE,IAAmB;YACvC,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;YAC1B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;YAEhE,OAAO,CAAA,GAAA,wBAAY,CAAA,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;QAC9E,CAAC;KACD;IA1KD,sDA0KC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from 'vs/base/common/event';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { IChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { FileChangeType, FileDeleteOptions, FileOverwriteOptions, FileSystemProviderCapabilities, FileType, IFileChange, IStat, IWatchOptions, FileOpenOptions, IFileSystemProviderWithFileReadWriteCapability, FileWriteOptions, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileFolderCopyCapability, FileReadStreamOptions, IFileSystemProviderWithOpenReadWriteCloseCapability } from 'vs/platform/files/common/files';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { newWriteableStream, ReadableStreamEvents, ReadableStreamEventPayload } from 'vs/base/common/stream';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { canceled } from 'vs/base/common/errors';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\n\ninterface IFileChangeDto {\n\tresource: UriComponents;\n\ttype: FileChangeType;\n}\n\n/**\n * An abstract file system provider that delegates all calls to a provided\n * `IChannel` via IPC communication.\n */\nexport abstract class IPCFileSystemProvider extends Disposable implements\n\tIFileSystemProviderWithFileReadWriteCapability,\n\tIFileSystemProviderWithOpenReadWriteCloseCapability,\n\tIFileSystemProviderWithFileReadStreamCapability,\n\tIFileSystemProviderWithFileFolderCopyCapability {\n\n\tprivate readonly session: string = generateUuid();\n\n\tprivate readonly _onDidChange = this._register(new Emitter<readonly IFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChange.event;\n\n\tprivate _onDidWatchErrorOccur = this._register(new Emitter<string>());\n\treadonly onDidErrorOccur = this._onDidWatchErrorOccur.event;\n\n\tprivate readonly _onDidChangeCapabilities = this._register(new Emitter<void>());\n\treadonly onDidChangeCapabilities = this._onDidChangeCapabilities.event;\n\n\tprivate _capabilities = FileSystemProviderCapabilities.FileReadWrite\n\t\t| FileSystemProviderCapabilities.FileOpenReadWriteClose\n\t\t| FileSystemProviderCapabilities.FileReadStream\n\t\t| FileSystemProviderCapabilities.FileFolderCopy\n\t\t| FileSystemProviderCapabilities.FileWriteUnlock;\n\tget capabilities(): FileSystemProviderCapabilities { return this._capabilities; }\n\n\tconstructor(private readonly channel: IChannel) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.channel.listen<IFileChangeDto[] | string>('filechange', [this.session])(eventsOrError => {\n\t\t\tif (Array.isArray(eventsOrError)) {\n\t\t\t\tconst events = eventsOrError;\n\t\t\t\tthis._onDidChange.fire(events.map(event => ({ resource: URI.revive(event.resource), type: event.type })));\n\t\t\t} else {\n\t\t\t\tconst error = eventsOrError;\n\t\t\t\tthis._onDidWatchErrorOccur.fire(error);\n\t\t\t}\n\t\t}));\n\t}\n\n\tprotected setCaseSensitive(isCaseSensitive: boolean) {\n\t\tif (isCaseSensitive) {\n\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t} else {\n\t\t\tthis._capabilities &= ~FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t}\n\n\t\tthis._onDidChangeCapabilities.fire(undefined);\n\t}\n\n\t// --- forwarding calls\n\n\tstat(resource: URI): Promise<IStat> {\n\t\treturn this.channel.call('stat', [resource]);\n\t}\n\n\topen(resource: URI, opts: FileOpenOptions): Promise<number> {\n\t\treturn this.channel.call('open', [resource, opts]);\n\t}\n\n\tclose(fd: number): Promise<void> {\n\t\treturn this.channel.call('close', [fd]);\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\tconst [bytes, bytesRead]: [VSBuffer, number] = await this.channel.call('read', [fd, pos, length]);\n\n\t\t// copy back the data that was written into the buffer on the remote\n\t\t// side. we need to do this because buffers are not referenced by\n\t\t// pointer, but only by value and as such cannot be directly written\n\t\t// to from the other process.\n\t\tdata.set(bytes.buffer.slice(0, bytesRead), offset);\n\n\t\treturn bytesRead;\n\t}\n\n\tasync readFile(resource: URI): Promise<Uint8Array> {\n\t\tconst buff = <VSBuffer>await this.channel.call('readFile', [resource]);\n\n\t\treturn buff.buffer;\n\t}\n\n\treadFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n\t\tconst stream = newWriteableStream<Uint8Array>(data => VSBuffer.concat(data.map(data => VSBuffer.wrap(data))).buffer);\n\n\t\t// Reading as file stream goes through an event to the remote side\n\t\tconst listener = this.channel.listen<ReadableStreamEventPayload<VSBuffer>>('readFileStream', [resource, opts])(dataOrErrorOrEnd => {\n\n\t\t\t// data\n\t\t\tif (dataOrErrorOrEnd instanceof VSBuffer) {\n\t\t\t\tstream.write(dataOrErrorOrEnd.buffer);\n\t\t\t}\n\n\t\t\t// end or error\n\t\t\telse {\n\t\t\t\tif (dataOrErrorOrEnd === 'end') {\n\t\t\t\t\tstream.end();\n\t\t\t\t} else {\n\n\t\t\t\t\t// Since we receive data through a IPC channel, it is likely\n\t\t\t\t\t// that the error was not serialized, or only partially. To\n\t\t\t\t\t// ensure our API use is correct, we convert the data to an\n\t\t\t\t\t// error here to forward it properly.\n\t\t\t\t\tlet error = dataOrErrorOrEnd;\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\terror = new Error(toErrorMessage(error));\n\t\t\t\t\t}\n\n\t\t\t\t\tstream.error(error);\n\t\t\t\t\tstream.end();\n\t\t\t\t}\n\n\t\t\t\t// Signal to the remote side that we no longer listen\n\t\t\t\tlistener.dispose();\n\t\t\t}\n\t\t});\n\n\t\t// Support cancellation\n\t\ttoken.onCancellationRequested(() => {\n\n\t\t\t// Ensure to end the stream properly with an error\n\t\t\t// to indicate the cancellation.\n\t\t\tstream.error(canceled());\n\t\t\tstream.end();\n\n\t\t\t// Ensure to dispose the listener upon cancellation. This will\n\t\t\t// bubble through the remote side as event and allows to stop\n\t\t\t// reading the file.\n\t\t\tlistener.dispose();\n\t\t});\n\n\t\treturn stream;\n\t}\n\n\twrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\treturn this.channel.call('write', [fd, pos, VSBuffer.wrap(data), offset, length]);\n\t}\n\n\twriteFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void> {\n\t\treturn this.channel.call('writeFile', [resource, VSBuffer.wrap(content), opts]);\n\t}\n\n\tdelete(resource: URI, opts: FileDeleteOptions): Promise<void> {\n\t\treturn this.channel.call('delete', [resource, opts]);\n\t}\n\n\tmkdir(resource: URI): Promise<void> {\n\t\treturn this.channel.call('mkdir', [resource]);\n\t}\n\n\treaddir(resource: URI): Promise<[string, FileType][]> {\n\t\treturn this.channel.call('readdir', [resource]);\n\t}\n\n\trename(resource: URI, target: URI, opts: FileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('rename', [resource, target, opts]);\n\t}\n\n\tcopy(resource: URI, target: URI, opts: FileOverwriteOptions): Promise<void> {\n\t\treturn this.channel.call('copy', [resource, target, opts]);\n\t}\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\t\tconst req = Math.random();\n\t\tthis.channel.call('watch', [this.session, req, resource, opts]);\n\n\t\treturn toDisposable(() => this.channel.call('unwatch', [this.session, req]));\n\t}\n}\n"]}