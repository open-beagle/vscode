{"version":3,"sources":["vs/platform/files/common/fileService.ts"],"names":[],"mappings":"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","file":"fileService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { mark } from 'vs/base/common/performance';\nimport { Disposable, IDisposable, toDisposable, dispose, DisposableStore } from 'vs/base/common/lifecycle';\nimport { IFileService, IResolveFileOptions, FileChangesEvent, FileOperationEvent, IFileSystemProviderRegistrationEvent, IFileSystemProvider, IFileStat, IResolveFileResult, ICreateFileOptions, IFileSystemProviderActivationEvent, FileOperationError, FileOperationResult, FileOperation, FileSystemProviderCapabilities, FileType, toFileSystemProviderErrorCode, FileSystemProviderErrorCode, IStat, IFileStatWithMetadata, IResolveMetadataFileOptions, etag, hasReadWriteCapability, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, toFileOperationResult, IFileSystemProviderWithOpenReadWriteCloseCapability, IFileSystemProviderWithFileReadWriteCapability, IResolveFileResultWithMetadata, IWatchOptions, IWriteFileOptions, IReadFileOptions, IFileStreamContent, IFileContent, ETAG_DISABLED, hasFileReadStreamCapability, IFileSystemProviderWithFileReadStreamCapability, ensureFileSystemProviderError, IFileSystemProviderCapabilitiesChangeEvent, IReadFileStreamOptions, FileDeleteOptions } from 'vs/platform/files/common/files';\nimport { URI } from 'vs/base/common/uri';\nimport { Emitter } from 'vs/base/common/event';\nimport { IExtUri, extUri, extUriIgnorePathCase, isAbsolutePath } from 'vs/base/common/resources';\nimport { TernarySearchTree } from 'vs/base/common/map';\nimport { isNonEmptyArray, coalesce } from 'vs/base/common/arrays';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { VSBuffer, VSBufferReadable, readableToBuffer, bufferToReadable, streamToBuffer, VSBufferReadableStream, VSBufferReadableBufferedStream, bufferedStreamToBuffer, newWriteableBufferStream } from 'vs/base/common/buffer';\nimport { isReadableStream, transform, peekReadable, peekStream, isReadableBufferedStream, newWriteableStream, listenStream, consumeStream } from 'vs/base/common/stream';\nimport { Promises, ResourceQueue } from 'vs/base/common/async';\nimport { CancellationTokenSource, CancellationToken } from 'vs/base/common/cancellation';\nimport { Schemas } from 'vs/base/common/network';\nimport { readFileIntoStream } from 'vs/platform/files/common/io';\nimport { Iterable } from 'vs/base/common/iterator';\n\nexport class FileService extends Disposable implements IFileService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly BUFFER_SIZE = 64 * 1024;\n\n\tconstructor(@ILogService private readonly logService: ILogService) {\n\t\tsuper();\n\t}\n\n\t//#region File System Provider\n\n\tprivate readonly _onDidChangeFileSystemProviderRegistrations = this._register(new Emitter<IFileSystemProviderRegistrationEvent>());\n\treadonly onDidChangeFileSystemProviderRegistrations = this._onDidChangeFileSystemProviderRegistrations.event;\n\n\tprivate readonly _onWillActivateFileSystemProvider = this._register(new Emitter<IFileSystemProviderActivationEvent>());\n\treadonly onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;\n\n\tprivate readonly _onDidChangeFileSystemProviderCapabilities = this._register(new Emitter<IFileSystemProviderCapabilitiesChangeEvent>());\n\treadonly onDidChangeFileSystemProviderCapabilities = this._onDidChangeFileSystemProviderCapabilities.event;\n\n\tprivate readonly provider = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable {\n\t\tif (this.provider.has(scheme)) {\n\t\t\tthrow new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\n\t\t}\n\n\t\tmark(`code/registerFilesystem/${scheme}`);\n\n\t\t// Add provider with event\n\t\tthis.provider.set(scheme, provider);\n\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });\n\n\t\t// Forward events from provider\n\t\tconst providerDisposables = new DisposableStore();\n\t\tproviderDisposables.add(provider.onDidChangeFile(changes => this._onDidFilesChange.fire(new FileChangesEvent(changes, !this.isPathCaseSensitive(provider)))));\n\t\tproviderDisposables.add(provider.onDidChangeCapabilities(() => this._onDidChangeFileSystemProviderCapabilities.fire({ provider, scheme })));\n\t\tif (typeof provider.onDidErrorOccur === 'function') {\n\t\t\tproviderDisposables.add(provider.onDidErrorOccur(error => this._onError.fire(new Error(error))));\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });\n\t\t\tthis.provider.delete(scheme);\n\n\t\t\tdispose(providerDisposables);\n\t\t});\n\t}\n\n\tgetProvider(scheme: string): IFileSystemProvider | undefined {\n\t\treturn this.provider.get(scheme);\n\t}\n\n\tasync activateProvider(scheme: string): Promise<void> {\n\n\t\t// Emit an event that we are about to activate a provider with the given scheme.\n\t\t// Listeners can participate in the activation by registering a provider for it.\n\t\tconst joiners: Promise<void>[] = [];\n\t\tthis._onWillActivateFileSystemProvider.fire({\n\t\t\tscheme,\n\t\t\tjoin(promise) {\n\t\t\t\tjoiners.push(promise);\n\t\t\t},\n\t\t});\n\n\t\tif (this.provider.has(scheme)) {\n\t\t\treturn; // provider is already here so we can return directly\n\t\t}\n\n\t\t// If the provider is not yet there, make sure to join on the listeners assuming\n\t\t// that it takes a bit longer to register the file system provider.\n\t\tawait Promises.settled(joiners);\n\t}\n\n\tcanHandleResource(resource: URI): boolean {\n\t\treturn this.provider.has(resource.scheme);\n\t}\n\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n\t\tconst provider = this.provider.get(resource.scheme);\n\n\t\treturn !!(provider && (provider.capabilities & capability));\n\t}\n\n\tlistCapabilities(): Iterable<{ scheme: string, capabilities: FileSystemProviderCapabilities; }> {\n\t\treturn Iterable.map(this.provider, ([scheme, provider]) => ({ scheme, capabilities: provider.capabilities }));\n\t}\n\n\tprotected async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\n\t\t// Assert path is absolute\n\t\tif (!isAbsolutePath(resource)) {\n\t\t\tthrow new FileOperationError(localize('invalidPath', \"Unable to resolve filesystem provider with relative file path '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_INVALID_PATH);\n\t\t}\n\n\t\t// Activate provider\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\t// Assert provider\n\t\tconst provider = this.provider.get(resource.scheme);\n\t\tif (!provider) {\n\t\t\tconst error = new Error();\n\t\t\terror.name = 'ENOPRO';\n\t\t\terror.message = localize('noProviderFound', \"No file system provider found for resource '{0}'\", resource.toString());\n\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate async withReadProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider) || hasFileReadStreamCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\n\t}\n\n\tprivate async withWriteProvider(resource: URI): Promise<IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\tif (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n\t\t\treturn provider;\n\t\t}\n\n\t\tthrow new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\n\t}\n\n\t//#endregion\n\n\tprivate readonly _onDidRunOperation = this._register(new Emitter<FileOperationEvent>());\n\treadonly onDidRunOperation = this._onDidRunOperation.event;\n\n\tprivate readonly _onError = this._register(new Emitter<Error>());\n\treadonly onError = this._onError.event;\n\n\t//#region File Metadata Resolving\n\n\tasync resolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tasync resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\ttry {\n\t\t\treturn await this.doResolveFile(resource, options);\n\t\t} catch (error) {\n\n\t\t\t// Specially handle file not found case as file operation result\n\t\t\tif (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\tthrow new FileOperationError(localize('fileNotFoundError', \"Unable to resolve non-existing file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t\t}\n\n\t\t\t// Bubble up any other error as is\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async doResolveFile(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\tconst provider = await this.withProvider(resource);\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\tconst resolveTo = options?.resolveTo;\n\t\tconst resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\n\t\tconst resolveMetadata = options?.resolveMetadata;\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\tlet trie: TernarySearchTree<URI, boolean> | undefined;\n\n\t\treturn this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\n\n\t\t\t// lazy trie to check for recursive resolving\n\t\t\tif (!trie) {\n\t\t\t\ttrie = TernarySearchTree.forUris<true>(() => !isPathCaseSensitive);\n\t\t\t\ttrie.set(resource, true);\n\t\t\t\tif (isNonEmptyArray(resolveTo)) {\n\t\t\t\t\tresolveTo.forEach(uri => trie!.set(uri, true));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check for recursive resolving\n\t\t\tif (Boolean(trie.findSuperstr(stat.resource) || trie.get(stat.resource))) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check for resolving single child folders\n\t\t\tif (stat.isDirectory && resolveSingleChildDescendants) {\n\t\t\t\treturn siblings === 1;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType; } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStatWithMetadata>;\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType; } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat> {\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\t// convert to file stat\n\t\tconst fileStat: IFileStat = {\n\t\t\tresource,\n\t\t\tname: providerExtUri.basename(resource),\n\t\t\tisFile: (stat.type & FileType.File) !== 0,\n\t\t\tisDirectory: (stat.type & FileType.Directory) !== 0,\n\t\t\tisSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n\t\t\tmtime: stat.mtime,\n\t\t\tctime: stat.ctime,\n\t\t\tsize: stat.size,\n\t\t\tetag: etag({ mtime: stat.mtime, size: stat.size })\n\t\t};\n\n\t\t// check to recurse for directories\n\t\tif (fileStat.isDirectory && recurse(fileStat, siblings)) {\n\t\t\ttry {\n\t\t\t\tconst entries = await provider.readdir(resource);\n\t\t\t\tconst resolvedEntries = await Promises.settled(entries.map(async ([name, type]) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst childResource = providerExtUri.joinPath(resource, name);\n\t\t\t\t\t\tconst childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n\t\t\t\t\t\treturn await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\t\treturn null; // can happen e.g. due to permission errors\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\t// make sure to get rid of null values that signal a failure to resolve a particular entry\n\t\t\t\tfileStat.children = coalesce(resolvedEntries);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\tfileStat.children = []; // gracefully handle errors, we may not have permissions to read\n\t\t\t}\n\n\t\t\treturn fileStat;\n\t\t}\n\n\t\treturn fileStat;\n\t}\n\n\tasync resolveAll(toResolve: { resource: URI, options?: IResolveFileOptions; }[]): Promise<IResolveFileResult[]>;\n\tasync resolveAll(toResolve: { resource: URI, options: IResolveMetadataFileOptions; }[]): Promise<IResolveFileResultWithMetadata[]>;\n\tasync resolveAll(toResolve: { resource: URI; options?: IResolveFileOptions; }[]): Promise<IResolveFileResult[]> {\n\t\treturn Promises.settled(toResolve.map(async entry => {\n\t\t\ttry {\n\t\t\t\treturn { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\treturn { stat: undefined, success: false };\n\t\t\t}\n\t\t}));\n\t}\n\n\tasync exists(resource: URI): Promise<boolean> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\ttry {\n\t\t\tconst stat = await provider.stat(resource);\n\n\t\t\treturn !!stat;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync canCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateCreateFile(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateCreateFile(resource: URI, options?: ICreateFileOptions): Promise<void> {\n\n\t\t// validate overwrite\n\t\tif (!options?.overwrite && await this.exists(resource)) {\n\t\t\tthrow new FileOperationError(localize('fileExists', \"Unable to create file '{0}' that already exists when overwrite flag is not set\", this.resourceForError(resource)), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\t}\n\n\tasync createFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream = VSBuffer.fromString(''), options?: ICreateFileOptions): Promise<IFileStatWithMetadata> {\n\n\t\t// validate\n\t\tawait this.doValidateCreateFile(resource, options);\n\n\t\t// do write into file (this will create it too)\n\t\tconst fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\n\n\t\t// events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync writeFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\ttry {\n\n\t\t\t// validate write\n\t\t\tconst stat = await this.validateWriteFile(provider, resource, options);\n\n\t\t\t// mkdir recursively as needed\n\t\t\tif (!stat) {\n\t\t\t\tawait this.mkdirp(provider, providerExtUri.dirname(resource));\n\t\t\t}\n\n\t\t\t// optimization: if the provider has unbuffered write capability and the data\n\t\t\t// to write is a Readable, we consume up to 3 chunks and try to write the data\n\t\t\t// unbuffered to reduce the overhead. If the Readable has more data to provide\n\t\t\t// we continue to write buffered.\n\t\t\tlet bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream;\n\t\t\tif (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof VSBuffer)) {\n\t\t\t\tif (isReadableStream(bufferOrReadableOrStream)) {\n\t\t\t\t\tconst bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\n\t\t\t\t\tif (bufferedStream.ended) {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = VSBuffer.concat(bufferedStream.buffer);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = bufferedStream;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => VSBuffer.concat(data), 3);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\n\t\t\t}\n\n\t\t\t// write file: unbuffered (only if data to write is a buffer, or the provider has no buffered write capability)\n\t\t\tif (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer)) {\n\t\t\t\tawait this.doWriteUnbuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\n\t\t\t// write file: buffered\n\t\t\telse {\n\t\t\t\tawait this.doWriteBuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer ? bufferToReadable(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new FileOperationError(localize('err.write', \"Unable to write file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options);\n\t\t}\n\n\t\treturn this.resolve(resource, { resolveMetadata: true });\n\t}\n\n\tprivate async validateWriteFile(provider: IFileSystemProvider, resource: URI, options?: IWriteFileOptions): Promise<IStat | undefined> {\n\n\t\t// Validate unlock support\n\t\tconst unlock = !!options?.unlock;\n\t\tif (unlock && !(provider.capabilities & FileSystemProviderCapabilities.FileWriteUnlock)) {\n\t\t\tthrow new Error(localize('writeFailedUnlockUnsupported', \"Unable to unlock file '{0}' because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate via file stat meta data\n\t\tlet stat: IStat | undefined = undefined;\n\t\ttry {\n\t\t\tstat = await provider.stat(resource);\n\t\t} catch (error) {\n\t\t\treturn undefined; // file might not exist\n\t\t}\n\n\t\t// File cannot be directory\n\t\tif ((stat.type & FileType.Directory) !== 0) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryWriteError', \"Unable to write file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// Dirty write prevention: if the file on disk has been changed and does not match our expected\n\t\t// mtime and etag, we bail out to prevent dirty writing.\n\t\t//\n\t\t// First, we check for a mtime that is in the future before we do more checks. The assumption is\n\t\t// that only the mtime is an indicator for a file that has changed on disk.\n\t\t//\n\t\t// Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n\t\t// one using the etag() function. Relying only on the mtime check has prooven to produce false\n\t\t// positives due to file system weirdness (especially around remote file systems). As such, the\n\t\t// check for size is a weaker check because it can return a false negative if the file has changed\n\t\t// but to the same length. This is a compromise we take to avoid having to produce checksums of\n\t\t// the file content for comparison which would be much slower to compute.\n\t\tif (\n\t\t\toptions && typeof options.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n\t\t\ttypeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n\t\t\toptions.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size })\n\t\t) {\n\t\t\tthrow new FileOperationError(localize('fileModifiedError', \"File Modified Since\"), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\tasync readFile(resource: URI, options?: IReadFileOptions): Promise<IFileContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\tif (options?.atomic) {\n\t\t\treturn this.doReadFileAtomic(provider, resource, options);\n\t\t}\n\n\t\treturn this.doReadFile(provider, resource, options);\n\t}\n\n\tprivate async doReadFileAtomic(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions): Promise<IFileContent> {\n\t\treturn new Promise<IFileContent>((resolve, reject) => {\n\t\t\tthis.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this.doReadFile(provider, resource, options);\n\t\t\t\t\tresolve(content);\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doReadFile(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileOptions): Promise<IFileContent> {\n\t\tconst stream = await this.doReadFileStream(provider, resource, {\n\t\t\t...options,\n\t\t\t// optimization: since we know that the caller does not\n\t\t\t// care about buffering, we indicate this to the reader.\n\t\t\t// this reduces all the overhead the buffered reading\n\t\t\t// has (open, read, close) if the provider supports\n\t\t\t// unbuffered reading.\n\t\t\tpreferUnbuffered: true\n\t\t});\n\n\t\treturn {\n\t\t\t...stream,\n\t\t\tvalue: await streamToBuffer(stream.value)\n\t\t};\n\t}\n\n\tasync readFileStream(resource: URI, options?: IReadFileStreamOptions): Promise<IFileStreamContent> {\n\t\tconst provider = await this.withReadProvider(resource);\n\n\t\treturn this.doReadFileStream(provider, resource, options);\n\t}\n\n\tprivate async doReadFileStream(provider: IFileSystemProviderWithFileReadWriteCapability | IFileSystemProviderWithOpenReadWriteCloseCapability | IFileSystemProviderWithFileReadStreamCapability, resource: URI, options?: IReadFileStreamOptions & { preferUnbuffered?: boolean; }): Promise<IFileStreamContent> {\n\n\t\t// install a cancellation token that gets cancelled\n\t\t// when any error occurs. this allows us to resolve\n\t\t// the content of the file while resolving metadata\n\t\t// but still cancel the operation in certain cases.\n\t\tconst cancellableSource = new CancellationTokenSource();\n\n\t\t// validate read operation\n\t\tconst statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {\n\t\t\tcancellableSource.cancel();\n\n\t\t\tthrow error;\n\t\t});\n\n\t\tlet fileStream: VSBufferReadableStream | undefined = undefined;\n\t\ttry {\n\n\t\t\t// if the etag is provided, we await the result of the validation\n\t\t\t// due to the likelihood of hitting a NOT_MODIFIED_SINCE result.\n\t\t\t// otherwise, we let it run in parallel to the file reading for\n\t\t\t// optimal startup performance.\n\t\t\tif (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED) {\n\t\t\t\tawait statPromise;\n\t\t\t}\n\n\t\t\t// read unbuffered (only if either preferred, or the provider has no buffered read capability)\n\t\t\tif (!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) || (hasReadWriteCapability(provider) && options?.preferUnbuffered)) {\n\t\t\t\tfileStream = this.readFileUnbuffered(provider, resource, options);\n\t\t\t}\n\n\t\t\t// read streamed (always prefer over primitive buffered read)\n\t\t\telse if (hasFileReadStreamCapability(provider)) {\n\t\t\t\tfileStream = this.readFileStreamed(provider, resource, cancellableSource.token, options);\n\t\t\t}\n\n\t\t\t// read buffered\n\t\t\telse {\n\t\t\t\tfileStream = this.readFileBuffered(provider, resource, cancellableSource.token, options);\n\t\t\t}\n\n\t\t\tconst fileStat = await statPromise;\n\n\t\t\treturn {\n\t\t\t\t...fileStat,\n\t\t\t\tvalue: fileStream\n\t\t\t};\n\t\t} catch (error) {\n\n\t\t\t// Await the stream to finish so that we exit this method\n\t\t\t// in a consistent state with file handles closed\n\t\t\t// (https://github.com/microsoft/vscode/issues/114024)\n\t\t\tif (fileStream) {\n\t\t\t\tawait consumeStream(fileStream);\n\t\t\t}\n\n\t\t\tthrow new FileOperationError(localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options);\n\t\t}\n\t}\n\n\tprivate readFileStreamed(provider: IFileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst fileStream = provider.readFileStream(resource, options, token);\n\n\t\treturn transform(fileStream, {\n\t\t\tdata: data => data instanceof VSBuffer ? data : VSBuffer.wrap(data),\n\t\t\terror: error => new FileOperationError(localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options)\n\t\t}, data => VSBuffer.concat(data));\n\t}\n\n\tprivate readFileBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: IReadFileStreamOptions = Object.create(null)): VSBufferReadableStream {\n\t\tconst stream = newWriteableBufferStream();\n\n\t\treadFileIntoStream(provider, resource, stream, data => data, {\n\t\t\t...options,\n\t\t\tbufferSize: this.BUFFER_SIZE,\n\t\t\terrorTransformer: error => new FileOperationError(localize('err.read', \"Unable to read file '{0}' ({1})\", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options)\n\t\t}, token);\n\n\t\treturn stream;\n\t}\n\n\tprivate readFileUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options?: IReadFileStreamOptions): VSBufferReadableStream {\n\t\tconst stream = newWriteableStream<VSBuffer>(data => VSBuffer.concat(data));\n\n\t\t// Read the file into the stream async but do not wait for\n\t\t// this to complete because streams work via events\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tlet buffer = await provider.readFile(resource);\n\n\t\t\t\t// respect position option\n\t\t\t\tif (options && typeof options.position === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(options.position);\n\t\t\t\t}\n\n\t\t\t\t// respect length option\n\t\t\t\tif (options && typeof options.length === 'number') {\n\t\t\t\t\tbuffer = buffer.slice(0, options.length);\n\t\t\t\t}\n\n\t\t\t\t// Throw if file is too large to load\n\t\t\t\tthis.validateReadFileLimits(resource, buffer.byteLength, options);\n\n\t\t\t\t// End stream with data\n\t\t\t\tstream.end(VSBuffer.wrap(buffer));\n\t\t\t} catch (err) {\n\t\t\t\tstream.error(err);\n\t\t\t\tstream.end();\n\t\t\t}\n\t\t})();\n\n\t\treturn stream;\n\t}\n\n\tprivate async validateReadFile(resource: URI, options?: IReadFileStreamOptions): Promise<IFileStatWithMetadata> {\n\t\tconst stat = await this.resolve(resource, { resolveMetadata: true });\n\n\t\t// Throw if resource is a directory\n\t\tif (stat.isDirectory) {\n\t\t\tthrow new FileOperationError(localize('fileIsDirectoryReadError', \"Unable to read file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n\t\t}\n\n\t\t// Throw if file not modified since (unless disabled)\n\t\tif (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\n\t\t\tthrow new FileOperationError(localize('fileNotModifiedError', \"File not modified since\"), FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\n\t\t}\n\n\t\t// Throw if file is too large to load\n\t\tthis.validateReadFileLimits(resource, stat.size, options);\n\n\t\treturn stat;\n\t}\n\n\tprivate validateReadFileLimits(resource: URI, size: number, options?: IReadFileStreamOptions): void {\n\t\tif (options?.limits) {\n\t\t\tlet tooLargeErrorResult: FileOperationResult | undefined = undefined;\n\n\t\t\tif (typeof options.limits.memory === 'number' && size > options.limits.memory) {\n\t\t\t\ttooLargeErrorResult = FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n\t\t\t}\n\n\t\t\tif (typeof options.limits.size === 'number' && size > options.limits.size) {\n\t\t\t\ttooLargeErrorResult = FileOperationResult.FILE_TOO_LARGE;\n\t\t\t}\n\n\t\t\tif (typeof tooLargeErrorResult === 'number') {\n\t\t\t\tthrow new FileOperationError(localize('fileTooLargeError', \"Unable to read file '{0}' that is too large to open\", this.resourceForError(resource)), tooLargeErrorResult);\n\t\t\t}\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync canMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'move', overwrite);\n\t}\n\n\tasync canCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true> {\n\t\treturn this.doCanMoveCopy(source, target, 'copy', overwrite);\n\t}\n\n\tprivate async doCanMoveCopy(source: URI, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<Error | true> {\n\t\tif (source.toString() !== target.toString()) {\n\t\t\ttry {\n\t\t\t\tconst sourceProvider = mode === 'move' ? this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source) : await this.withReadProvider(source);\n\t\t\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t\t\tawait this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\t\t\t} catch (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tasync move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// move\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync copy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = await this.withReadProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n\t\t// copy\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolve(target, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async doMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\n\t\tif (source.toString() === target.toString()) {\n\t\t\treturn mode; // simulate node.js behaviour here and do a no-op if paths match\n\t\t}\n\n\t\t// validation\n\t\tconst { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\n\t\t// delete as needed (unless target is same resurce with different path case)\n\t\tif (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n\t\t\tawait this.del(target, { recursive: true });\n\t\t}\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));\n\n\t\t// copy source => target\n\t\tif (mode === 'copy') {\n\n\t\t\t// same provider with fast copy: leverage copy() functionality\n\t\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\t\tawait sourceProvider.copy(source, target, { overwrite });\n\t\t\t}\n\n\t\t\t// when copying via buffer/unbuffered, we have to manually\n\t\t\t// traverse the source if it is a folder and not a file\n\t\t\telse {\n\t\t\t\tconst sourceFile = await this.resolve(source);\n\t\t\t\tif (sourceFile.isDirectory) {\n\t\t\t\t\tawait this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doCopyFile(sourceProvider, source, targetProvider, target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mode;\n\t\t}\n\n\t\t// move source => target\n\t\telse {\n\n\t\t\t// same provider: leverage rename() functionality\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tawait sourceProvider.rename(source, target, { overwrite });\n\n\t\t\t\treturn mode;\n\t\t\t}\n\n\t\t\t// across providers: copy to target & delete at source\n\t\t\telse {\n\t\t\t\tawait this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\t\t\t\tawait this.del(source, { recursive: true });\n\n\t\t\t\treturn 'copy';\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doCopyFile(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI): Promise<void> {\n\n\t\t// copy: source (buffered) => target (buffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (buffered) => target (unbuffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (buffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (unbuffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\t}\n\n\tprivate async doCopyFolder(sourceProvider: IFileSystemProvider, sourceFolder: IFileStat, targetProvider: IFileSystemProvider, targetFolder: URI): Promise<void> {\n\n\t\t// create folder in target\n\t\tawait targetProvider.mkdir(targetFolder);\n\n\t\t// create children in target\n\t\tif (Array.isArray(sourceFolder.children)) {\n\t\t\tawait Promises.settled(sourceFolder.children.map(async sourceChild => {\n\t\t\t\tconst targetChild = this.getExtUri(targetProvider).providerExtUri.joinPath(targetFolder, sourceChild.name);\n\t\t\t\tif (sourceChild.isDirectory) {\n\t\t\t\t\treturn this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async doValidateMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean, isSameResourceWithDifferentPathCase: boolean; }> {\n\t\tlet isSameResourceWithDifferentPathCase = false;\n\n\t\t// Check if source is equal or parent to target (requires providers to be the same)\n\t\tif (sourceProvider === targetProvider) {\n\t\t\tconst { providerExtUri, isPathCaseSensitive } = this.getExtUri(sourceProvider);\n\t\t\tif (!isPathCaseSensitive) {\n\t\t\t\tisSameResourceWithDifferentPathCase = providerExtUri.isEqual(source, target);\n\t\t\t}\n\n\t\t\tif (isSameResourceWithDifferentPathCase && mode === 'copy') {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError1', \"Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\n\t\t\tif (!isSameResourceWithDifferentPathCase && providerExtUri.isEqualOrParent(target, source)) {\n\t\t\t\tthrow new Error(localize('unableToMoveCopyError2', \"Unable to move/copy when source '{0}' is parent of target '{1}'.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t}\n\t\t}\n\n\t\t// Extra checks if target exists and this is not a rename\n\t\tconst exists = await this.exists(target);\n\t\tif (exists && !isSameResourceWithDifferentPathCase) {\n\n\t\t\t// Bail out if target exists and we are not about to overwrite\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow new FileOperationError(localize('unableToMoveCopyError3', \"Unable to move/copy '{0}' because target '{1}' already exists at destination.\", this.resourceForError(source), this.resourceForError(target)), FileOperationResult.FILE_MOVE_CONFLICT);\n\t\t\t}\n\n\t\t\t// Special case: if the target is a parent of the source, we cannot delete\n\t\t\t// it as it would delete the source as well. In this case we have to throw\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\tconst { providerExtUri } = this.getExtUri(sourceProvider);\n\t\t\t\tif (providerExtUri.isEqualOrParent(source, target)) {\n\t\t\t\t\tthrow new Error(localize('unableToMoveCopyError4', \"Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.\", this.resourceForError(source), this.resourceForError(target)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { exists, isSameResourceWithDifferentPathCase };\n\t}\n\n\tprivate getExtUri(provider: IFileSystemProvider): { providerExtUri: IExtUri, isPathCaseSensitive: boolean; } {\n\t\tconst isPathCaseSensitive = this.isPathCaseSensitive(provider);\n\n\t\treturn {\n\t\t\tproviderExtUri: isPathCaseSensitive ? extUri : extUriIgnorePathCase,\n\t\t\tisPathCaseSensitive\n\t\t};\n\t}\n\n\tprivate isPathCaseSensitive(provider: IFileSystemProvider): boolean {\n\t\treturn !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t}\n\n\tasync createFolder(resource: URI): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// mkdir recursively\n\t\tawait this.mkdirp(provider, resource);\n\n\t\t// events\n\t\tconst fileStat = await this.resolve(resource, { resolveMetadata: true });\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async mkdirp(provider: IFileSystemProvider, directory: URI): Promise<void> {\n\t\tconst directoriesToCreate: string[] = [];\n\n\t\t// mkdir until we reach root\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\t\twhile (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {\n\t\t\ttry {\n\t\t\t\tconst stat = await provider.stat(directory);\n\t\t\t\tif ((stat.type & FileType.Directory) === 0) {\n\t\t\t\t\tthrow new Error(localize('mkdirExistsError', \"Unable to create folder '{0}' that already exists but is not a directory\", this.resourceForError(directory)));\n\t\t\t\t}\n\n\t\t\t\tbreak; // we have hit a directory that exists -> good\n\t\t\t} catch (error) {\n\n\t\t\t\t// Bubble up any other error that is not file not found\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Upon error, remember directories that need to be created\n\t\t\t\tdirectoriesToCreate.push(providerExtUri.basename(directory));\n\n\t\t\t\t// Continue up\n\t\t\t\tdirectory = providerExtUri.dirname(directory);\n\t\t\t}\n\t\t}\n\n\t\t// Create directories as needed\n\t\tfor (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n\t\t\tdirectory = providerExtUri.joinPath(directory, directoriesToCreate[i]);\n\n\t\t\ttry {\n\t\t\t\tawait provider.mkdir(directory);\n\t\t\t} catch (error) {\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n\t\t\t\t\t// For mkdirp() we tolerate that the mkdir() call fails\n\t\t\t\t\t// in case the folder already exists. This follows node.js\n\t\t\t\t\t// own implementation of fs.mkdir({ recursive: true }) and\n\t\t\t\t\t// reduces the chances of race conditions leading to errors\n\t\t\t\t\t// if multiple calls try to create the same folders\n\t\t\t\t\t// As such, we only throw an error here if it is other than\n\t\t\t\t\t// the fact that the file already exists.\n\t\t\t\t\t// (see also https://github.com/microsoft/vscode/issues/89834)\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync canDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<Error | true> {\n\t\ttry {\n\t\t\tawait this.doValidateDelete(resource, options);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async doValidateDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<IFileSystemProvider> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n\t\t// Validate trash support\n\t\tconst useTrash = !!options?.useTrash;\n\t\tif (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n\t\t\tthrow new Error(localize('deleteFailedTrashUnsupported', \"Unable to delete file '{0}' via trash because provider does not support it.\", this.resourceForError(resource)));\n\t\t}\n\n\t\t// Validate delete\n\t\tconst exists = await this.exists(resource);\n\t\tif (!exists) {\n\t\t\tthrow new FileOperationError(localize('deleteFailedNotFound', \"Unable to delete non-existing file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n\t\t}\n\n\t\t// Validate recursive\n\t\tconst recursive = !!options?.recursive;\n\t\tif (!recursive && exists) {\n\t\t\tconst stat = await this.resolve(resource);\n\t\t\tif (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n\t\t\t\tthrow new Error(localize('deleteFailedNonEmptyFolder', \"Unable to delete non-empty folder '{0}'.\", this.resourceForError(resource)));\n\t\t\t}\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tasync del(resource: URI, options?: Partial<FileDeleteOptions>): Promise<void> {\n\t\tconst provider = await this.doValidateDelete(resource, options);\n\n\t\tconst useTrash = !!options?.useTrash;\n\t\tconst recursive = !!options?.recursive;\n\n\t\t// Delete through provider\n\t\tawait provider.delete(resource, { recursive, useTrash });\n\n\t\t// Events\n\t\tthis._onDidRunOperation.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate readonly _onDidFilesChange = this._register(new Emitter<FileChangesEvent>());\n\treadonly onDidFilesChange = this._onDidFilesChange.event;\n\n\tprivate readonly activeWatchers = new Map<string, { disposable: IDisposable, count: number; }>();\n\n\twatch(resource: URI, options: IWatchOptions = { recursive: false, excludes: [] }): IDisposable {\n\t\tlet watchDisposed = false;\n\t\tlet disposeWatch = () => { watchDisposed = true; };\n\n\t\t// Watch and wire in disposable which is async but\n\t\t// check if we got disposed meanwhile and forward\n\t\tthis.doWatch(resource, options).then(disposable => {\n\t\t\tif (watchDisposed) {\n\t\t\t\tdispose(disposable);\n\t\t\t} else {\n\t\t\t\tdisposeWatch = () => dispose(disposable);\n\t\t\t}\n\t\t}, error => this.logService.error(error));\n\n\t\treturn toDisposable(() => disposeWatch());\n\t}\n\n\tasync doWatch(resource: URI, options: IWatchOptions): Promise<IDisposable> {\n\t\tconst provider = await this.withProvider(resource);\n\t\tconst key = this.toWatchKey(provider, resource, options);\n\n\t\t// Only start watching if we are the first for the given key\n\t\tconst watcher = this.activeWatchers.get(key) || { count: 0, disposable: provider.watch(resource, options) };\n\t\tif (!this.activeWatchers.has(key)) {\n\t\t\tthis.activeWatchers.set(key, watcher);\n\t\t}\n\n\t\t// Increment usage counter\n\t\twatcher.count += 1;\n\n\t\treturn toDisposable(() => {\n\n\t\t\t// Unref\n\t\t\twatcher.count--;\n\n\t\t\t// Dispose only when last user is reached\n\t\t\tif (watcher.count === 0) {\n\t\t\t\tdispose(watcher.disposable);\n\t\t\t\tthis.activeWatchers.delete(key);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate toWatchKey(provider: IFileSystemProvider, resource: URI, options: IWatchOptions): string {\n\t\tconst { providerExtUri } = this.getExtUri(provider);\n\n\t\treturn [\n\t\t\tproviderExtUri.getComparisonKey(resource), \t// lowercase path if the provider is case insensitive\n\t\t\tString(options.recursive),\t\t\t\t\t// use recursive: true | false as part of the key\n\t\t\toptions.excludes.join()\t\t\t\t\t\t// use excludes as part of the key\n\t\t].join();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.activeWatchers.forEach(watcher => dispose(watcher.disposable));\n\t\tthis.activeWatchers.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate readonly writeQueue = this._register(new ResourceQueue());\n\n\tprivate async doWriteBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options: IWriteFileOptions | undefined, readableOrStreamOrBufferedStream: VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {\n\n\t\t\t// open handle\n\t\t\tconst handle = await provider.open(resource, { create: true, unlock: options?.unlock ?? false });\n\n\t\t\t// write into handle until all bytes from buffer have been written\n\t\t\ttry {\n\t\t\t\tif (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\n\t\t\t\t\tawait this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t\t} finally {\n\n\t\t\t\t// close handle always\n\t\t\t\tawait provider.close(handle);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async doWriteStreamBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet posInFile = 0;\n\t\tlet stream: VSBufferReadableStream;\n\n\t\t// Buffered stream: consume the buffer first by writing\n\t\t// it to the target before reading from the stream.\n\t\tif (isReadableBufferedStream(streamOrBufferedStream)) {\n\t\t\tif (streamOrBufferedStream.buffer.length > 0) {\n\t\t\t\tconst chunk = VSBuffer.concat(streamOrBufferedStream.buffer);\n\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\t\tposInFile += chunk.byteLength;\n\t\t\t}\n\n\t\t\t// If the stream has been consumed, return early\n\t\t\tif (streamOrBufferedStream.ended) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstream = streamOrBufferedStream.stream;\n\t\t}\n\n\t\t// Unbuffered stream - just take as is\n\t\telse {\n\t\t\tstream = streamOrBufferedStream;\n\t\t}\n\n\t\treturn new Promise(async (resolve, reject) => {\n\n\t\t\tlistenStream(stream, {\n\t\t\t\tonData: async chunk => {\n\n\t\t\t\t\t// pause stream to perform async write operation\n\t\t\t\t\tstream.pause();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tposInFile += chunk.byteLength;\n\n\t\t\t\t\t// resume stream now that we have successfully written\n\t\t\t\t\t// run this on the next tick to prevent increasing the\n\t\t\t\t\t// execution stack because resume() may call the event\n\t\t\t\t\t// handler again before finishing.\n\t\t\t\t\tsetTimeout(() => stream.resume());\n\t\t\t\t},\n\t\t\t\tonError: error => reject(error),\n\t\t\t\tonEnd: () => resolve()\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate async doWriteReadableBufferedQueued(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: VSBufferReadable): Promise<void> {\n\t\tlet posInFile = 0;\n\n\t\tlet chunk: VSBuffer | null;\n\t\twhile ((chunk = readable.read()) !== null) {\n\t\t\tawait this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n\t\t\tposInFile += chunk.byteLength;\n\t\t}\n\t}\n\n\tprivate async doWriteBuffer(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: VSBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n\t\tlet totalBytesWritten = 0;\n\t\twhile (totalBytesWritten < length) {\n\n\t\t\t// Write through the provider\n\t\t\tconst bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n\t\t\ttotalBytesWritten += bytesWritten;\n\t\t}\n\t}\n\n\tprivate async doWriteUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\treturn this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(() => this.doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream));\n\t}\n\n\tprivate async doWriteUnbufferedQueued(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, options: IWriteFileOptions | undefined, bufferOrReadableOrStreamOrBufferedStream: VSBuffer | VSBufferReadable | VSBufferReadableStream | VSBufferReadableBufferedStream): Promise<void> {\n\t\tlet buffer: VSBuffer;\n\t\tif (bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {\n\t\t\tbuffer = bufferOrReadableOrStreamOrBufferedStream;\n\t\t} else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await streamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\n\t\t\tbuffer = await bufferedStreamToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t} else {\n\t\t\tbuffer = readableToBuffer(bufferOrReadableOrStreamOrBufferedStream);\n\t\t}\n\n\t\t// Write through the provider\n\t\tawait provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true, unlock: options?.unlock ?? false });\n\t}\n\n\tprivate async doPipeBuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeBufferedQueued(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\tlet sourceHandle: number | undefined = undefined;\n\t\tlet targetHandle: number | undefined = undefined;\n\n\t\ttry {\n\n\t\t\t// Open handles\n\t\t\tsourceHandle = await sourceProvider.open(source, { create: false });\n\t\t\ttargetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t\tconst buffer = VSBuffer.alloc(this.BUFFER_SIZE);\n\n\t\t\tlet posInFile = 0;\n\t\t\tlet posInBuffer = 0;\n\t\t\tlet bytesRead = 0;\n\t\t\tdo {\n\t\t\t\t// read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\t\tbytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\t\t// write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) all bytes we read (bytesRead).\n\t\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n\t\t\t\tposInFile += bytesRead;\n\t\t\t\tposInBuffer += bytesRead;\n\n\t\t\t\t// when buffer full, fill it again from the beginning\n\t\t\t\tif (posInBuffer === buffer.byteLength) {\n\t\t\t\t\tposInBuffer = 0;\n\t\t\t\t}\n\t\t\t} while (bytesRead > 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait Promises.settled([\n\t\t\t\ttypeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n\t\t\t\ttypeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate async doPipeUnbuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeUnbufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\t\treturn targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true, unlock: false });\n\t}\n\n\tprivate async doPipeUnbufferedToBuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\treturn this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));\n\t}\n\n\tprivate async doPipeUnbufferedToBufferedQueued(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n\t\t// Open handle\n\t\tconst targetHandle = await targetProvider.open(target, { create: true, unlock: false });\n\n\t\t// Read entire buffer from source and write buffered\n\t\ttry {\n\t\t\tconst buffer = await sourceProvider.readFile(source);\n\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, VSBuffer.wrap(buffer), buffer.byteLength, 0, 0);\n\t\t} catch (error) {\n\t\t\tthrow ensureFileSystemProviderError(error);\n\t\t} finally {\n\t\t\tawait targetProvider.close(targetHandle);\n\t\t}\n\t}\n\n\tprivate async doPipeBufferedToUnbuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\n\t\t// Read buffer via stream buffered\n\t\tconst buffer = await streamToBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\n\n\t\t// Write buffer into target at once\n\t\tawait this.doWriteUnbuffered(targetProvider, target, undefined, buffer);\n\t}\n\n\tprotected throwIfFileSystemIsReadonly<T extends IFileSystemProvider>(provider: T, resource: URI): T {\n\t\tif (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Unable to modify readonly file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\tprivate resourceForError(resource: URI): string {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\treturn resource.fsPath;\n\t\t}\n\n\t\treturn resource.toString(true);\n\t}\n\n\t//#endregion\n}\n"]}