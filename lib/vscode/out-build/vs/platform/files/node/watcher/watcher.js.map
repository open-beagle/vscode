{"version":3,"file":"watcher.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/platform/files/node/watcher/watcher.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI as uri } from 'vs/base/common/uri';\nimport { FileChangeType, isParent, IFileChange } from 'vs/platform/files/common/files';\nimport { isLinux } from 'vs/base/common/platform';\n\nexport interface IDiskFileChange {\n\ttype: FileChangeType;\n\tpath: string;\n}\n\nexport interface ILogMessage {\n\ttype: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\tmessage: string;\n}\n\nexport function toFileChanges(changes: IDiskFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: uri.file(change.path)\n\t}));\n}\n\nexport function normalizeFileChanges(changes: IDiskFileChange[]): IDiskFileChange[] {\n\n\t// Build deltas\n\tconst normalizer = new EventNormalizer();\n\tfor (const event of changes) {\n\t\tnormalizer.processEvent(event);\n\t}\n\n\treturn normalizer.normalize();\n}\n\nclass EventNormalizer {\n\tprivate normalized: IDiskFileChange[] = [];\n\tprivate mapPathToChange: Map<string, IDiskFileChange> = new Map();\n\n\tprocessEvent(event: IDiskFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(event.path);\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// ignore CREATE followed by DELETE in one go\n\t\t\tif (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(event.path);\n\t\t\t\tthis.normalized.splice(this.normalized.indexOf(existingEvent), 1);\n\t\t\t}\n\n\t\t\t// flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise store new\n\t\telse {\n\t\t\tthis.normalized.push(event);\n\t\t\tthis.mapPathToChange.set(event.path, event);\n\t\t}\n\t}\n\n\tnormalize(): IDiskFileChange[] {\n\t\tconst addedChangeEvents: IDiskFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn this.normalized.filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddedChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.path.length - e2.path.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(d => isParent(e.path, d, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.path);\n\n\t\t\treturn true;\n\t\t}).concat(addedChangeEvents);\n\t}\n}\n"]}