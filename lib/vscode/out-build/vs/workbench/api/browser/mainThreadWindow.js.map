{"version":3,"file":"mainThreadWindow.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/api/browser/mainThreadWindow.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAWhG,IAAa,gBAAgB,GAA7B,MAAa,gBAAgB;QAM5B,YACC,cAA+B,EACA,WAAyB,EACvB,aAA6B;YAD/B,gBAAW,GAAX,WAAW,CAAc;YACvB,kBAAa,GAAb,aAAa,CAAgB;YAN9C,gBAAW,GAAG,IAAI,2BAAe,EAAE,CAAC;YACpC,aAAQ,GAAG,IAAI,GAAG,EAAuB,CAAC;YAO1D,IAAI,CAAC,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,iCAAc,CAAC,aAAa,CAAC,CAAC;YAEnE,aAAK,CAAC,KAAK,CAAC,WAAW,CAAC,gBAAgB,CAAC,CACvC,IAAI,CAAC,KAAK,CAAC,uBAAuB,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QACrE,CAAC;QAED,OAAO;YACN,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;YAE3B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE;gBAC3C,KAAK,CAAC,OAAO,EAAE,CAAC;aAChB;YACD,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;QACvB,CAAC;QAED,oBAAoB;YACnB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QACnD,CAAC;QAED,KAAK,CAAC,QAAQ,CAAC,aAA4B,EAAE,SAA6B,EAAE,OAAwB;YACnG,MAAM,GAAG,GAAG,SAAG,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YACpC,IAAI,MAAoB,CAAC;YACzB,IAAI,SAAS,IAAI,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,QAAQ,EAAE,KAAK,GAAG,CAAC,QAAQ,EAAE,EAAE;gBACpE,mEAAmE;gBACnE,MAAM,GAAG,SAAS,CAAC;aACnB;iBAAM;gBACN,4CAA4C;gBAC5C,MAAM,GAAG,GAAG,CAAC;aACb;YACD,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,EAAE;gBACtC,YAAY,EAAE,IAAI;gBAClB,cAAc,EAAE,OAAO,CAAC,cAAc;gBACtC,uBAAuB,EAAE,OAAO,CAAC,uBAAuB;aACxD,CAAC,CAAC;QACJ,CAAC;QAED,KAAK,CAAC,cAAc,CAAC,aAA4B,EAAE,OAAwB;YAC1E,MAAM,GAAG,GAAG,SAAG,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;YACtC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;YACzE,OAAO,MAAM,CAAC,QAAQ,CAAC;QACxB,CAAC;KACD,CAAA;IApDY,gBAAgB;QAD5B,CAAA,GAAA,uCAAoB,CAAA,CAAC,8BAAW,CAAC,gBAAgB,CAAC;QAShD,WAAA,mBAAY,CAAA;QACZ,WAAA,uBAAc,CAAA;OATJ,gBAAgB,CAoD5B;IApDY,4CAAgB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { DisposableStore, IDisposable } from 'vs/base/common/lifecycle';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { IOpenerService } from 'vs/platform/opener/common/opener';\nimport { extHostNamedCustomer } from 'vs/workbench/api/common/extHostCustomers';\nimport { ExtHostContext, ExtHostWindowShape, IExtHostContext, IOpenUriOptions, MainContext, MainThreadWindowShape } from '../common/extHost.protocol';\nimport { IHostService } from 'vs/workbench/services/host/browser/host';\n\n@extHostNamedCustomer(MainContext.MainThreadWindow)\nexport class MainThreadWindow implements MainThreadWindowShape {\n\n\tprivate readonly proxy: ExtHostWindowShape;\n\tprivate readonly disposables = new DisposableStore();\n\tprivate readonly resolved = new Map<number, IDisposable>();\n\n\tconstructor(\n\t\textHostContext: IExtHostContext,\n\t\t@IHostService private readonly hostService: IHostService,\n\t\t@IOpenerService private readonly openerService: IOpenerService,\n\t) {\n\t\tthis.proxy = extHostContext.getProxy(ExtHostContext.ExtHostWindow);\n\n\t\tEvent.latch(hostService.onDidChangeFocus)\n\t\t\t(this.proxy.$onDidChangeWindowFocus, this.proxy, this.disposables);\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.dispose();\n\n\t\tfor (const value of this.resolved.values()) {\n\t\t\tvalue.dispose();\n\t\t}\n\t\tthis.resolved.clear();\n\t}\n\n\t$getWindowVisibility(): Promise<boolean> {\n\t\treturn Promise.resolve(this.hostService.hasFocus);\n\t}\n\n\tasync $openUri(uriComponents: UriComponents, uriString: string | undefined, options: IOpenUriOptions): Promise<boolean> {\n\t\tconst uri = URI.from(uriComponents);\n\t\tlet target: URI | string;\n\t\tif (uriString && URI.parse(uriString).toString() === uri.toString()) {\n\t\t\t// called with string and no transformation happened -> keep string\n\t\t\ttarget = uriString;\n\t\t} else {\n\t\t\t// called with URI or transformed -> use uri\n\t\t\ttarget = uri;\n\t\t}\n\t\treturn this.openerService.open(target, {\n\t\t\topenExternal: true,\n\t\t\tallowTunneling: options.allowTunneling,\n\t\t\tallowContributedOpeners: options.allowContributedOpeners,\n\t\t});\n\t}\n\n\tasync $asExternalUri(uriComponents: UriComponents, options: IOpenUriOptions): Promise<UriComponents> {\n\t\tconst uri = URI.revive(uriComponents);\n\t\tconst result = await this.openerService.resolveExternalUri(uri, options);\n\t\treturn result.resolved;\n\t}\n}\n"]}