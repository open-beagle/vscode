{"version":3,"sources":["vs/workbench/browser/editor.ts"],"names":[],"mappings":"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","file":"editor.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { EditorInput, EditorResourceAccessor, IEditorInput, EditorExtensions, SideBySideEditor } from 'vs/workbench/common/editor';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { EditorPane } from 'vs/workbench/browser/parts/editor/editorPane';\nimport { IConstructorSignature0, IInstantiationService, BrandedService, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { insert } from 'vs/base/common/arrays';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { Promises } from 'vs/base/common/async';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IUriIdentityService } from 'vs/workbench/services/uriIdentity/common/uriIdentity';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { URI } from 'vs/workbench/workbench.web.api';\nimport { IEditorGroup } from 'vs/workbench/services/editor/common/editorGroupsService';\n\n//#region Editors Registry\n\nexport interface IEditorDescriptor {\n\n\t/**\n\t * The unique identifier of the editor\n\t */\n\tgetId(): string;\n\n\t/**\n\t * The display name of the editor\n\t */\n\tgetName(): string;\n\n\tinstantiate(instantiationService: IInstantiationService): EditorPane;\n\n\tdescribes(obj: unknown): boolean;\n}\n\nexport interface IEditorRegistry {\n\n\t/**\n\t * Registers an editor to the platform for the given input type. The second parameter also supports an\n\t * array of input classes to be passed in. If the more than one editor is registered for the same editor\n\t * input, the input itself will be asked which editor it prefers if this method is provided. Otherwise\n\t * the first editor in the list will be returned.\n\t *\n\t * @param inputDescriptors A set of constructor functions that return an instance of EditorInput for which the\n\t * registered editor should be used for.\n\t */\n\tregisterEditor(descriptor: IEditorDescriptor, inputDescriptors: readonly SyncDescriptor<EditorInput>[]): IDisposable;\n\n\t/**\n\t * Returns the editor descriptor for the given input or `undefined` if none.\n\t */\n\tgetEditor(input: EditorInput): IEditorDescriptor | undefined;\n\n\t/**\n\t * Returns the editor descriptor for the given identifier or `undefined` if none.\n\t */\n\tgetEditorById(editorId: string): IEditorDescriptor | undefined;\n\n\t/**\n\t * Returns an array of registered editors known to the platform.\n\t */\n\tgetEditors(): readonly IEditorDescriptor[];\n}\n\n/**\n * A lightweight descriptor of an editor. The descriptor is deferred so that heavy editors\n * can load lazily in the workbench.\n */\nexport class EditorDescriptor implements IEditorDescriptor {\n\n\tstatic create<Services extends BrandedService[]>(\n\t\tctor: { new(...services: Services): EditorPane },\n\t\tid: string,\n\t\tname: string\n\t): EditorDescriptor {\n\t\treturn new EditorDescriptor(ctor as IConstructorSignature0<EditorPane>, id, name);\n\t}\n\n\tconstructor(\n\t\tprivate readonly ctor: IConstructorSignature0<EditorPane>,\n\t\tprivate readonly id: string,\n\t\tprivate readonly name: string\n\t) { }\n\n\tinstantiate(instantiationService: IInstantiationService): EditorPane {\n\t\treturn instantiationService.createInstance(this.ctor);\n\t}\n\n\tgetId(): string {\n\t\treturn this.id;\n\t}\n\n\tgetName(): string {\n\t\treturn this.name;\n\t}\n\n\tdescribes(obj: unknown): boolean {\n\t\treturn obj instanceof EditorPane && obj.getId() === this.id;\n\t}\n}\n\nclass EditorRegistry implements IEditorRegistry {\n\n\tprivate readonly editors: EditorDescriptor[] = [];\n\tprivate readonly mapEditorToInputs = new Map<EditorDescriptor, readonly SyncDescriptor<EditorInput>[]>();\n\n\tregisterEditor(descriptor: EditorDescriptor, inputDescriptors: readonly SyncDescriptor<EditorInput>[]): IDisposable {\n\t\tthis.mapEditorToInputs.set(descriptor, inputDescriptors);\n\n\t\tconst remove = insert(this.editors, descriptor);\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.mapEditorToInputs.delete(descriptor);\n\t\t\tremove();\n\t\t});\n\t}\n\n\tgetEditor(input: EditorInput): EditorDescriptor | undefined {\n\t\tconst findEditorDescriptors = (input: EditorInput, byInstanceOf?: boolean): EditorDescriptor[] => {\n\t\t\tconst matchingDescriptors: EditorDescriptor[] = [];\n\n\t\t\tfor (const editor of this.editors) {\n\t\t\t\tconst inputDescriptors = this.mapEditorToInputs.get(editor) || [];\n\t\t\t\tfor (const inputDescriptor of inputDescriptors) {\n\t\t\t\t\tconst inputClass = inputDescriptor.ctor;\n\n\t\t\t\t\t// Direct check on constructor type (ignores prototype chain)\n\t\t\t\t\tif (!byInstanceOf && input.constructor === inputClass) {\n\t\t\t\t\t\tmatchingDescriptors.push(editor);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Normal instanceof check\n\t\t\t\t\telse if (byInstanceOf && input instanceof inputClass) {\n\t\t\t\t\t\tmatchingDescriptors.push(editor);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no descriptors found, continue search using instanceof and prototype chain\n\t\t\tif (!byInstanceOf && matchingDescriptors.length === 0) {\n\t\t\t\treturn findEditorDescriptors(input, true);\n\t\t\t}\n\n\t\t\tif (byInstanceOf) {\n\t\t\t\treturn matchingDescriptors;\n\t\t\t}\n\n\t\t\treturn matchingDescriptors;\n\t\t};\n\n\t\tconst descriptors = findEditorDescriptors(input);\n\t\tif (descriptors.length > 0) {\n\n\t\t\t// Ask the input for its preferred Editor\n\t\t\tconst preferredEditorId = input.getPreferredEditorId(descriptors.map(descriptor => descriptor.getId()));\n\t\t\tif (preferredEditorId) {\n\t\t\t\treturn this.getEditorById(preferredEditorId);\n\t\t\t}\n\n\t\t\t// Otherwise, first come first serve\n\t\t\treturn descriptors[0];\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetEditorById(editorId: string): EditorDescriptor | undefined {\n\t\treturn this.editors.find(editor => editor.getId() === editorId);\n\t}\n\n\tgetEditors(): readonly EditorDescriptor[] {\n\t\treturn this.editors.slice(0);\n\t}\n\n\tgetEditorInputs(): SyncDescriptor<EditorInput>[] {\n\t\tconst inputClasses: SyncDescriptor<EditorInput>[] = [];\n\t\tfor (const editor of this.editors) {\n\t\t\tconst editorInputDescriptors = this.mapEditorToInputs.get(editor);\n\t\t\tif (editorInputDescriptors) {\n\t\t\t\tinputClasses.push(...editorInputDescriptors.map(descriptor => descriptor.ctor));\n\t\t\t}\n\t\t}\n\n\t\treturn inputClasses;\n\t}\n}\n\nRegistry.add(EditorExtensions.Editors, new EditorRegistry());\n\n//#endregion\n\n//#region Editor Close Tracker\n\nexport function whenEditorClosed(accessor: ServicesAccessor, resources: URI[]): Promise<void> {\n\tconst editorService = accessor.get(IEditorService);\n\tconst uriIdentityService = accessor.get(IUriIdentityService);\n\tconst workingCopyService = accessor.get(IWorkingCopyService);\n\n\treturn new Promise(resolve => {\n\t\tlet remainingResources = [...resources];\n\n\t\t// Observe any editor closing from this moment on\n\t\tconst listener = editorService.onDidCloseEditor(async event => {\n\t\t\tconst primaryResource = EditorResourceAccessor.getOriginalUri(event.editor, { supportSideBySide: SideBySideEditor.PRIMARY });\n\t\t\tconst secondaryResource = EditorResourceAccessor.getOriginalUri(event.editor, { supportSideBySide: SideBySideEditor.SECONDARY });\n\n\t\t\t// Remove from resources to wait for being closed based on the\n\t\t\t// resources from editors that got closed\n\t\t\tremainingResources = remainingResources.filter(resource => {\n\t\t\t\tif (uriIdentityService.extUri.isEqual(resource, primaryResource) || uriIdentityService.extUri.isEqual(resource, secondaryResource)) {\n\t\t\t\t\treturn false; // remove - the closing editor matches this resource\n\t\t\t\t}\n\n\t\t\t\treturn true; // keep - not yet closed\n\t\t\t});\n\n\t\t\t// All resources to wait for being closed are closed\n\t\t\tif (remainingResources.length === 0) {\n\n\t\t\t\t// If auto save is configured with the default delay (1s) it is possible\n\t\t\t\t// to close the editor while the save still continues in the background. As such\n\t\t\t\t// we have to also check if the editors to track for are dirty and if so wait\n\t\t\t\t// for them to get saved.\n\t\t\t\tconst dirtyResources = resources.filter(resource => workingCopyService.isDirty(resource));\n\t\t\t\tif (dirtyResources.length > 0) {\n\t\t\t\t\tawait Promises.settled(dirtyResources.map(async resource => await new Promise<void>(resolve => {\n\t\t\t\t\t\tif (!workingCopyService.isDirty(resource)) {\n\t\t\t\t\t\t\treturn resolve(); // return early if resource is not dirty\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise resolve promise when resource is saved\n\t\t\t\t\t\tconst listener = workingCopyService.onDidChangeDirty(workingCopy => {\n\t\t\t\t\t\t\tif (!workingCopy.isDirty() && uriIdentityService.extUri.isEqual(resource, workingCopy.resource)) {\n\t\t\t\t\t\t\t\tlistener.dispose();\n\n\t\t\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})));\n\t\t\t\t}\n\n\t\t\t\tlistener.dispose();\n\n\t\t\t\treturn resolve();\n\t\t\t}\n\t\t});\n\t});\n}\n\n//#endregion\n\n\n//#region ARIA\n\nexport function computeEditorAriaLabel(input: IEditorInput, index: number | undefined, group: IEditorGroup | undefined, groupCount: number): string {\n\tlet ariaLabel = input.getAriaLabel();\n\tif (group && !group.isPinned(input)) {\n\t\tariaLabel = localize('preview', \"{0}, preview\", ariaLabel);\n\t}\n\n\tif (group?.isSticky(index ?? input)) {\n\t\tariaLabel = localize('pinned', \"{0}, pinned\", ariaLabel);\n\t}\n\n\t// Apply group information to help identify in\n\t// which group we are (only if more than one group\n\t// is actually opened)\n\tif (group && groupCount > 1) {\n\t\tariaLabel = `${ariaLabel}, ${group.ariaLabel}`;\n\t}\n\n\treturn ariaLabel;\n}\n\n//#endregion\n"]}