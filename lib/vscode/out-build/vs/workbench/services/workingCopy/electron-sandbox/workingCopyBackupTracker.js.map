{"version":3,"sources":["vs/workbench/services/workingCopy/electron-sandbox/workingCopyBackupTracker.ts"],"names":[],"mappings":"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","file":"workingCopyBackupTracker.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { IWorkbenchContribution } from 'vs/workbench/common/contributions';\nimport { IFilesConfigurationService, AutoSaveMode } from 'vs/workbench/services/filesConfiguration/common/filesConfigurationService';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { IWorkingCopy, WorkingCopyCapabilities } from 'vs/workbench/services/workingCopy/common/workingCopy';\nimport { ILifecycleService, ShutdownReason } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { ConfirmResult, IFileDialogService, IDialogService, getFileNamesMessage } from 'vs/platform/dialogs/common/dialogs';\nimport Severity from 'vs/base/common/severity';\nimport { WorkbenchState, IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport { HotExitConfiguration } from 'vs/platform/files/common/files';\nimport { INativeHostService } from 'vs/platform/native/electron-sandbox/native';\nimport { WorkingCopyBackupTracker } from 'vs/workbench/services/workingCopy/common/workingCopyBackupTracker';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { SaveReason } from 'vs/workbench/common/editor';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { IProgressService, ProgressLocation } from 'vs/platform/progress/common/progress';\nimport { Promises, raceCancellation } from 'vs/base/common/async';\nimport { IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { IWorkingCopyEditorService } from 'vs/workbench/services/workingCopy/common/workingCopyEditorService';\n\nexport class NativeWorkingCopyBackupTracker extends WorkingCopyBackupTracker implements IWorkbenchContribution {\n\n\tconstructor(\n\t\t@IWorkingCopyBackupService workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IFilesConfigurationService filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t@ILifecycleService lifecycleService: ILifecycleService,\n\t\t@IFileDialogService private readonly fileDialogService: IFileDialogService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@INativeHostService private readonly nativeHostService: INativeHostService,\n\t\t@ILogService logService: ILogService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@IProgressService private readonly progressService: IProgressService,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IWorkingCopyEditorService workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService editorService: IEditorService\n\t) {\n\t\tsuper(workingCopyBackupService, workingCopyService, logService, lifecycleService, filesConfigurationService, workingCopyEditorService, editorService);\n\t}\n\n\tprotected onBeforeShutdown(reason: ShutdownReason): boolean | Promise<boolean> {\n\n\t\t// Dirty working copies need treatment on shutdown\n\t\tconst dirtyWorkingCopies = this.workingCopyService.dirtyWorkingCopies;\n\t\tif (dirtyWorkingCopies.length) {\n\t\t\treturn this.onBeforeShutdownWithDirty(reason, dirtyWorkingCopies);\n\t\t}\n\n\t\t// No dirty working copies\n\t\treturn this.onBeforeShutdownWithoutDirty();\n\t}\n\n\tprotected async onBeforeShutdownWithDirty(reason: ShutdownReason, dirtyWorkingCopies: readonly IWorkingCopy[]): Promise<boolean> {\n\n\t\t// If auto save is enabled, save all non-untitled working copies\n\t\t// and then check again for dirty copies\n\t\tif (this.filesConfigurationService.getAutoSaveMode() !== AutoSaveMode.OFF) {\n\n\t\t\t// Save all dirty working copies\n\t\t\ttry {\n\t\t\t\tawait this.doSaveAllBeforeShutdown(false /* not untitled */, SaveReason.AUTO);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[backup tracker] error saving dirty working copies: ${error}`); // guard against misbehaving saves, we handle remaining dirty below\n\t\t\t}\n\n\t\t\t// If we still have dirty working copies, we either have untitled ones or working copies that cannot be saved\n\t\t\tconst remainingDirtyWorkingCopies = this.workingCopyService.dirtyWorkingCopies;\n\t\t\tif (remainingDirtyWorkingCopies.length) {\n\t\t\t\treturn this.handleDirtyBeforeShutdown(remainingDirtyWorkingCopies, reason);\n\t\t\t}\n\n\t\t\treturn false; // no veto (there are no remaining dirty working copies)\n\t\t}\n\n\t\t// Auto save is not enabled\n\t\treturn this.handleDirtyBeforeShutdown(dirtyWorkingCopies, reason);\n\t}\n\n\tprivate async handleDirtyBeforeShutdown(dirtyWorkingCopies: readonly IWorkingCopy[], reason: ShutdownReason): Promise<boolean> {\n\n\t\t// Trigger backup if configured\n\t\tlet backups: IWorkingCopy[] = [];\n\t\tlet backupError: Error | undefined = undefined;\n\t\tif (this.filesConfigurationService.isHotExitEnabled) {\n\t\t\ttry {\n\t\t\t\tconst backupResult = await this.backupBeforeShutdown(dirtyWorkingCopies, reason);\n\t\t\t\tbackups = backupResult.backups;\n\t\t\t\tbackupError = backupResult.error;\n\n\t\t\t\tif (backups.length === dirtyWorkingCopies.length) {\n\t\t\t\t\treturn false; // no veto (backup was successful for all working copies)\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tbackupError = error;\n\t\t\t}\n\t\t}\n\n\t\tconst remainingDirtyWorkingCopies = dirtyWorkingCopies.filter(workingCopy => !backups.includes(workingCopy));\n\n\t\t// We ran a backup but received an error that we show to the user\n\t\tif (backupError) {\n\t\t\tif (this.environmentService.isExtensionDevelopment) {\n\t\t\t\tthis.logService.error(`[backup tracker] error creating backups: ${backupError}`);\n\n\t\t\t\treturn false; // do not block shutdown during extension development (https://github.com/microsoft/vscode/issues/115028)\n\t\t\t}\n\n\t\t\tthis.showErrorDialog(localize('backupTrackerBackupFailed', \"The following dirty editors could not be saved to the back up location.\"), remainingDirtyWorkingCopies, backupError);\n\n\t\t\treturn true; // veto (the backup failed)\n\t\t}\n\n\t\t// Since a backup did not happen, we have to confirm for\n\t\t// the working copies that did not successfully backup\n\t\ttry {\n\t\t\treturn await this.confirmBeforeShutdown(remainingDirtyWorkingCopies);\n\t\t} catch (error) {\n\t\t\tif (this.environmentService.isExtensionDevelopment) {\n\t\t\t\tthis.logService.error(`[backup tracker] error saving or reverting dirty working copies: ${error}`);\n\n\t\t\t\treturn false; // do not block shutdown during extension development (https://github.com/microsoft/vscode/issues/115028)\n\t\t\t}\n\n\t\t\tthis.showErrorDialog(localize('backupTrackerConfirmFailed', \"The following dirty editors could not be saved or reverted.\"), remainingDirtyWorkingCopies, error);\n\n\t\t\treturn true; // veto (save or revert failed)\n\t\t}\n\t}\n\n\tprivate showErrorDialog(msg: string, workingCopies: readonly IWorkingCopy[], error?: Error): void {\n\t\tconst dirtyWorkingCopies = workingCopies.filter(workingCopy => workingCopy.isDirty());\n\n\t\tconst advice = localize('backupErrorDetails', \"Try saving or reverting the dirty editors first and then try again.\");\n\t\tconst detail = dirtyWorkingCopies.length\n\t\t\t? getFileNamesMessage(dirtyWorkingCopies.map(x => x.name)) + '\\n' + advice\n\t\t\t: advice;\n\n\t\tthis.dialogService.show(Severity.Error, msg, [localize('ok', 'OK')], { detail });\n\n\t\tthis.logService.error(error ? `[backup tracker] ${msg}: ${error}` : `[backup tracker] ${msg}`);\n\t}\n\n\tprivate async backupBeforeShutdown(dirtyWorkingCopies: readonly IWorkingCopy[], reason: ShutdownReason): Promise<{ backups: IWorkingCopy[], error?: Error }> {\n\n\t\t// When quit is requested skip the confirm callback and attempt to backup all workspaces.\n\t\t// When quit is not requested the confirm callback should be shown when the window being\n\t\t// closed is the only VS Code window open, except for on Mac where hot exit is only\n\t\t// ever activated when quit is requested.\n\n\t\tlet doBackup: boolean | undefined;\n\t\tif (this.environmentService.isExtensionDevelopment) {\n\t\t\tdoBackup = true; // always backup closing extension development window without asking to speed up debugging\n\t\t} else {\n\t\t\tswitch (reason) {\n\t\t\t\tcase ShutdownReason.CLOSE:\n\t\t\t\t\tif (this.contextService.getWorkbenchState() !== WorkbenchState.EMPTY && this.filesConfigurationService.hotExitConfiguration === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n\t\t\t\t\t\tdoBackup = true; // backup if a folder is open and onExitAndWindowClose is configured\n\t\t\t\t\t} else if (await this.nativeHostService.getWindowCount() > 1 || isMacintosh) {\n\t\t\t\t\t\tdoBackup = false; // do not backup if a window is closed that does not cause quitting of the application\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoBackup = true; // backup if last window is closed on win/linux where the application quits right after\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShutdownReason.QUIT:\n\t\t\t\t\tdoBackup = true; // backup because next start we restore all backups\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShutdownReason.RELOAD:\n\t\t\t\t\tdoBackup = true; // backup because after window reload, backups restore\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShutdownReason.LOAD:\n\t\t\t\t\tif (this.contextService.getWorkbenchState() !== WorkbenchState.EMPTY && this.filesConfigurationService.hotExitConfiguration === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n\t\t\t\t\t\tdoBackup = true; // backup if a folder is open and onExitAndWindowClose is configured\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoBackup = false; // do not backup because we are switching contexts\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!doBackup) {\n\t\t\treturn { backups: [] };\n\t\t}\n\n\t\treturn this.doBackupBeforeShutdown(dirtyWorkingCopies);\n\t}\n\n\tprivate async doBackupBeforeShutdown(dirtyWorkingCopies: readonly IWorkingCopy[]): Promise<{ backups: IWorkingCopy[], error?: Error }> {\n\t\tconst backups: IWorkingCopy[] = [];\n\t\tlet error: Error | undefined = undefined;\n\n\t\tawait this.withProgressAndCancellation(async token => {\n\n\t\t\t// Perform a backup of all dirty working copies unless a backup already exists\n\t\t\ttry {\n\t\t\t\tawait Promises.settled(dirtyWorkingCopies.map(async workingCopy => {\n\t\t\t\t\tconst contentVersion = this.getContentVersion(workingCopy);\n\n\t\t\t\t\t// Backup exists\n\t\t\t\t\tif (this.workingCopyBackupService.hasBackupSync(workingCopy, contentVersion)) {\n\t\t\t\t\t\tbackups.push(workingCopy);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Backup does not exist\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst backup = await workingCopy.backup(token);\n\t\t\t\t\t\tawait this.workingCopyBackupService.backup(workingCopy, backup.content, contentVersion, backup.meta, token);\n\n\t\t\t\t\t\tbackups.push(workingCopy);\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t} catch (backupError) {\n\t\t\t\terror = backupError;\n\t\t\t}\n\t\t}, localize('backupBeforeShutdown', \"Waiting for dirty editors to backup...\"));\n\n\t\treturn { backups, error };\n\t}\n\n\tprivate async confirmBeforeShutdown(dirtyWorkingCopies: IWorkingCopy[]): Promise<boolean> {\n\n\t\t// Save\n\t\tconst confirm = await this.fileDialogService.showSaveConfirm(dirtyWorkingCopies.map(workingCopy => workingCopy.name));\n\t\tif (confirm === ConfirmResult.SAVE) {\n\t\t\tconst dirtyCountBeforeSave = this.workingCopyService.dirtyCount;\n\n\t\t\ttry {\n\t\t\t\tawait this.doSaveAllBeforeShutdown(dirtyWorkingCopies, SaveReason.EXPLICIT);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[backup tracker] error saving dirty working copies: ${error}`); // guard against misbehaving saves, we handle remaining dirty below\n\t\t\t}\n\n\t\t\tconst savedWorkingCopies = dirtyCountBeforeSave - this.workingCopyService.dirtyCount;\n\t\t\tif (savedWorkingCopies < dirtyWorkingCopies.length) {\n\t\t\t\treturn true; // veto (save failed or was canceled)\n\t\t\t}\n\n\t\t\treturn this.noVeto(dirtyWorkingCopies); // no veto (dirty saved)\n\t\t}\n\n\t\t// Don't Save\n\t\telse if (confirm === ConfirmResult.DONT_SAVE) {\n\t\t\ttry {\n\t\t\t\tawait this.doRevertAllBeforeShutdown(dirtyWorkingCopies);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[backup tracker] error reverting dirty working copies: ${error}`); // do not block the shutdown on errors from revert\n\t\t\t}\n\n\t\t\treturn this.noVeto(dirtyWorkingCopies); // no veto (dirty reverted)\n\t\t}\n\n\t\t// Cancel\n\t\treturn true; // veto (user canceled)\n\t}\n\n\tprivate doSaveAllBeforeShutdown(dirtyWorkingCopies: IWorkingCopy[], reason: SaveReason): Promise<void>;\n\tprivate doSaveAllBeforeShutdown(includeUntitled: boolean, reason: SaveReason): Promise<void>;\n\tprivate doSaveAllBeforeShutdown(arg1: IWorkingCopy[] | boolean, reason: SaveReason): Promise<void> {\n\t\tconst dirtyWorkingCopies = Array.isArray(arg1) ? arg1 : this.workingCopyService.dirtyWorkingCopies.filter(workingCopy => {\n\t\t\tif (arg1 === false && (workingCopy.capabilities & WorkingCopyCapabilities.Untitled)) {\n\t\t\t\treturn false; // skip untitled unless explicitly included\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\treturn this.withProgressAndCancellation(async () => {\n\n\t\t\t// Skip save participants on shutdown for performance reasons\n\t\t\tconst saveOptions = { skipSaveParticipants: true, reason };\n\n\t\t\t// First save through the editor service if we save all to benefit\n\t\t\t// from some extras like switching to untitled dirty editors before saving.\n\t\t\tlet result: boolean | undefined = undefined;\n\t\t\tif (typeof arg1 === 'boolean' || dirtyWorkingCopies.length === this.workingCopyService.dirtyCount) {\n\t\t\t\tresult = await this.editorService.saveAll({ includeUntitled: typeof arg1 === 'boolean' ? arg1 : true, ...saveOptions });\n\t\t\t}\n\n\t\t\t// If we still have dirty working copies, save those directly\n\t\t\t// unless the save was not successful (e.g. cancelled)\n\t\t\tif (result !== false) {\n\t\t\t\tawait Promises.settled(dirtyWorkingCopies.map(workingCopy => workingCopy.isDirty() ? workingCopy.save(saveOptions) : Promise.resolve(true)));\n\t\t\t}\n\t\t}, localize('saveBeforeShutdown', \"Waiting for dirty editors to save...\"));\n\t}\n\n\tprivate doRevertAllBeforeShutdown(dirtyWorkingCopies: IWorkingCopy[]): Promise<void> {\n\t\treturn this.withProgressAndCancellation(async () => {\n\n\t\t\t// Soft revert is good enough on shutdown\n\t\t\tconst revertOptions = { soft: true };\n\n\t\t\t// First revert through the editor service if we revert all\n\t\t\tif (dirtyWorkingCopies.length === this.workingCopyService.dirtyCount) {\n\t\t\t\tawait this.editorService.revertAll(revertOptions);\n\t\t\t}\n\n\t\t\t// If we still have dirty working copies, revert those directly\n\t\t\t// unless the revert operation was not successful (e.g. cancelled)\n\t\t\tawait Promises.settled(dirtyWorkingCopies.map(workingCopy => workingCopy.isDirty() ? workingCopy.revert(revertOptions) : Promise.resolve()));\n\t\t}, localize('revertBeforeShutdown', \"Waiting for dirty editors to revert...\"));\n\t}\n\n\tprivate withProgressAndCancellation(promiseFactory: (token: CancellationToken) => Promise<void>, title: string): Promise<void> {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\treturn this.progressService.withProgress({\n\t\t\tlocation: ProgressLocation.Notification,\n\t\t\tcancellable: true, // for issues such as https://github.com/microsoft/vscode/issues/112278\n\t\t\tdelay: 800, // delay notification so that it only appears when operation takes a long time\n\t\t\ttitle\n\t\t}, () => raceCancellation(promiseFactory(cts.token), cts.token), () => cts.dispose(true));\n\t}\n\n\tprivate noVeto(backupsToDiscard: IWorkingCopy[]): boolean | Promise<boolean> {\n\t\tif (!this.editorGroupService.isRestored()) {\n\t\t\treturn false; // if editors have not restored, we are very likely not up to speed with backups and thus should not discard them\n\t\t}\n\n\t\treturn Promises.settled(backupsToDiscard.map(workingCopy => this.workingCopyBackupService.discardBackup(workingCopy))).then(() => false, () => false);\n\t}\n\n\tprivate async onBeforeShutdownWithoutDirty(): Promise<boolean> {\n\n\t\t// If we have proceeded enough that editors and dirty state\n\t\t// has restored, we make sure that no backups lure around\n\t\t// given we have no known dirty working copy. This helps\n\t\t// to clean up stale backups as for example reported in\n\t\t// https://github.com/microsoft/vscode/issues/92962\n\t\t//\n\t\t// However, we never want to discard backups that we know\n\t\t// were not restored in the session.\n\t\tif (this.editorGroupService.isRestored()) {\n\t\t\ttry {\n\n\t\t\t\t// Backups without `typeId` are handed in the legacy backup\n\t\t\t\t// restorer still and thus we explicitly don't want to keep\n\t\t\t\t// them on shutdown, otherwise they would always come back.\n\t\t\t\t// TODO@bpasero remove this check once typeId has been adopted.\n\t\t\t\tconst backupsToKeep = Array.from(this.unrestoredBackups).filter(unrestoredBackup => unrestoredBackup.typeId.length > 0);\n\t\t\t\tawait this.workingCopyBackupService.discardBackups(backupsToKeep);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`[backup tracker] error discarding backups: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\treturn false; // no veto (no dirty)\n\t}\n}\n"]}