{"version":3,"file":"workingCopyBackupService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/workingCopy/common/workingCopyBackupService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { basename, isEqual, joinPath } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { equals, deepClone } from 'vs/base/common/objects';\nimport { Promises, ResourceQueue } from 'vs/base/common/async';\nimport { IResolvedWorkingCopyBackup, IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { IFileService, FileOperationError, FileOperationResult } from 'vs/platform/files/common/files';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { isReadableStream, peekStream } from 'vs/base/common/stream';\nimport { bufferToStream, prefixedBufferReadable, prefixedBufferStream, readableToBuffer, streamToBuffer, VSBuffer, VSBufferReadable, VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Schemas } from 'vs/base/common/network';\nimport { hash } from 'vs/base/common/hash';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { IWorkbenchContributionsRegistry, Extensions as WorkbenchExtensions } from 'vs/workbench/common/contributions';\nimport { LegacyWorkingCopyBackupRestorer } from 'vs/workbench/services/workingCopy/common/legacyBackupRestorer';\nimport { LifecyclePhase } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { isEmptyObject } from 'vs/base/common/types';\nimport { IWorkingCopyBackupMeta, IWorkingCopyIdentifier } from 'vs/workbench/services/workingCopy/common/workingCopy';\n\nexport class WorkingCopyBackupsModel {\n\n\tprivate readonly cache = new ResourceMap<{ versionId?: number, meta?: IWorkingCopyBackupMeta }>();\n\n\tstatic async create(backupRoot: URI, fileService: IFileService): Promise<WorkingCopyBackupsModel> {\n\t\tconst model = new WorkingCopyBackupsModel(backupRoot, fileService);\n\n\t\tawait model.resolve();\n\n\t\treturn model;\n\t}\n\n\tprivate constructor(private backupRoot: URI, private fileService: IFileService) { }\n\n\tprivate async resolve(): Promise<void> {\n\t\ttry {\n\t\t\tconst backupRootStat = await this.fileService.resolve(this.backupRoot);\n\t\t\tif (backupRootStat.children) {\n\t\t\t\tawait Promises.settled(backupRootStat.children\n\t\t\t\t\t.filter(child => child.isDirectory)\n\t\t\t\t\t.map(async backupSchemaFolder => {\n\n\t\t\t\t\t\t// Read backup directory for backups\n\t\t\t\t\t\tconst backupSchemaFolderStat = await this.fileService.resolve(backupSchemaFolder.resource);\n\n\t\t\t\t\t\t// Remember known backups in our caches\n\t\t\t\t\t\tif (backupSchemaFolderStat.children) {\n\t\t\t\t\t\t\tfor (const backupForSchema of backupSchemaFolderStat.children) {\n\t\t\t\t\t\t\t\tif (!backupForSchema.isDirectory) {\n\t\t\t\t\t\t\t\t\tthis.add(backupForSchema.resource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore any errors\n\t\t}\n\t}\n\n\tadd(resource: URI, versionId = 0, meta?: IWorkingCopyBackupMeta): void {\n\t\tthis.cache.set(resource, { versionId, meta: deepClone(meta) }); // make sure to not store original meta in our cache...\n\t}\n\n\tcount(): number {\n\t\treturn this.cache.size;\n\t}\n\n\thas(resource: URI, versionId?: number, meta?: IWorkingCopyBackupMeta): boolean {\n\t\tconst entry = this.cache.get(resource);\n\t\tif (!entry) {\n\t\t\treturn false; // unknown resource\n\t\t}\n\n\t\tif (typeof versionId === 'number' && versionId !== entry.versionId) {\n\t\t\treturn false; // different versionId\n\t\t}\n\n\t\tif (meta && !equals(meta, entry.meta)) {\n\t\t\treturn false; // different metadata\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget(): URI[] {\n\t\treturn Array.from(this.cache.keys());\n\t}\n\n\tremove(resource: URI): void {\n\t\tthis.cache.delete(resource);\n\t}\n\n\tmove(source: URI, target: URI): void {\n\t\tconst entry = this.cache.get(source);\n\t\tif (entry) {\n\t\t\tthis.cache.delete(source);\n\t\t\tthis.cache.set(target, entry);\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis.cache.clear();\n\t}\n}\n\nexport abstract class WorkingCopyBackupService implements IWorkingCopyBackupService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate impl: NativeWorkingCopyBackupServiceImpl | InMemoryWorkingCopyBackupService;\n\n\tconstructor(\n\t\tbackupWorkspaceHome: URI | undefined,\n\t\t@IFileService protected fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tthis.impl = this.initialize(backupWorkspaceHome);\n\t}\n\n\tprivate initialize(backupWorkspaceHome: URI | undefined): NativeWorkingCopyBackupServiceImpl | InMemoryWorkingCopyBackupService {\n\t\tif (backupWorkspaceHome) {\n\t\t\treturn new NativeWorkingCopyBackupServiceImpl(backupWorkspaceHome, this.fileService, this.logService);\n\t\t}\n\n\t\treturn new InMemoryWorkingCopyBackupService();\n\t}\n\n\treinitialize(backupWorkspaceHome: URI | undefined): void {\n\n\t\t// Re-init implementation (unless we are running in-memory)\n\t\tif (this.impl instanceof NativeWorkingCopyBackupServiceImpl) {\n\t\t\tif (backupWorkspaceHome) {\n\t\t\t\tthis.impl.initialize(backupWorkspaceHome);\n\t\t\t} else {\n\t\t\t\tthis.impl = new InMemoryWorkingCopyBackupService();\n\t\t\t}\n\t\t}\n\t}\n\n\thasBackups(): Promise<boolean> {\n\t\treturn this.impl.hasBackups();\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number): boolean {\n\t\treturn this.impl.hasBackupSync(identifier, versionId);\n\t}\n\n\tbackup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadableStream | VSBufferReadable, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\treturn this.impl.backup(identifier, content, versionId, meta, token);\n\t}\n\n\tdiscardBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\treturn this.impl.discardBackup(identifier);\n\t}\n\n\tdiscardBackups(except?: IWorkingCopyIdentifier[]): Promise<void> {\n\t\treturn this.impl.discardBackups(except);\n\t}\n\n\tgetBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\treturn this.impl.getBackups();\n\t}\n\n\tresolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\treturn this.impl.resolve(identifier);\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn this.impl.toBackupResource(identifier);\n\t}\n}\n\nclass NativeWorkingCopyBackupServiceImpl extends Disposable implements IWorkingCopyBackupService {\n\n\tprivate static readonly PREAMBLE_END_MARKER = '\\n';\n\tprivate static readonly PREAMBLE_END_MARKER_CHARCODE = '\\n'.charCodeAt(0);\n\tprivate static readonly PREAMBLE_META_SEPARATOR = ' '; // using a character that is know to be escaped in a URI as separator\n\tprivate static readonly PREAMBLE_MAX_LENGTH = 10000;\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate readonly ioOperationQueues = this._register(new ResourceQueue()); // queue IO operations to ensure write/delete file order\n\n\tprivate ready!: Promise<WorkingCopyBackupsModel>;\n\tprivate model: WorkingCopyBackupsModel | undefined = undefined;\n\n\tconstructor(\n\t\tprivate backupWorkspaceHome: URI,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.initialize(backupWorkspaceHome);\n\t}\n\n\tinitialize(backupWorkspaceResource: URI): void {\n\t\tthis.backupWorkspaceHome = backupWorkspaceResource;\n\n\t\tthis.ready = this.doInitialize();\n\t}\n\n\tprivate async doInitialize(): Promise<WorkingCopyBackupsModel> {\n\n\t\t// Create backup model\n\t\tthis.model = await WorkingCopyBackupsModel.create(this.backupWorkspaceHome, this.fileService);\n\n\t\t// Migrate hashes as needed. We used to hash with a MD5\n\t\t// sum of the path but switched to our own simpler hash\n\t\t// to avoid a node.js dependency. We still want to\n\t\t// support the older hash so we:\n\t\t// - iterate over all backups\n\t\t// - detect if the file name length is 32 (MD5 length)\n\t\t// - read the backup's target file path\n\t\t// - rename the backup to the new hash\n\t\t// - update the backup in our model\n\t\t//\n\t\t// TODO@bpasero remove me eventually\n\t\tfor (const backupResource of this.model.get()) {\n\t\t\tif (basename(backupResource).length !== 32) {\n\t\t\t\tcontinue; // not a MD5 hash, already uses new hash function\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst identifier = await this.resolveIdentifier(backupResource);\n\t\t\t\tif (!identifier) {\n\t\t\t\t\tthis.logService.warn(`Backup: Unable to read target URI of backup ${backupResource} for migration to new hash.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst expectedBackupResource = this.toBackupResource(identifier);\n\t\t\t\tif (!isEqual(expectedBackupResource, backupResource)) {\n\t\t\t\t\tawait this.fileService.move(backupResource, expectedBackupResource, true);\n\t\t\t\t\tthis.model.move(backupResource, expectedBackupResource);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(`Backup: Unable to migrate backup ${backupResource} to new hash.`);\n\t\t\t}\n\t\t}\n\n\t\treturn this.model;\n\t}\n\n\tasync hasBackups(): Promise<boolean> {\n\t\tconst model = await this.ready;\n\n\t\treturn model.count() > 0;\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number): boolean {\n\t\tif (!this.model) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.model.has(backupResource, versionId);\n\t}\n\n\tasync backup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadable | VSBufferReadableStream, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\tconst model = await this.ready;\n\t\tif (token?.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tif (model.has(backupResource, versionId, meta)) {\n\t\t\treturn; // return early if backup version id matches requested one\n\t\t}\n\n\t\treturn this.ioOperationQueues.queueFor(backupResource).queue(async () => {\n\t\t\tif (token?.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Encode as: Resource + META-START + Meta + END\n\t\t\t// and respect max length restrictions in case\n\t\t\t// meta is too large.\n\t\t\tlet preamble = this.createPreamble(identifier, meta);\n\t\t\tif (preamble.length >= NativeWorkingCopyBackupServiceImpl.PREAMBLE_MAX_LENGTH) {\n\t\t\t\tpreamble = this.createPreamble(identifier);\n\t\t\t}\n\n\t\t\t// Update backup with value\n\t\t\tconst preambleBuffer = VSBuffer.fromString(preamble);\n\t\t\tlet backupBuffer: VSBuffer | VSBufferReadableStream | VSBufferReadable;\n\t\t\tif (isReadableStream(content)) {\n\t\t\t\tbackupBuffer = prefixedBufferStream(preambleBuffer, content);\n\t\t\t} else if (content) {\n\t\t\t\tbackupBuffer = prefixedBufferReadable(preambleBuffer, content);\n\t\t\t} else {\n\t\t\t\tbackupBuffer = VSBuffer.concat([preambleBuffer, VSBuffer.fromString('')]);\n\t\t\t}\n\n\t\t\tawait this.fileService.writeFile(backupResource, backupBuffer);\n\n\t\t\t// Update model\n\t\t\tmodel.add(backupResource, versionId, meta);\n\t\t});\n\t}\n\n\tprivate createPreamble(identifier: IWorkingCopyIdentifier, meta?: IWorkingCopyBackupMeta): string {\n\t\treturn `${identifier.resource.toString()}${NativeWorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR}${JSON.stringify({ ...meta, typeId: identifier.typeId })}${NativeWorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER}`;\n\t}\n\n\tasync discardBackups(except?: IWorkingCopyIdentifier[]): Promise<void> {\n\t\tconst model = await this.ready;\n\n\t\t// Discard all but some backups\n\t\tif (Array.isArray(except) && except.length > 0) {\n\t\t\tconst exceptMap = new ResourceMap<boolean>();\n\t\t\tfor (const exceptWorkingCopy of except) {\n\t\t\t\texceptMap.set(this.toBackupResource(exceptWorkingCopy), true);\n\t\t\t}\n\n\t\t\tfor (const backupResource of model.get()) {\n\t\t\t\tif (!exceptMap.has(backupResource)) {\n\t\t\t\t\tawait this.doDiscardBackup(backupResource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Discard all backups\n\t\telse {\n\t\t\tawait this.deleteIgnoreFileNotFound(this.backupWorkspaceHome);\n\n\t\t\tmodel.clear();\n\t\t}\n\t}\n\n\tdiscardBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.doDiscardBackup(backupResource);\n\t}\n\n\tprivate async doDiscardBackup(backupResource: URI): Promise<void> {\n\t\tconst model = await this.ready;\n\n\t\treturn this.ioOperationQueues.queueFor(backupResource).queue(async () => {\n\t\t\tawait this.deleteIgnoreFileNotFound(backupResource);\n\n\t\t\tmodel.remove(backupResource);\n\t\t});\n\t}\n\n\tprivate async deleteIgnoreFileNotFound(backupResource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait this.fileService.del(backupResource, { recursive: true });\n\t\t} catch (error) {\n\t\t\tif ((<FileOperationError>error).fileOperationResult !== FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\tthrow error; // re-throw any other error than file not found which is OK\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\tconst model = await this.ready;\n\n\t\tconst backups = await Promise.all(model.get().map(backupResource => this.resolveIdentifier(backupResource)));\n\n\t\treturn coalesce(backups);\n\t}\n\n\tprivate async resolveIdentifier(backupResource: URI): Promise<IWorkingCopyIdentifier | undefined> {\n\n\t\t// Read the entire backup preamble by reading up to\n\t\t// `PREAMBLE_MAX_LENGTH` in the backup file until\n\t\t// the `PREAMBLE_END_MARKER` is found\n\t\tconst backupPreamble = await this.readToMatchingString(backupResource, NativeWorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER, NativeWorkingCopyBackupServiceImpl.PREAMBLE_MAX_LENGTH);\n\t\tif (!backupPreamble) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Figure out the offset in the preamble where meta\n\t\t// information possibly starts. This can be `-1` for\n\t\t// older backups without meta.\n\t\tconst metaStartIndex = backupPreamble.indexOf(NativeWorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR);\n\n\t\t// Extract the preamble content for resource and meta\n\t\tlet resourcePreamble: string;\n\t\tlet metaPreamble: string | undefined;\n\t\tif (metaStartIndex > 0) {\n\t\t\tresourcePreamble = backupPreamble.substring(0, metaStartIndex);\n\t\t\tmetaPreamble = backupPreamble.substr(metaStartIndex + 1);\n\t\t} else {\n\t\t\tresourcePreamble = backupPreamble;\n\t\t\tmetaPreamble = undefined;\n\t\t}\n\n\t\t// Try to find the `typeId` in the meta data if possible\n\t\tlet typeId: string | undefined = undefined;\n\t\tif (metaPreamble) {\n\t\t\ttry {\n\t\t\t\ttypeId = JSON.parse(metaPreamble).typeId;\n\t\t\t} catch (error) {\n\t\t\t\t// ignore JSON parse errors\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttypeId: typeId ?? '', // Fallback for previous backups that do not encode the typeId (TODO@bpasero remove me eventually)\n\t\t\tresource: URI.parse(resourcePreamble)\n\t\t};\n\t}\n\n\tprivate async readToMatchingString(backupResource: URI, matchingString: string, maximumBytesToRead: number): Promise<string | undefined> {\n\t\tconst contents = (await this.fileService.readFile(backupResource, { length: maximumBytesToRead })).value.toString();\n\n\t\tconst matchingStringIndex = contents.indexOf(matchingString);\n\t\tif (matchingStringIndex >= 0) {\n\t\t\treturn contents.substr(0, matchingStringIndex);\n\t\t}\n\n\t\t// Unable to find matching string in file\n\t\treturn undefined;\n\t}\n\n\tasync resolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\tconst model = await this.ready;\n\t\tif (!model.has(backupResource)) {\n\t\t\treturn undefined; // require backup to be present\n\t\t}\n\n\t\t// Load the backup content and peek into the first chunk\n\t\t// to be able to resolve the meta data\n\t\tconst backupStream = await this.fileService.readFileStream(backupResource);\n\t\tconst peekedBackupStream = await peekStream(backupStream.value, 1);\n\t\tconst firstBackupChunk = VSBuffer.concat(peekedBackupStream.buffer);\n\n\t\t// We have seen reports (e.g. https://github.com/microsoft/vscode/issues/78500) where\n\t\t// if VSCode goes down while writing the backup file, the file can turn empty because\n\t\t// it always first gets truncated and then written to. In this case, we will not find\n\t\t// the meta-end marker ('\\n') and as such the backup can only be invalid. We bail out\n\t\t// here if that is the case.\n\t\tconst preambleEndIndex = firstBackupChunk.buffer.indexOf(NativeWorkingCopyBackupServiceImpl.PREAMBLE_END_MARKER_CHARCODE);\n\t\tif (preambleEndIndex === -1) {\n\t\t\tthis.logService.trace(`Backup: Could not find meta end marker in ${backupResource}. The file is probably corrupt (filesize: ${backupStream.size}).`);\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst preambelRaw = firstBackupChunk.slice(0, preambleEndIndex).toString();\n\n\t\t// Extract meta data (if any)\n\t\tlet meta: T | undefined;\n\t\tconst metaStartIndex = preambelRaw.indexOf(NativeWorkingCopyBackupServiceImpl.PREAMBLE_META_SEPARATOR);\n\t\tif (metaStartIndex !== -1) {\n\t\t\ttry {\n\t\t\t\tmeta = JSON.parse(preambelRaw.substr(metaStartIndex + 1));\n\n\t\t\t\t// `typeId` is a property that we add so we\n\t\t\t\t// remove it when returning to clients.\n\t\t\t\tif (typeof meta?.typeId === 'string') {\n\t\t\t\t\tdelete meta.typeId;\n\n\t\t\t\t\tif (isEmptyObject(meta)) {\n\t\t\t\t\t\tmeta = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// ignore JSON parse errors\n\t\t\t}\n\t\t}\n\n\t\t// Build a new stream without the preamble\n\t\tconst firstBackupChunkWithoutPreamble = firstBackupChunk.slice(preambleEndIndex + 1);\n\t\tlet value: VSBufferReadableStream;\n\t\tif (peekedBackupStream.ended) {\n\t\t\tvalue = bufferToStream(firstBackupChunkWithoutPreamble);\n\t\t} else {\n\t\t\tvalue = prefixedBufferStream(firstBackupChunkWithoutPreamble, peekedBackupStream.stream);\n\t\t}\n\n\t\treturn { value, meta };\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn joinPath(this.backupWorkspaceHome, identifier.resource.scheme, hashIdentifier(identifier));\n\t}\n}\n\nexport class InMemoryWorkingCopyBackupService implements IWorkingCopyBackupService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate backups = new ResourceMap<{ typeId: string, content: VSBuffer, meta?: IWorkingCopyBackupMeta }>();\n\n\tconstructor() { }\n\n\tasync hasBackups(): Promise<boolean> {\n\t\treturn this.backups.size > 0;\n\t}\n\n\thasBackupSync(identifier: IWorkingCopyIdentifier, versionId?: number): boolean {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\n\t\treturn this.backups.has(backupResource);\n\t}\n\n\tasync backup(identifier: IWorkingCopyIdentifier, content?: VSBufferReadable | VSBufferReadableStream, versionId?: number, meta?: IWorkingCopyBackupMeta, token?: CancellationToken): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tthis.backups.set(backupResource, {\n\t\t\ttypeId: identifier.typeId,\n\t\t\tcontent: content instanceof VSBuffer ? content : content ? isReadableStream(content) ? await streamToBuffer(content) : readableToBuffer(content) : VSBuffer.fromString(''),\n\t\t\tmeta\n\t\t});\n\t}\n\n\tasync resolve<T extends IWorkingCopyBackupMeta>(identifier: IWorkingCopyIdentifier): Promise<IResolvedWorkingCopyBackup<T> | undefined> {\n\t\tconst backupResource = this.toBackupResource(identifier);\n\t\tconst backup = this.backups.get(backupResource);\n\t\tif (backup) {\n\t\t\treturn { value: bufferToStream(backup.content), meta: backup.meta as T | undefined };\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tasync getBackups(): Promise<IWorkingCopyIdentifier[]> {\n\t\treturn Array.from(this.backups.entries()).map(([resource, backup]) => ({ typeId: backup.typeId, resource }));\n\t}\n\n\tasync discardBackup(identifier: IWorkingCopyIdentifier): Promise<void> {\n\t\tthis.backups.delete(this.toBackupResource(identifier));\n\t}\n\n\tasync discardBackups(except?: IWorkingCopyIdentifier[]): Promise<void> {\n\t\tif (Array.isArray(except) && except.length > 0) {\n\t\t\tconst exceptMap = new ResourceMap<boolean>();\n\t\t\tfor (const exceptWorkingCopy of except) {\n\t\t\t\texceptMap.set(this.toBackupResource(exceptWorkingCopy), true);\n\t\t\t}\n\n\t\t\tfor (const backup of await this.getBackups()) {\n\t\t\t\tif (!exceptMap.has(this.toBackupResource(backup))) {\n\t\t\t\t\tawait this.discardBackup(backup);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.backups.clear();\n\t\t}\n\t}\n\n\ttoBackupResource(identifier: IWorkingCopyIdentifier): URI {\n\t\treturn URI.from({ scheme: Schemas.inMemory, path: hashIdentifier(identifier) });\n\t}\n}\n\n/*\n * Exported only for testing\n */\nexport function hashIdentifier(identifier: IWorkingCopyIdentifier): string {\n\n\t// IMPORTANT: for backwards compatibility, ensure that\n\t// we ignore the `typeId` unless a value is provided.\n\t// To preserve previous backups without type id, we\n\t// need to just hash the resource. Otherwise we use\n\t// the type id as a seed to the resource path.\n\tlet resource: URI;\n\tif (identifier.typeId.length > 0) {\n\t\tconst typeIdHash = hashString(identifier.typeId);\n\t\tif (identifier.resource.path) {\n\t\t\tresource = joinPath(identifier.resource, typeIdHash);\n\t\t} else {\n\t\t\tresource = identifier.resource.with({ path: typeIdHash });\n\t\t}\n\t} else {\n\t\tresource = identifier.resource;\n\t}\n\n\treturn hashPath(resource);\n}\n\nfunction hashPath(resource: URI): string {\n\tconst str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();\n\n\treturn hashString(str);\n}\n\nfunction hashString(str: string): string {\n\treturn hash(str).toString(16);\n}\n\n// Register Backup Restorer\nRegistry.as<IWorkbenchContributionsRegistry>(WorkbenchExtensions.Workbench).registerWorkbenchContribution(LegacyWorkingCopyBackupRestorer, LifecyclePhase.Starting);\n"]}