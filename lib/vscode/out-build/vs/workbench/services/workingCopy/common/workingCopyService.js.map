{"version":3,"file":"workingCopyService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/workingCopy/common/workingCopyService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { URI } from 'vs/base/common/uri';\nimport { Disposable, IDisposable, toDisposable, DisposableStore, dispose } from 'vs/base/common/lifecycle';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { IWorkingCopy } from 'vs/workbench/services/workingCopy/common/workingCopy';\n\nexport const IWorkingCopyService = createDecorator<IWorkingCopyService>('workingCopyService');\n\nexport interface IWorkingCopyService {\n\n\treadonly _serviceBrand: undefined;\n\n\n\t//#region Events\n\n\t/**\n\t * An event for when a working copy was registered.\n\t */\n\treadonly onDidRegister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy was unregistered.\n\t */\n\treadonly onDidUnregister: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy dirty state changed.\n\t */\n\treadonly onDidChangeDirty: Event<IWorkingCopy>;\n\n\t/**\n\t * An event for when a working copy's content changed.\n\t */\n\treadonly onDidChangeContent: Event<IWorkingCopy>;\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\t/**\n\t * The number of dirty working copies that are registered.\n\t */\n\treadonly dirtyCount: number;\n\n\t/**\n\t * All dirty working copies that are registered.\n\t */\n\treadonly dirtyWorkingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Whether there is any registered working copy that is dirty.\n\t */\n\treadonly hasDirty: boolean;\n\n\t/**\n\t * Figure out if working copies with the given\n\t * resource are dirty or not.\n\t *\n\t * @param resource the URI of the working copy\n\t * @param typeId optional type identifier to only\n\t * consider working copies of that type.\n\t */\n\tisDirty(resource: URI, typeId?: string): boolean;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\t/**\n\t * All working copies that are registered.\n\t */\n\treadonly workingCopies: readonly IWorkingCopy[];\n\n\t/**\n\t * Register a new working copy with the service. This method will\n\t * throw if you try to register a working copy on a resource that\n\t * has already been registered.\n\t *\n\t * Overall there can only ever be 1 working copy with the same\n\t * resource.\n\t */\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable;\n\n\t//#endregion\n}\n\nexport class WorkingCopyService extends Disposable implements IWorkingCopyService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\t//#region Events\n\n\tprivate readonly _onDidRegister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidRegister = this._onDidRegister.event;\n\n\tprivate readonly _onDidUnregister = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidUnregister = this._onDidUnregister.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<IWorkingCopy>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\t//#endregion\n\n\n\t//#region Registry\n\n\tget workingCopies(): IWorkingCopy[] { return Array.from(this._workingCopies.values()); }\n\tprivate _workingCopies = new Set<IWorkingCopy>();\n\n\tprivate readonly mapResourceToWorkingCopies = new ResourceMap<Map<string, IWorkingCopy>>();\n\n\tregisterWorkingCopy(workingCopy: IWorkingCopy): IDisposable {\n\t\tlet workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.has(workingCopy.typeId)) {\n\t\t\tthrow new Error(`Cannot register more than one working copy with the same resource ${workingCopy.resource.toString(true)} and type ${workingCopy.typeId}.`);\n\t\t}\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.add(workingCopy);\n\n\t\t// Registry (type based)\n\t\tif (!workingCopiesForResource) {\n\t\t\tworkingCopiesForResource = new Map();\n\t\t\tthis.mapResourceToWorkingCopies.set(workingCopy.resource, workingCopiesForResource);\n\t\t}\n\t\tworkingCopiesForResource.set(workingCopy.typeId, workingCopy);\n\n\t\t// Wire in Events\n\t\tconst disposables = new DisposableStore();\n\t\tdisposables.add(workingCopy.onDidChangeContent(() => this._onDidChangeContent.fire(workingCopy)));\n\t\tdisposables.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\n\t\t// Send some initial events\n\t\tthis._onDidRegister.fire(workingCopy);\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\tthis.unregisterWorkingCopy(workingCopy);\n\t\t\tdispose(disposables);\n\n\t\t\t// Signal as event\n\t\t\tthis._onDidUnregister.fire(workingCopy);\n\t\t});\n\t}\n\n\tprivate unregisterWorkingCopy(workingCopy: IWorkingCopy): void {\n\n\t\t// Registry (all)\n\t\tthis._workingCopies.delete(workingCopy);\n\n\t\t// Registry (type based)\n\t\tconst workingCopiesForResource = this.mapResourceToWorkingCopies.get(workingCopy.resource);\n\t\tif (workingCopiesForResource?.delete(workingCopy.typeId) && workingCopiesForResource.size === 0) {\n\t\t\tthis.mapResourceToWorkingCopies.delete(workingCopy.resource);\n\t\t}\n\n\t\t// If copy is dirty, ensure to fire an event to signal the dirty change\n\t\t// (a disposed working copy cannot account for being dirty in our model)\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t}\n\t}\n\n\t//#endregion\n\n\n\t//#region Dirty Tracking\n\n\tget hasDirty(): boolean {\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget dirtyCount(): number {\n\t\tlet totalDirtyCount = 0;\n\n\t\tfor (const workingCopy of this._workingCopies) {\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\ttotalDirtyCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn totalDirtyCount;\n\t}\n\n\tget dirtyWorkingCopies(): IWorkingCopy[] {\n\t\treturn this.workingCopies.filter(workingCopy => workingCopy.isDirty());\n\t}\n\n\tisDirty(resource: URI, typeId?: string): boolean {\n\t\tconst workingCopies = this.mapResourceToWorkingCopies.get(resource);\n\t\tif (workingCopies) {\n\n\t\t\t// For a specific type\n\t\t\tif (typeof typeId === 'string') {\n\t\t\t\treturn workingCopies.get(typeId)?.isDirty() ?? false;\n\t\t\t}\n\n\t\t\t// Across all working copies\n\t\t\telse {\n\t\t\t\tfor (const [, workingCopy] of workingCopies) {\n\t\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//#endregion\n}\n\nregisterSingleton(IWorkingCopyService, WorkingCopyService, true);\n"]}