{"version":3,"file":"fileWorkingCopyManager.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/workingCopy/common/fileWorkingCopyManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, DisposableStore, dispose, IDisposable } from 'vs/base/common/lifecycle';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { FileWorkingCopy, FileWorkingCopyState, IFileWorkingCopy, IFileWorkingCopyModel, IFileWorkingCopyModelFactory, IFileWorkingCopySaveOptions } from 'vs/workbench/services/workingCopy/common/fileWorkingCopy';\nimport { SaveReason } from 'vs/workbench/common/editor';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { Promises, ResourceQueue } from 'vs/base/common/async';\nimport { FileChangesEvent, FileChangeType, FileOperation, IFileService } from 'vs/platform/files/common/files';\nimport { ILifecycleService } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { ILabelService } from 'vs/platform/label/common/label';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IFileDialogService } from 'vs/platform/dialogs/common/dialogs';\nimport { joinPath } from 'vs/base/common/resources';\nimport { IWorkingCopyFileService, WorkingCopyFileEvent } from 'vs/workbench/services/workingCopy/common/workingCopyFileService';\nimport { IUriIdentityService } from 'vs/workbench/services/uriIdentity/common/uriIdentity';\nimport { CancellationToken } from 'vs/base/common/cancellation';\n\n/**\n * The only one that should be dealing with `IFileWorkingCopy` and handle all\n * operations that are working copy related, such as save/revert, backup\n * and resolving.\n */\nexport interface IFileWorkingCopyManager<T extends IFileWorkingCopyModel> extends IDisposable {\n\n\t/**\n\t * An event for when a file working copy was created.\n\t */\n\treadonly onDidCreate: Event<IFileWorkingCopy<T>>;\n\n\t/**\n\t * An event for when a file working copy was resolved.\n\t */\n\treadonly onDidResolve: Event<IFileWorkingCopy<T>>;\n\n\t/**\n\t * An event for when a file working copy changed it's dirty state.\n\t */\n\treadonly onDidChangeDirty: Event<IFileWorkingCopy<T>>;\n\n\t/**\n\t * An event for when a file working copy failed to save.\n\t */\n\treadonly onDidSaveError: Event<IFileWorkingCopy<T>>;\n\n\t/**\n\t * An event for when a file working copy successfully saved.\n\t */\n\treadonly onDidSave: Event<IFileWorkingCopySaveEvent<T>>;\n\n\t/**\n\t * An event for when a file working copy was reverted.\n\t */\n\treadonly onDidRevert: Event<IFileWorkingCopy<T>>;\n\n\t/**\n\t * Access to all known file working copies within the manager.\n\t */\n\treadonly workingCopies: readonly IFileWorkingCopy<T>[];\n\n\t/**\n\t * Returns the file working copy for the provided resource\n\t * or `undefined` if none.\n\t */\n\tget(resource: URI): IFileWorkingCopy<T> | undefined;\n\n\t/**\n\t * Allows to resolve a file working copy. If the manager already knows\n\t * about a file working copy with the same `URI`, it will return that\n\t * existing file working copy. There will never be more than one\n\t * file working copy per `URI` until the file working copy is disposed.\n\t *\n\t * Use the `IFileWorkingCopyResolveOptions.reload` option to control the\n\t * behaviour for when a file working copy was previously already resolved\n\t * with regards to resolving it again from the underlying file resource\n\t * or not.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * @param resource used as unique identifier of the file working copy in\n\t * case one is already known for this `URI`.\n\t * @param options\n\t */\n\tresolve(resource: URI, options?: IFileWorkingCopyResolveOptions): Promise<IFileWorkingCopy<T>>;\n\n\t/**\n\t * Implements \"Save As\" for file based working copies. The API is `URI` based\n\t * because it works even without resolved file working copies. If a file working\n\t * copy exists for any given `URI`, the implementation will deal with them properly\n\t * (e.g. dirty contents of the source will be written to the target and the source\n\t * will be reverted).\n\t *\n\t * Note: it is possible that the returned file working copy has a different `URI`\n\t * than the `target` that was passed in. Based on URI identity, the file working\n\t * copy may chose to return an existing file working copy with different casing\n\t * to respect file systems that are case insensitive.\n\t *\n\t * Note: Callers must `dispose` the working copy when no longer needed.\n\t *\n\t * @param source the source resource to save as\n\t * @param target the optional target resource to save to. if not defined, the user\n\t * will be asked for input\n\t * @returns the target working copy that was saved to or `undefined` in case of\n\t * cancellation\n\t */\n\tsaveAs(source: URI, target: URI, options?: IFileWorkingCopySaveOptions): Promise<IFileWorkingCopy<T> | undefined>;\n\tsaveAs(source: URI, target: undefined, options?: IFileWorkingCopySaveAsOptions): Promise<IFileWorkingCopy<T> | undefined>;\n\n\t/**\n\t * Waits for the file working copy to be ready to be disposed. There may be\n\t * conditions under which the file working copy cannot be disposed, e.g. when\n\t * it is dirty. Once the promise is settled, it is safe to dispose.\n\t */\n\tcanDispose(workingCopy: IFileWorkingCopy<T>): true | Promise<true>;\n}\n\nexport interface IFileWorkingCopySaveEvent<T extends IFileWorkingCopyModel> {\n\n\t/**\n\t * The file working copy that was successfully saved.\n\t */\n\tworkingCopy: IFileWorkingCopy<T>;\n\n\t/**\n\t * The reason why the file working copy was saved.\n\t */\n\treason: SaveReason;\n}\n\nexport interface IFileWorkingCopyResolveOptions {\n\n\t/**\n\t * The contents to use for the file working copy if known.\n\t * If not provided, the contents will be retrieved from the\n\t * underlying resource or backup if present.\n\t *\n\t * If contents are provided, the file working copy will be marked\n\t * as dirty right from the beginning.\n\t */\n\tcontents?: VSBufferReadableStream;\n\n\t/**\n\t * If the file working copy was already resolved before,\n\t * allows to trigger a reload of it to fetch the latest contents:\n\t * - async: resolve() will return immediately and trigger\n\t *          a reload that will run in the background.\n\t * -  sync: resolve() will only return resolved when the\n\t *          file working copy has finished reloading.\n\t */\n\treload?: {\n\t\tasync: boolean\n\t};\n}\n\nexport interface IFileWorkingCopySaveAsOptions extends IFileWorkingCopySaveOptions {\n\n\t/**\n\t * Optional target resource to suggest to the user in case\n\t * no taget resource is provided to save to.\n\t */\n\tsuggestedTarget?: URI;\n}\n\nexport class FileWorkingCopyManager<T extends IFileWorkingCopyModel> extends Disposable implements IFileWorkingCopyManager<T> {\n\n\t//#region Events\n\n\tprivate readonly _onDidCreate = this._register(new Emitter<IFileWorkingCopy<T>>());\n\treadonly onDidCreate = this._onDidCreate.event;\n\n\tprivate readonly _onDidResolve = this._register(new Emitter<IFileWorkingCopy<T>>());\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<IFileWorkingCopy<T>>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidSaveError = this._register(new Emitter<IFileWorkingCopy<T>>());\n\treadonly onDidSaveError = this._onDidSaveError.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<IFileWorkingCopySaveEvent<T>>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidRevert = this._register(new Emitter<IFileWorkingCopy<T>>());\n\treadonly onDidRevert = this._onDidRevert.event;\n\n\t//#endregion\n\n\tprivate readonly mapResourceToWorkingCopy = new ResourceMap<IFileWorkingCopy<T>>();\n\tprivate readonly mapResourceToWorkingCopyListeners = new ResourceMap<IDisposable>();\n\tprivate readonly mapResourceToDisposeListener = new ResourceMap<IDisposable>();\n\tprivate readonly mapResourceToPendingWorkingCopyResolve = new ResourceMap<Promise<void>>();\n\n\tprivate readonly workingCopyResolveQueue = this._register(new ResourceQueue());\n\n\tconstructor(\n\t\tprivate readonly workingCopyTypeId: string,\n\t\tprivate readonly modelFactory: IFileWorkingCopyModelFactory<T>,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@ILabelService private readonly labelService: ILabelService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IFileDialogService private readonly fileDialogService: IFileDialogService,\n\t\t@IWorkingCopyFileService private readonly workingCopyFileService: IWorkingCopyFileService,\n\t\t@IUriIdentityService private readonly uriIdentityService: IUriIdentityService\n\t) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Update working copies from file change events\n\t\tthis._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));\n\n\t\t// Working copy operations\n\t\tthis._register(this.workingCopyFileService.onWillRunWorkingCopyFileOperation(e => this.onWillRunWorkingCopyFileOperation(e)));\n\t\tthis._register(this.workingCopyFileService.onDidFailWorkingCopyFileOperation(e => this.onDidFailWorkingCopyFileOperation(e)));\n\t\tthis._register(this.workingCopyFileService.onDidRunWorkingCopyFileOperation(e => this.onDidRunWorkingCopyFileOperation(e)));\n\n\t\t// Lifecycle\n\t\tthis.lifecycleService.onWillShutdown(event => event.join(this.onWillShutdown(), 'join.fileWorkingCopyManager'));\n\t\tthis.lifecycleService.onDidShutdown(() => this.dispose());\n\t}\n\n\tprivate async onWillShutdown(): Promise<void> {\n\t\tlet fileWorkingCopies: IFileWorkingCopy<T>[];\n\n\t\t// As long as file working copies are pending to be saved, we prolong the shutdown\n\t\t// until that has happened to ensure we are not shutting down in the middle of\n\t\t// writing to the working copy (https://github.com/microsoft/vscode/issues/116600).\n\t\twhile ((fileWorkingCopies = this.workingCopies.filter(workingCopy => workingCopy.hasState(FileWorkingCopyState.PENDING_SAVE))).length > 0) {\n\t\t\tawait Promises.settled(fileWorkingCopies.map(workingCopy => workingCopy.joinState(FileWorkingCopyState.PENDING_SAVE)));\n\t\t}\n\t}\n\n\t//#region Resolve from file changes\n\n\tprivate onDidFilesChange(e: FileChangesEvent): void {\n\t\tfor (const workingCopy of this.workingCopies) {\n\t\t\tif (workingCopy.isDirty() || !workingCopy.isResolved()) {\n\t\t\t\tcontinue; // require a resolved, saved working copy to continue\n\t\t\t}\n\n\t\t\t// Trigger a resolve for any update or add event that impacts\n\t\t\t// the working copy. We also consider the added event\n\t\t\t// because it could be that a file was added and updated\n\t\t\t// right after.\n\t\t\tif (e.contains(workingCopy.resource, FileChangeType.UPDATED, FileChangeType.ADDED)) {\n\t\t\t\tthis.queueWorkingCopyResolve(workingCopy);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate queueWorkingCopyResolve(workingCopy: IFileWorkingCopy<T>): void {\n\n\t\t// Resolves a working copy to update (use a queue to prevent accumulation of\n\t\t// resolve when the resolving actually takes long. At most we only want the\n\t\t// queue to have a size of 2 (1 running resolve and 1 queued resolve).\n\t\tconst queue = this.workingCopyResolveQueue.queueFor(workingCopy.resource);\n\t\tif (queue.size <= 1) {\n\t\t\tqueue.queue(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait workingCopy.resolve();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Working Copy File Events\n\n\tprivate readonly mapCorrelationIdToWorkingCopiesToRestore = new Map<number, { source: URI, target: URI, snapshot?: VSBufferReadableStream; }[]>();\n\n\tprivate onWillRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\n\t\t// Move / Copy: remember working copies to restore after the operation\n\t\tif (e.operation === FileOperation.MOVE || e.operation === FileOperation.COPY) {\n\t\t\te.waitUntil((async () => {\n\t\t\t\tconst workingCopiesToRestore: { source: URI, target: URI, snapshot?: VSBufferReadableStream; }[] = [];\n\n\t\t\t\tfor (const { source, target } of e.files) {\n\t\t\t\t\tif (source) {\n\t\t\t\t\t\tif (this.uriIdentityService.extUri.isEqual(source, target)) {\n\t\t\t\t\t\t\tcontinue; // ignore if resources are considered equal\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Find all working copies that related to source (can be many if resource is a folder)\n\t\t\t\t\t\tconst sourceWorkingCopies: IFileWorkingCopy<T>[] = [];\n\t\t\t\t\t\tfor (const workingCopy of this.workingCopies) {\n\t\t\t\t\t\t\tif (this.uriIdentityService.extUri.isEqualOrParent(workingCopy.resource, source)) {\n\t\t\t\t\t\t\t\tsourceWorkingCopies.push(workingCopy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remember each source working copy to load again after move is done\n\t\t\t\t\t\t// with optional content to restore if it was dirty\n\t\t\t\t\t\tfor (const sourceWorkingCopy of sourceWorkingCopies) {\n\t\t\t\t\t\t\tconst sourceResource = sourceWorkingCopy.resource;\n\n\t\t\t\t\t\t\t// If the source is the actual working copy, just use target as new resource\n\t\t\t\t\t\t\tlet targetResource: URI;\n\t\t\t\t\t\t\tif (this.uriIdentityService.extUri.isEqual(sourceResource, source)) {\n\t\t\t\t\t\t\t\ttargetResource = target;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Otherwise a parent folder of the source is being moved, so we need\n\t\t\t\t\t\t\t// to compute the target resource based on that\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttargetResource = joinPath(target, sourceResource.path.substr(source.path.length + 1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tworkingCopiesToRestore.push({\n\t\t\t\t\t\t\t\tsource: sourceResource,\n\t\t\t\t\t\t\t\ttarget: targetResource,\n\t\t\t\t\t\t\t\tsnapshot: sourceWorkingCopy.isDirty() ? await sourceWorkingCopy.model?.snapshot(CancellationToken.None) : undefined\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.set(e.correlationId, workingCopiesToRestore);\n\t\t\t})());\n\t\t}\n\t}\n\n\tprivate onDidFailWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\n\t\t// Move / Copy: restore dirty flag on working copies to restore that were dirty\n\t\tif ((e.operation === FileOperation.MOVE || e.operation === FileOperation.COPY)) {\n\t\t\tconst workingCopiesToRestore = this.mapCorrelationIdToWorkingCopiesToRestore.get(e.correlationId);\n\t\t\tif (workingCopiesToRestore) {\n\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.delete(e.correlationId);\n\n\t\t\t\tworkingCopiesToRestore.forEach(workingCopy => {\n\n\t\t\t\t\t// Snapshot presence means this working copy used to be dirty and so we restore that\n\t\t\t\t\t// flag. we do NOT have to restore the content because the working copy was only soft\n\t\t\t\t\t// reverted and did not loose its original dirty contents.\n\t\t\t\t\tif (workingCopy.snapshot) {\n\t\t\t\t\t\tthis.get(workingCopy.source)?.markDirty();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDidRunWorkingCopyFileOperation(e: WorkingCopyFileEvent): void {\n\t\tswitch (e.operation) {\n\n\t\t\t// Create: Revert existing working copies\n\t\t\tcase FileOperation.CREATE:\n\t\t\t\te.waitUntil((async () => {\n\t\t\t\t\tfor (const { target } of e.files) {\n\t\t\t\t\t\tconst workingCopy = this.get(target);\n\t\t\t\t\t\tif (workingCopy && !workingCopy.isDisposed()) {\n\t\t\t\t\t\t\tawait workingCopy.revert();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})());\n\t\t\t\tbreak;\n\n\t\t\t// Move/Copy: restore working copies that were loaded before the operation took place\n\t\t\tcase FileOperation.MOVE:\n\t\t\tcase FileOperation.COPY:\n\t\t\t\te.waitUntil((async () => {\n\t\t\t\t\tconst workingCopiesToRestore = this.mapCorrelationIdToWorkingCopiesToRestore.get(e.correlationId);\n\t\t\t\t\tif (workingCopiesToRestore) {\n\t\t\t\t\t\tthis.mapCorrelationIdToWorkingCopiesToRestore.delete(e.correlationId);\n\n\t\t\t\t\t\tawait Promises.settled(workingCopiesToRestore.map(async workingCopyToRestore => {\n\n\t\t\t\t\t\t\t// Restore the working copy at the target. if we have previous dirty content, we pass it\n\t\t\t\t\t\t\t// over to be used, otherwise we force a reload from disk. this is important\n\t\t\t\t\t\t\t// because we know the file has changed on disk after the move and the working copy might\n\t\t\t\t\t\t\t// have still existed with the previous state. this ensures that the working copy is not\n\t\t\t\t\t\t\t// tracking a stale state.\n\t\t\t\t\t\t\tawait this.resolve(workingCopyToRestore.target, {\n\t\t\t\t\t\t\t\treload: { async: false }, // enforce a reload\n\t\t\t\t\t\t\t\tcontents: workingCopyToRestore.snapshot\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t})());\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Get / Get all\n\n\tget workingCopies(): IFileWorkingCopy<T>[] {\n\t\treturn [...this.mapResourceToWorkingCopy.values()];\n\t}\n\n\tget(resource: URI): IFileWorkingCopy<T> | undefined {\n\t\treturn this.mapResourceToWorkingCopy.get(resource);\n\t}\n\n\t//#endregion\n\n\t//#region Resolve\n\n\tasync resolve(resource: URI, options?: IFileWorkingCopyResolveOptions): Promise<IFileWorkingCopy<T>> {\n\n\t\t// Await a pending working copy resolve first before proceeding\n\t\t// to ensure that we never resolve a working copy more than once\n\t\t// in parallel\n\t\tconst pendingResolve = this.joinPendingResolve(resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\t\t}\n\n\t\tlet workingCopyResolve: Promise<void>;\n\t\tlet workingCopy = this.get(resource);\n\t\tlet didCreateWorkingCopy = false;\n\n\t\t// Working copy exists\n\t\tif (workingCopy) {\n\n\t\t\t// Always reload if contents are provided\n\t\t\tif (options?.contents) {\n\t\t\t\tworkingCopyResolve = workingCopy.resolve(options);\n\t\t\t}\n\n\t\t\t// Reload async or sync based on options\n\t\t\telse if (options?.reload) {\n\n\t\t\t\t// Async reload: trigger a reload but return immediately\n\t\t\t\tif (options.reload.async) {\n\t\t\t\t\tworkingCopy.resolve(options);\n\t\t\t\t\tworkingCopyResolve = Promise.resolve();\n\t\t\t\t}\n\n\t\t\t\t// Sync reload: do not return until working copy reloaded\n\t\t\t\telse {\n\t\t\t\t\tworkingCopyResolve = workingCopy.resolve(options);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do not reload\n\t\t\telse {\n\t\t\t\tworkingCopyResolve = Promise.resolve();\n\t\t\t}\n\t\t}\n\n\t\t// File working copy does not exist\n\t\telse {\n\t\t\tdidCreateWorkingCopy = true;\n\n\t\t\tconst newWorkingCopy = workingCopy = this.instantiationService.createInstance(FileWorkingCopy, this.workingCopyTypeId, resource, this.labelService.getUriBasenameLabel(resource), this.modelFactory) as unknown as IFileWorkingCopy<T>;\n\t\t\tworkingCopyResolve = workingCopy.resolve(options);\n\n\t\t\tthis.registerWorkingCopy(newWorkingCopy);\n\t\t}\n\n\t\t// Store pending resolve to avoid race conditions\n\t\tthis.mapResourceToPendingWorkingCopyResolve.set(resource, workingCopyResolve);\n\n\t\t// Make known to manager (if not already known)\n\t\tthis.add(resource, workingCopy);\n\n\t\t// Emit some events if we created the working copy\n\t\tif (didCreateWorkingCopy) {\n\t\t\tthis._onDidCreate.fire(workingCopy);\n\n\t\t\t// If the working copy is dirty right from the beginning,\n\t\t\t// make sure to emit this as an event\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Wait for working copy to resolve\n\t\t\tawait workingCopyResolve;\n\n\t\t\t// Remove from pending resolves\n\t\t\tthis.mapResourceToPendingWorkingCopyResolve.delete(resource);\n\n\t\t\t// File working copy can be dirty if a backup was restored, so we make sure to\n\t\t\t// have this event delivered if we created the working copy here\n\t\t\tif (didCreateWorkingCopy && workingCopy.isDirty()) {\n\t\t\t\tthis._onDidChangeDirty.fire(workingCopy);\n\t\t\t}\n\n\t\t\treturn workingCopy;\n\t\t} catch (error) {\n\n\t\t\t// Free resources of this invalid working copy\n\t\t\tif (workingCopy) {\n\t\t\t\tworkingCopy.dispose();\n\t\t\t}\n\n\t\t\t// Remove from pending resolves\n\t\t\tthis.mapResourceToPendingWorkingCopyResolve.delete(resource);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate joinPendingResolve(resource: URI): Promise<void> | undefined {\n\t\tconst pendingWorkingCopyResolve = this.mapResourceToPendingWorkingCopyResolve.get(resource);\n\t\tif (pendingWorkingCopyResolve) {\n\t\t\treturn pendingWorkingCopyResolve.then(undefined, error => {/* ignore any error here, it will bubble to the original requestor*/ });\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate registerWorkingCopy(workingCopy: IFileWorkingCopy<T>): void {\n\n\t\t// Install working copy listeners\n\t\tconst workingCopyListeners = new DisposableStore();\n\t\tworkingCopyListeners.add(workingCopy.onDidResolve(() => this._onDidResolve.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onDidChangeDirty(() => this._onDidChangeDirty.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onDidSaveError(() => this._onDidSaveError.fire(workingCopy)));\n\t\tworkingCopyListeners.add(workingCopy.onDidSave(reason => this._onDidSave.fire({ workingCopy: workingCopy, reason })));\n\t\tworkingCopyListeners.add(workingCopy.onDidRevert(() => this._onDidRevert.fire(workingCopy)));\n\n\t\t// Keep for disposal\n\t\tthis.mapResourceToWorkingCopyListeners.set(workingCopy.resource, workingCopyListeners);\n\t}\n\n\tprivate add(resource: URI, workingCopy: IFileWorkingCopy<T>): void {\n\t\tconst knownWorkingCopy = this.mapResourceToWorkingCopy.get(resource);\n\t\tif (knownWorkingCopy === workingCopy) {\n\t\t\treturn; // already cached\n\t\t}\n\n\t\t// Dispose any previously stored dispose listener for this resource\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tif (disposeListener) {\n\t\t\tdisposeListener.dispose();\n\t\t}\n\n\t\t// Store in cache but remove when working copy gets disposed\n\t\tthis.mapResourceToWorkingCopy.set(resource, workingCopy);\n\t\tthis.mapResourceToDisposeListener.set(resource, workingCopy.onWillDispose(() => this.remove(resource)));\n\t}\n\n\tprivate remove(resource: URI): void {\n\t\tthis.mapResourceToWorkingCopy.delete(resource);\n\n\t\tconst disposeListener = this.mapResourceToDisposeListener.get(resource);\n\t\tif (disposeListener) {\n\t\t\tdispose(disposeListener);\n\t\t\tthis.mapResourceToDisposeListener.delete(resource);\n\t\t}\n\n\t\tconst workingCopyListener = this.mapResourceToWorkingCopyListeners.get(resource);\n\t\tif (workingCopyListener) {\n\t\t\tdispose(workingCopyListener);\n\t\t\tthis.mapResourceToWorkingCopyListeners.delete(resource);\n\t\t}\n\t}\n\n\tprivate clear(): void {\n\n\t\t// Working copy caches\n\t\tthis.mapResourceToWorkingCopy.clear();\n\t\tthis.mapResourceToPendingWorkingCopyResolve.clear();\n\n\t\t// Dispose the dispose listeners\n\t\tthis.mapResourceToDisposeListener.forEach(listener => listener.dispose());\n\t\tthis.mapResourceToDisposeListener.clear();\n\n\t\t// Dispose the working copy change listeners\n\t\tthis.mapResourceToWorkingCopyListeners.forEach(listener => listener.dispose());\n\t\tthis.mapResourceToWorkingCopyListeners.clear();\n\t}\n\n\t//#endregion\n\n\t//#region Save As...\n\n\tasync saveAs(source: URI, target?: URI, options?: IFileWorkingCopySaveAsOptions): Promise<IFileWorkingCopy<T> | undefined> {\n\n\t\t// If not provided, ask user for target\n\t\tif (!target) {\n\t\t\ttarget = await this.fileDialogService.pickFileToSave(options?.suggestedTarget ?? source);\n\n\t\t\tif (!target) {\n\t\t\t\treturn undefined; // user canceled\n\t\t\t}\n\t\t}\n\n\t\t// Do it\n\t\treturn this.doSaveAs(source, target, options);\n\t}\n\n\tprivate async doSaveAs(source: URI, target: URI, options?: IFileWorkingCopySaveAsOptions): Promise<IFileWorkingCopy<T> | undefined> {\n\t\tlet sourceContents: VSBufferReadableStream;\n\n\t\t// If the source is an existing file working copy, we can directly\n\t\t// use that to copy the contents to the target destination\n\t\tconst sourceWorkingCopy = this.get(source);\n\t\tif (sourceWorkingCopy?.isResolved()) {\n\t\t\tsourceContents = await sourceWorkingCopy.model.snapshot(CancellationToken.None);\n\t\t}\n\n\t\t// Otherwise we resolve the contents from the underlying file\n\t\telse {\n\t\t\tsourceContents = (await this.fileService.readFileStream(source)).value;\n\t\t}\n\n\t\t// Save the contents through working copy to benefit from save\n\t\t// participants and handling a potential already existing target\n\t\treturn this.doSaveAsWorkingCopy(source, sourceContents, target, options);\n\t}\n\n\tprivate async doSaveAsWorkingCopy(source: URI, sourceContents: VSBufferReadableStream, target: URI, options?: IFileWorkingCopySaveAsOptions): Promise<IFileWorkingCopy<T>> {\n\n\t\t// Prefer an existing working copy if it is already resolved\n\t\t// for the given target resource\n\t\tlet targetExists = false;\n\t\tlet targetWorkingCopy = this.get(target);\n\t\tif (targetWorkingCopy?.isResolved()) {\n\t\t\ttargetExists = true;\n\t\t}\n\n\t\t// Otherwise create the target working copy empty if\n\t\t// it does not exist already and resolve it from there\n\t\telse {\n\t\t\ttargetExists = await this.fileService.exists(target);\n\n\t\t\t// Create target file adhoc if it does not exist yet\n\t\t\tif (!targetExists) {\n\t\t\t\tawait this.workingCopyFileService.create([{ resource: target }], CancellationToken.None);\n\t\t\t}\n\n\t\t\t// At this point we need to resolve the target working copy\n\t\t\t// and we have to do an explicit check if the source URI\n\t\t\t// equals the target via URI identity. If they match and we\n\t\t\t// have had an existing working copy with the source, we\n\t\t\t// prefer that one over resolving the target. Otherwiese we\n\t\t\t// would potentially introduce a\n\t\t\tif (this.uriIdentityService.extUri.isEqual(source, target) && this.get(source)) {\n\t\t\t\ttargetWorkingCopy = await this.resolve(source);\n\t\t\t} else {\n\t\t\t\ttargetWorkingCopy = await this.resolve(target);\n\t\t\t}\n\t\t}\n\n\t\t// Take over content from source to target\n\t\tawait targetWorkingCopy.model?.update(sourceContents, CancellationToken.None);\n\n\t\t// Save target\n\t\tawait targetWorkingCopy.save({ ...options, force: true  /* force to save, even if not dirty (https://github.com/microsoft/vscode/issues/99619) */ });\n\n\t\t// Revert the source\n\t\tawait this.doRevert(source);\n\n\t\treturn targetWorkingCopy;\n\t}\n\n\tprivate async doRevert(resource: URI): Promise<void> {\n\t\tconst workingCopy = this.get(resource);\n\t\tif (!workingCopy) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn workingCopy.revert();\n\t}\n\n\t//#endregion\n\n\t//#region Lifecycle\n\n\tcanDispose(workingCopy: IFileWorkingCopy<T>): true | Promise<true> {\n\n\t\t// Quick return if working copy already disposed or not dirty and not resolving\n\t\tif (\n\t\t\tworkingCopy.isDisposed() ||\n\t\t\t(!this.mapResourceToPendingWorkingCopyResolve.has(workingCopy.resource) && !workingCopy.isDirty())\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Promise based return in all other cases\n\t\treturn this.doCanDispose(workingCopy);\n\t}\n\n\tprivate async doCanDispose(workingCopy: IFileWorkingCopy<T>): Promise<true> {\n\n\t\t// If we have a pending working copy resolve, await it first and then try again\n\t\tconst pendingResolve = this.joinPendingResolve(workingCopy.resource);\n\t\tif (pendingResolve) {\n\t\t\tawait pendingResolve;\n\n\t\t\treturn this.canDispose(workingCopy);\n\t\t}\n\n\t\t// Dirty working copy: we do not allow to dispose dirty working copys\n\t\t// to prevent data loss cases. dirty working copys can only be disposed when\n\t\t// they are either saved or reverted\n\t\tif (workingCopy.isDirty()) {\n\t\t\tawait Event.toPromise(workingCopy.onDidChangeDirty);\n\n\t\t\treturn this.canDispose(workingCopy);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.clear();\n\t}\n\n\t//#endregion\n}\n"]}