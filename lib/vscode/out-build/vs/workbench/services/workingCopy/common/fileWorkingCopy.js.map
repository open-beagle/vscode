{"version":3,"sources":["vs/workbench/services/workingCopy/common/fileWorkingCopy.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAiOhG;;OAEG;IACH,IAAkB,oBAqCjB;IArCD,WAAkB,oBAAoB;QAErC;;WAEG;QACH,iEAAK,CAAA;QAEL;;WAEG;QACH,iEAAK,CAAA;QAEL;;;WAGG;QACH,+EAAY,CAAA;QAEZ;;;;WAIG;QACH,uEAAQ,CAAA;QAER;;;WAGG;QACH,mEAAM,CAAA;QAEN;;;;WAIG;QACH,iEAAK,CAAA;IACN,CAAC,EArCiB,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAqCrC;IA2DD,IAAa,eAAe,GAA5B,MAAa,eAAiD,SAAQ,sBAAU;QAiC/E,YAAY;QAEZ,YACU,MAAc,EACd,QAAa,EACb,IAAY,EACJ,YAA6C,EAC/B,WAAyB,EAC1B,UAAuB,EAClB,eAAiC,EACvB,yBAAqD,EACtD,wBAAmD,EAC1E,kBAAuC,EACrB,mBAAyC,EACpC,wBAAmD,EAC9D,aAA6B,EACvB,mBAAyC;YAEhF,KAAK,EAAE,CAAC;YAfC,WAAM,GAAN,MAAM,CAAQ;YACd,aAAQ,GAAR,QAAQ,CAAK;YACb,SAAI,GAAJ,IAAI,CAAQ;YACJ,iBAAY,GAAZ,YAAY,CAAiC;YAC/B,gBAAW,GAAX,WAAW,CAAc;YAC1B,eAAU,GAAV,UAAU,CAAa;YAClB,oBAAe,GAAf,eAAe,CAAkB;YACvB,8BAAyB,GAAzB,yBAAyB,CAA4B;YACtD,6BAAwB,GAAxB,wBAAwB,CAA2B;YAExD,wBAAmB,GAAnB,mBAAmB,CAAsB;YACpC,6BAAwB,GAAxB,wBAAwB,CAA2B;YAC9D,kBAAa,GAAb,aAAa,CAAgB;YACvB,wBAAmB,GAAnB,mBAAmB,CAAsB;YA/CxE,iBAAY,gBAAyD;YAEtE,WAAM,GAAkB,SAAS,CAAC;YAG1C,gBAAgB;YAEC,wBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;YAClE,uBAAkB,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC;YAE5C,kBAAa,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;YAC5D,iBAAY,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC;YAEhC,sBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;YAChE,qBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;YAExC,oBAAe,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;YAC9D,mBAAc,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;YAEpC,eAAU,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAc,CAAC,CAAC;YAC/D,cAAS,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;YAE1B,iBAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;YAC3D,gBAAW,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;YAE9B,yBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;YACnE,wBAAmB,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC;YAE9C,mBAAc,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;YAC7D,kBAAa,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;YAgCnD,2BAA2B;YAEnB,iBAAY,GAAG,KAAK,CAAC;YA4D7B,YAAY;YAEZ,eAAe;YAEP,UAAK,GAAG,KAAK,CAAC;YAgTd,oCAA+B,GAAG,KAAK,CAAC;YAqGhD,YAAY;YAEZ,cAAc;YAEN,cAAS,GAAG,CAAC,CAAC;YAGd,kCAA6B,GAAuB,SAAS,CAAC;YAErD,uBAAkB,GAAG,IAAI,0BAAkB,EAAE,CAAC;YA+Y/D,YAAY;YAEZ,eAAe;YAEP,mBAAc,GAAG,KAAK,CAAC;YACvB,gBAAW,GAAG,KAAK,CAAC;YAuC5B,YAAY;YAEZ,iBAAiB;YAET,aAAQ,GAAG,KAAK,CAAC;YAz6BxB,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAClD,MAAM,IAAI,KAAK,CAAC,kCAAkC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,oDAAoD,CAAC,CAAC;aACpI;YAED,qCAAqC;YACrC,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC;YAE7D,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC1B,CAAC;QAxDD,IAAI,KAAK,KAAoB,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QA8D1C,iBAAiB;YACxB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAClF,CAAC;QAEO,KAAK,CAAC,gBAAgB,CAAC,CAAmB;YACjD,IAAI,kBAAkB,GAAG,KAAK,CAAC;YAC/B,IAAI,oBAAyC,CAAC;YAE9C,oEAAoE;YACpE,IAAI,IAAI,CAAC,YAAY,EAAE;gBACtB,MAAM,4BAA4B,GAAG,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,gBAAuB,CAAC;gBACrF,IAAI,4BAA4B,EAAE;oBACjC,oBAAoB,GAAG,KAAK,CAAC;oBAC7B,kBAAkB,GAAG,IAAI,CAAC;iBAC1B;aACD;YAED,6CAA6C;iBACxC;gBACJ,MAAM,8BAA8B,GAAG,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,kBAAyB,CAAC;gBACzF,IAAI,8BAA8B,EAAE;oBACnC,oBAAoB,GAAG,IAAI,CAAC;oBAC5B,kBAAkB,GAAG,IAAI,CAAC;iBAC1B;aACD;YAED,IAAI,kBAAkB,IAAI,IAAI,CAAC,YAAY,KAAK,oBAAoB,EAAE;gBACrE,IAAI,wBAAwB,GAAY,KAAK,CAAC;gBAC9C,IAAI,oBAAoB,EAAE;oBAEzB,oFAAoF;oBACpF,mFAAmF;oBACnF,qFAAqF;oBACrF,wDAAwD;oBACxD,MAAM,CAAA,GAAA,eAAO,CAAA,CAAC,GAAG,CAAC,CAAC;oBAEnB,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;wBACtB,wBAAwB,GAAG,IAAI,CAAC;qBAChC;yBAAM;wBACN,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAC5D,wBAAwB,GAAG,CAAC,MAAM,CAAC;qBACnC;iBACD;gBAED,IAAI,IAAI,CAAC,YAAY,KAAK,wBAAwB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;oBACzE,IAAI,CAAC,WAAW,CAAC,wBAAwB,CAAC,CAAC;iBAC3C;aACD;QACF,CAAC;QAEO,WAAW,CAAC,QAAiB;YACpC,IAAI,IAAI,CAAC,YAAY,KAAK,QAAQ,EAAE;gBACnC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;gBAE7B,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,CAAC;aACjC;QACF,CAAC;QASD,OAAO;YACN,OAAO,IAAI,CAAC,KAAK,CAAC;QACnB,CAAC;QAED,SAAS;YACR,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACrB,CAAC;QAEO,QAAQ,CAAC,KAAc;YAC9B,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;gBACvB,OAAO,CAAC,mDAAmD;aAC3D;YAED,mCAAmC;YACnC,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;YAC5B,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YAEvB,iCAAiC;YACjC,IAAI,KAAK,KAAK,QAAQ,EAAE;gBACvB,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC;aAC9B;QACF,CAAC;QAEO,UAAU,CAAC,KAAc;YAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;YAC5B,MAAM,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC;YAC9C,MAAM,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC;YACxC,MAAM,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC;YAE9C,IAAI,CAAC,KAAK,EAAE;gBACX,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;gBACnB,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;gBAC5B,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;gBAEzB,2EAA2E;gBAC3E,4EAA4E;gBAC5E,0EAA0E;gBAC1E,2EAA2E;gBAC3E,wBAAwB;gBACxB,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;oBACtB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;iBAC3C;aACD;iBAAM;gBACN,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;aAClB;YAED,sCAAsC;YACtC,OAAO,GAAG,EAAE;gBACX,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;gBACtB,IAAI,CAAC,cAAc,GAAG,iBAAiB,CAAC;gBACxC,IAAI,CAAC,WAAW,GAAG,cAAc,CAAC;gBAClC,IAAI,CAAC,cAAc,GAAG,iBAAiB,CAAC;YACzC,CAAC,CAAC;QACH,CAAC;QAQD,KAAK,CAAC,OAAO,CAAC,OAAwC;YACrD,IAAI,CAAC,KAAK,CAAC,uCAAuC,CAAC,CAAC;YAEpD,kCAAkC;YAClC,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;gBACtB,IAAI,CAAC,KAAK,CAAC,gGAAgG,CAAC,CAAC;gBAE7G,OAAO;aACP;YAED,8EAA8E;YAC9E,iFAAiF;YACjF,aAAa;YACb,IAAI,CAAC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,CAAA,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,CAAC,EAAE;gBAC/E,IAAI,CAAC,KAAK,CAAC,4GAA4G,CAAC,CAAC;gBAEzH,OAAO;aACP;YAED,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QAChC,CAAC;QAEO,KAAK,CAAC,SAAS,CAAC,OAAwC;YAE/D,8DAA8D;YAC9D,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,EAAE;gBACtB,OAAO,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;aAChD;YAED,kFAAkF;YAClF,MAAM,KAAK,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;YACjC,IAAI,KAAK,EAAE;gBACV,MAAM,kBAAkB,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAC1D,IAAI,kBAAkB,EAAE;oBACvB,OAAO;iBACP;aACD;YAED,sCAAsC;YACtC,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;QACtC,CAAC;QAEO,KAAK,CAAC,iBAAiB,CAAC,MAA8B;YAC7D,IAAI,CAAC,KAAK,CAAC,yCAAyC,CAAC,CAAC;YAEtD,mCAAmC;YACnC,IAAI,KAAa,CAAC;YAClB,IAAI,KAAa,CAAC;YAClB,IAAI,IAAY,CAAC;YACjB,IAAI,IAAY,CAAC;YACjB,IAAI;gBACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;gBAC1F,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;gBACvB,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;gBACvB,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;gBACrB,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;gBAErB,qDAAqD;gBACrD,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aACxB;YAAC,OAAO,KAAK,EAAE;gBAEf,yCAAyC;gBACzC,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBACnB,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBACnB,IAAI,GAAG,CAAC,CAAC;gBACT,IAAI,GAAG,qBAAa,CAAC;gBAErB,2CAA2C;gBAC3C,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,mBAAmB,2BAAuC,CAAC,CAAC;aACnF;YAED,sBAAsB;YACtB,OAAO,IAAI,CAAC,kBAAkB,CAAC;gBAC9B,QAAQ,EAAE,IAAI,CAAC,QAAQ;gBACvB,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,KAAK;gBACL,KAAK;gBACL,IAAI;gBACJ,IAAI;gBACJ,KAAK,EAAE,MAAM;aACb,EAAE,IAAI,CAAC,kCAAkC,CAAC,CAAC;QAC7C,CAAC;QAEO,KAAK,CAAC,iBAAiB;YAE9B,wBAAwB;YACxB,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAiC,IAAI,CAAC,CAAC;YAEjG,mEAAmE;YACnE,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;YAC/B,IAAI,CAAC,KAAK,EAAE;gBACX,IAAI,CAAC,KAAK,CAAC,kIAAkI,CAAC,CAAC;gBAE/I,OAAO,IAAI,CAAC,CAAC,yDAAyD;aACtE;YAED,4CAA4C;YAC5C,IAAI,MAAM,EAAE;gBACX,MAAM,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;gBAEvC,OAAO,IAAI,CAAC;aACZ;YAED,sDAAsD;YACtD,OAAO,KAAK,CAAC;QACd,CAAC;QAEO,KAAK,CAAC,mBAAmB,CAAC,MAAkE;YACnG,IAAI,CAAC,KAAK,CAAC,2CAA2C,CAAC,CAAC;YAExD,sBAAsB;YACtB,MAAM,IAAI,CAAC,kBAAkB,CAAC;gBAC7B,QAAQ,EAAE,IAAI,CAAC,QAAQ;gBACvB,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;gBACnD,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;gBACnD,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACxC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,qBAAa;gBACpD,KAAK,EAAE,MAAM,CAAC,KAAK;aACnB,EAAE,IAAI,CAAC,kCAAkC,CAAC,CAAC;YAE5C,uCAAuC;YACvC,IAAI,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE;gBACxC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;aACvB;QACF,CAAC;QAEO,KAAK,CAAC,eAAe,CAAC,OAAwC;YACrE,IAAI,CAAC,KAAK,CAAC,uCAAuC,CAAC,CAAC;YAEpD,MAAM,iBAAiB,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB,CAAC;YAErD,iBAAiB;YACjB,IAAI,IAAwB,CAAC;YAC7B,IAAI,iBAAiB,EAAE;gBACtB,IAAI,GAAG,qBAAa,CAAC,CAAC,+CAA+C;aACrE;iBAAM,IAAI,IAAI,CAAC,oBAAoB,EAAE;gBACrC,IAAI,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,4CAA4C;aACnF;YAED,mEAAmE;YACnE,gEAAgE;YAChE,YAAY;YACZ,MAAM,gBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC;YAExC,kBAAkB;YAClB,IAAI;gBACH,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC;gBAE/E,qDAAqD;gBACrD,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;gBAExB,uDAAuD;gBACvD,2CAA2C;gBAC3C,IAAI,gBAAgB,KAAK,IAAI,CAAC,SAAS,EAAE;oBACxC,IAAI,CAAC,KAAK,CAAC,4GAA4G,CAAC,CAAC;oBAEzH,OAAO;iBACP;gBAED,MAAM,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,KAAK,CAAC,oCAAoC,CAAC,CAAC;aACnF;YAAC,OAAO,KAAK,EAAE;gBACf,MAAM,MAAM,GAAG,KAAK,CAAC,mBAAmB,CAAC;gBAEzC,2CAA2C;gBAC3C,IAAI,CAAC,WAAW,CAAC,MAAM,2BAAuC,CAAC,CAAC;gBAEhE,+DAA+D;gBAC/D,qBAAqB;gBACrB,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,MAAM,oCAAgD,EAAE;oBAChF,OAAO;iBACP;gBAED,6EAA6E;gBAC7E,+EAA+E;gBAC/E,iFAAiF;gBACjF,0EAA0E;gBAC1E,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,MAAM,2BAAuC,IAAI,CAAC,iBAAiB,EAAE;oBAC7F,OAAO;iBACP;gBAED,gCAAgC;gBAChC,MAAM,KAAK,CAAC;aACZ;QACF,CAAC;QAEO,KAAK,CAAC,kBAAkB,CAAC,OAA2B,EAAE,KAAc;YAC3E,IAAI,CAAC,KAAK,CAAC,kDAAkD,CAAC,CAAC;YAE/D,kCAAkC;YAClC,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;gBACtB,IAAI,CAAC,KAAK,CAAC,oFAAoF,CAAC,CAAC;gBAEjG,OAAO;aACP;YAED,gCAAgC;YAChC,IAAI,CAAC,0BAA0B,CAAC;gBAC/B,QAAQ,EAAE,IAAI,CAAC,QAAQ;gBACvB,IAAI,EAAE,OAAO,CAAC,IAAI;gBAClB,KAAK,EAAE,OAAO,CAAC,KAAK;gBACpB,KAAK,EAAE,OAAO,CAAC,KAAK;gBACpB,IAAI,EAAE,OAAO,CAAC,IAAI;gBAClB,IAAI,EAAE,OAAO,CAAC,IAAI;gBAClB,MAAM,EAAE,IAAI;gBACZ,WAAW,EAAE,KAAK;gBAClB,cAAc,EAAE,KAAK;aACrB,CAAC,CAAC;YAEH,gDAAgD;YAChD,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;gBACtB,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACxC;YAED,6BAA6B;iBACxB;gBACJ,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aACxC;YAED,iEAAiE;YACjE,iEAAiE;YACjE,iEAAiE;YACjE,iEAAiE;YACjE,eAAe;YACf,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAEvB,gBAAgB;YAChB,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;QAC3B,CAAC;QAEO,KAAK,CAAC,aAAa,CAAC,QAAgC;YAC3D,IAAI,CAAC,KAAK,CAAC,qCAAqC,CAAC,CAAC;YAElD,mDAAmD;YACnD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,gCAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;YAEnH,kBAAkB;YAClB,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACzC,CAAC;QAIO,KAAK,CAAC,aAAa,CAAC,QAAgC;;YAC3D,IAAI,CAAC,KAAK,CAAC,qCAAqC,CAAC,CAAC;YAElD,sFAAsF;YACtF,IAAI,CAAC,+BAA+B,GAAG,IAAI,CAAC;YAC5C,IAAI;gBACH,MAAM,CAAA,MAAA,IAAI,CAAC,KAAK,0CAAE,MAAM,CAAC,QAAQ,EAAE,gCAAiB,CAAC,IAAI,CAAC,CAAA,CAAC;aAC3D;oBAAS;gBACT,IAAI,CAAC,+BAA+B,GAAG,KAAK,CAAC;aAC7C;QACF,CAAC;QAEO,qBAAqB,CAAC,KAA4B;YAEzD,uDAAuD;YACvD,qFAAqF;YACrF,2EAA2E;YAE3E,iBAAiB;YACjB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YAE7G,YAAY;YACZ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAC3D,CAAC;QAEO,qBAAqB,CAAC,KAA4B,EAAE,kBAA2B;YACtF,IAAI,CAAC,KAAK,CAAC,qDAAqD,CAAC,CAAC;YAElE,6GAA6G;YAC7G,IAAI,CAAC,SAAS,EAAE,CAAC;YACjB,IAAI,CAAC,KAAK,CAAC,+DAA+D,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;YAE5F,0EAA0E;YAC1E,gEAAgE;YAChE,oDAAoD;YACpD,IAAI,kBAAkB,EAAE;gBACvB,IAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;aAChD;YAED,4EAA4E;YAC5E,mEAAmE;YACnE,yFAAyF;YACzF,IAAI,CAAC,IAAI,CAAC,+BAA+B,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;gBAEhE,yFAAyF;gBACzF,sFAAsF;gBACtF,IAAI,KAAK,CAAC,SAAS,KAAK,IAAI,CAAC,cAAc,EAAE;oBAC5C,IAAI,CAAC,KAAK,CAAC,gGAAgG,CAAC,CAAC;oBAE7G,cAAc;oBACd,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;oBAC5B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;oBAErB,qCAAqC;oBACrC,IAAI,QAAQ,EAAE;wBACb,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;qBACzB;iBACD;gBAED,yEAAyE;qBACpE;oBACJ,IAAI,CAAC,KAAK,CAAC,yFAAyF,CAAC,CAAC;oBAEtG,gBAAgB;oBAChB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;iBACpB;aACD;YAED,gBAAgB;YAChB,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,CAAC;QACjC,CAAC;QAED,YAAY;QAEZ,gBAAgB;QAEhB,KAAK,CAAC,MAAM,CAAC,KAAwB;YAEpC,sCAAsC;YACtC,IAAI,IAAI,GAA+C,SAAS,CAAC;YACjE,IAAI,IAAI,CAAC,oBAAoB,EAAE;gBAC9B,IAAI,GAAG;oBACN,KAAK,EAAE,IAAI,CAAC,oBAAoB,CAAC,KAAK;oBACtC,KAAK,EAAE,IAAI,CAAC,oBAAoB,CAAC,KAAK;oBACtC,IAAI,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI;oBACpC,IAAI,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI;oBACpC,QAAQ,EAAE,IAAI,CAAC,YAAY;iBAC3B,CAAC;aACF;YAED,qCAAqC;YACrC,IAAI,OAAO,GAAuC,SAAS,CAAC;YAC5D,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;gBACtB,OAAO,GAAG,MAAM,CAAA,GAAA,wBAAgB,CAAA,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;aACpE;YAED,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;QAC1B,CAAC;QAaD,KAAK,CAAC,IAAI,CAAC,UAAuC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;YACpE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;gBACvB,OAAO,KAAK,CAAC;aACb;YAED,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;gBACtB,IAAI,CAAC,KAAK,CAAC,qEAAqE,CAAC,CAAC;gBAElF,OAAO,KAAK,CAAC,CAAC,+DAA+D;aAC7E;YAED,IACC,CAAC,IAAI,CAAC,QAAQ,kBAA+B,IAAI,IAAI,CAAC,QAAQ,eAA4B,CAAC;gBAC3F,CAAC,OAAO,CAAC,MAAM,iBAAoB,IAAI,OAAO,CAAC,MAAM,yBAA4B,IAAI,OAAO,CAAC,MAAM,0BAA6B,CAAC,EAChI;gBACD,IAAI,CAAC,KAAK,CAAC,4GAA4G,CAAC,CAAC;gBAEzH,OAAO,KAAK,CAAC,CAAC,2FAA2F;aACzG;YAED,mBAAmB;YACnB,IAAI,CAAC,KAAK,CAAC,oCAAoC,CAAC,CAAC;YACjD,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YAC3B,IAAI,CAAC,KAAK,CAAC,mCAAmC,CAAC,CAAC;YAEhD,OAAO,IAAI,CAAC;QACb,CAAC;QAEO,KAAK,CAAC,MAAM,CAAC,OAAoC;YACxD,IAAI,OAAO,OAAO,CAAC,MAAM,KAAK,QAAQ,EAAE;gBACvC,OAAO,CAAC,MAAM,mBAAsB,CAAC;aACrC;YAED,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;YAC/B,IAAI,CAAC,KAAK,CAAC,8BAA8B,SAAS,4BAA4B,SAAS,EAAE,CAAC,CAAC;YAE3F,4EAA4E;YAC5E,EAAE;YACF,sFAAsF;YACtF,wDAAwD;YACxD,EAAE;YACF,IAAI,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;gBAClD,IAAI,CAAC,KAAK,CAAC,8BAA8B,SAAS,iDAAiD,SAAS,EAAE,CAAC,CAAC;gBAEhH,OAAO,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC;aACvC;YAED,4CAA4C;YAC5C,EAAE;YACF,+EAA+E;YAC/E,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;gBAClC,IAAI,CAAC,KAAK,CAAC,8BAA8B,SAAS,6EAA6E,IAAI,CAAC,KAAK,qBAAqB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;gBAEjL,OAAO;aACP;YAED,+FAA+F;YAC/F,8GAA8G;YAC9G,EAAE;YACF,0HAA0H;YAC1H,wBAAwB;YACxB,8HAA8H;YAC9H,yDAAyD;YACzD,EAAE;YACF,IAAI,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,EAAE;gBACzC,IAAI,CAAC,KAAK,CAAC,8BAA8B,SAAS,gCAAgC,CAAC,CAAC;gBAEpF,sDAAsD;gBACtD,oDAAoD;gBACpD,mCAAmC;gBACnC,iDAAiD;gBACjD,8CAA8C;gBAC9C,qDAAqD;gBACrD,gCAAgC;gBAChC,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,CAAC;gBAExC,qDAAqD;gBACrD,OAAO,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;aACnE;YAED,8EAA8E;YAC9E,oCAAoC;YACpC,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;gBACtB,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,CAAC;aAC9B;YAED,MAAM,gBAAgB,GAAG,IAAI,sCAAuB,EAAE,CAAC;YAEvD,OAAO,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC,KAAK,IAAI,EAAE;;gBAEhE,2DAA2D;gBAC3D,gEAAgE;gBAChE,iDAAiD;gBACjD,mEAAmE;gBACnE,mCAAmC;gBACnC,qDAAqD;gBACrD,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC,oBAAoB,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;oBAC3F,IAAI;wBAEH,mFAAmF;wBACnF,kFAAkF;wBAClF,gFAAgF;wBAChF,EAAE;wBACF,kCAAkC;wBAClC,qEAAqE;wBACrE,gFAAgF;wBAChF,yDAAyD;wBACzD,qCAAqC;wBACrC,4FAA4F;wBAC5F,6DAA6D;wBAC7D,EAAE;wBACF,iEAAiE;wBACjE,IAAI,OAAO,CAAC,MAAM,iBAAoB,IAAI,OAAO,IAAI,CAAC,6BAA6B,KAAK,QAAQ,EAAE;4BACjG,MAAM,sBAAsB,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,6BAA6B,CAAC;4BAC/E,IAAI,sBAAsB,GAAG,eAAe,CAAC,wDAAwD,EAAE;gCACtG,MAAM,CAAA,GAAA,eAAO,CAAA,CAAC,eAAe,CAAC,wDAAwD,GAAG,sBAAsB,CAAC,CAAC;6BACjH;yBACD;wBAED,4DAA4D;wBAC5D,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,uBAAuB,EAAE;4BACpD,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,mBAAmB,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,MAAM,EAAE,MAAA,OAAO,CAAC,MAAM,mDAAuB,EAAE,EAAE,gBAAgB,CAAC,KAAK,CAAC,CAAC;yBAC5I;qBACD;oBAAC,OAAO,KAAK,EAAE;wBACf,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,2CAA2C,SAAS,6BAA6B,KAAK,CAAC,QAAQ,EAAE,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;qBACtK;iBACD;gBAED,2DAA2D;gBAC3D,6DAA6D;gBAC7D,IAAI,gBAAgB,CAAC,KAAK,CAAC,uBAAuB,EAAE;oBACnD,OAAO;iBACP;gBAED,iGAAiG;gBACjG,kGAAkG;gBAClG,oGAAoG;gBACpG,gGAAgG;gBAChG,iGAAiG;gBACjG,kFAAkF;gBAClF,IAAI,IAAI,CAAC,UAAU,EAAE,EAAE;oBACtB,OAAO;iBACP;gBAED,mGAAmG;gBACnG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;oBACvB,OAAO;iBACP;gBAED,qEAAqE;gBACrE,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;gBAE3B,qDAAqD;gBACrD,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;gBAEzB,qEAAqE;gBACrE,iEAAiE;gBACjE,yBAAyB;gBACzB,IAAI,CAAC,KAAK,CAAC,8BAA8B,SAAS,oBAAoB,CAAC,CAAC;gBACxE,MAAM,oBAAoB,GAAG,CAAA,GAAA,uBAAe,CAAA,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;gBACxE,MAAM,uBAAuB,GAAG,IAAI,CAAC;gBACrC,OAAO,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC,KAAK,IAAI,EAAE;oBAChE,IAAI;wBAEH,uCAAuC;wBACvC,MAAM,QAAQ,GAAG,MAAM,CAAA,GAAA,wBAAgB,CAAA,CAAC,uBAAuB,CAAC,KAAK,CAAC,QAAQ,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,gBAAgB,CAAC,KAAK,CAAC,CAAC;wBAEhI,2DAA2D;wBAC3D,4DAA4D;wBAC5D,0DAA0D;wBAC1D,wDAAwD;wBACxD,0DAA0D;wBAC1D,4BAA4B;wBAC5B,IAAI,gBAAgB,CAAC,KAAK,CAAC,uBAAuB,EAAE;4BACnD,OAAO;yBACP;6BAAM;4BACN,gBAAgB,CAAC,OAAO,EAAE,CAAC;yBAC3B;wBAED,MAAM,gBAAgB,GAAsB;4BAC3C,KAAK,EAAE,oBAAoB,CAAC,KAAK;4BACjC,IAAI,EAAE,CAAC,OAAO,CAAC,mBAAmB,IAAI,CAAC,IAAI,CAAC,yBAAyB,CAAC,oBAAoB,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,qBAAa,CAAC,CAAC,CAAC,oBAAoB,CAAC,IAAI;4BACtK,MAAM,EAAE,OAAO,CAAC,WAAW;yBAC3B,CAAC;wBAEF,qBAAqB;wBACrB,IAAI,IAA2B,CAAC;wBAChC,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa,KAAI,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE;4BAClG,IAAI,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,oBAAoB,CAAC,QAAQ,EAAE,CAAA,GAAA,uBAAe,CAAA,CAAC,QAAQ,CAAC,EAAE,gBAAgB,CAAC,CAAC;yBACpI;6BAAM;4BACN,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,oBAAoB,CAAC,QAAQ,EAAE,CAAA,GAAA,uBAAe,CAAA,CAAC,QAAQ,CAAC,EAAE,gBAAgB,CAAC,CAAC;yBACpH;wBAED,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;qBACjD;oBAAC,OAAO,KAAK,EAAE;wBACf,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;qBAChD;gBACF,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC,CAAC;YACxC,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC,CAAC;QACxC,CAAC;QAEO,iBAAiB,CAAC,IAA2B,EAAE,SAAiB,EAAE,OAAoC;;YAE7G,0CAA0C;YAC1C,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAC;YAEtC,+DAA+D;YAC/D,IAAI,SAAS,KAAK,IAAI,CAAC,SAAS,EAAE;gBACjC,IAAI,CAAC,KAAK,CAAC,yCAAyC,SAAS,6DAA6D,CAAC,CAAC;gBAC5H,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;aACrB;iBAAM;gBACN,IAAI,CAAC,KAAK,CAAC,yCAAyC,SAAS,uEAAuE,CAAC,CAAC;aACtI;YAED,gDAAgD;YAChD,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAExB,kBAAkB;YAClB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAA,OAAO,CAAC,MAAM,mDAAuB,CAAC,CAAC;QAC7D,CAAC;QAEO,eAAe,CAAC,KAAY,EAAE,SAAiB,EAAE,OAAoC;YAC5F,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,uCAAuC,SAAS,wCAAwC,KAAK,CAAC,QAAQ,EAAE,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YAE7K,qDAAqD;YACrD,gCAAgC;YAChC,IAAI,OAAO,CAAC,kBAAkB,EAAE;gBAC/B,MAAM,KAAK,CAAC;aACZ;YAED,kFAAkF;YAClF,4EAA4E;YAC5E,+EAA+E;YAC/E,kDAAkD;YAClD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YAEpB,sBAAsB;YACtB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;YAExB,+BAA+B;YAC/B,IAAK,KAA4B,CAAC,mBAAmB,gCAA4C,EAAE;gBAClG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;aAC3B;YAED,iCAAiC;YACjC,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;gBACrC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,gBAAgB,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;aAC3E;iBAAM;gBACN,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;aAC9B;YAED,gBAAgB;YAChB,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;QAC7B,CAAC;QAEO,iBAAiB,CAAC,KAAY;;YACrC,MAAM,kBAAkB,GAAG,KAA2B,CAAC;YACvD,MAAM,cAAc,GAAc,EAAE,CAAC;YAErC,IAAI,OAAe,CAAC;YAEpB,yBAAyB;YACzB,IAAI,kBAAkB,CAAC,mBAAmB,gCAA4C,EAAE;gBACvF,OAAO,GAAG,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAgB,EAAE,IAA8G,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;gBAEhK,cAAc,CAAC,IAAI,CAAC,CAAA,GAAA,kBAAQ,CAAA,CAAC,EAAE,EAAE,EAAE,2BAA2B,EAAE,KAAK,EAAE,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAW,EAAE,IAAW,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,mBAAmB,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBACnK,cAAc,CAAC,IAAI,CAAC,CAAA,GAAA,kBAAQ,CAAA,CAAC,EAAE,EAAE,EAAE,wBAAwB,EAAE,KAAK,EAAE,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAS,EAAE,IAAS,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;aACjI;YAED,uBAAuB;iBAClB;gBACJ,MAAM,aAAa,GAAG,kBAAkB,CAAC,mBAAmB,8BAA0C,CAAC;gBACvG,MAAM,aAAa,GAAG,aAAa,KAAI,MAAA,kBAAkB,CAAC,OAAO,0CAAE,MAAM,CAAA,CAAC;gBAC1E,MAAM,kBAAkB,GAAG,kBAAkB,CAAC,mBAAmB,mCAA+C,CAAC;gBACjH,MAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAE5E,gBAAgB;gBAChB,IAAI,eAAe,IAAI,CAAC,kBAAkB,IAAI,aAAa,CAAC,EAAE;oBAC7D,cAAc,CAAC,IAAI,CAAC,CAAA,GAAA,kBAAQ,CAAA,CAAC;wBAC5B,EAAE,EAAE,8BAA8B;wBAClC,KAAK,EAAE,aAAa,CAAC,CAAC;4BACrB,oBAAS,CAAC,CAAC,CAAC,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAmB,EAAE,IAAuB,CAAC,CAAC,CAAC,CAAC,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAuB,EAAE,IAAsB,CAAC,CAAC,CAAC;4BAChI,oBAAS,CAAC,CAAC,CAAC,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAc,EAAE,IAAmB,CAAC,CAAC,CAAC,CAAC,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAkB,EAAE,IAAkB,CAAC;wBAC7G,GAAG,EAAE,GAAG,EAAE;4BACT,IAAI,CAAC,IAAI,CAAC,EAAE,aAAa,EAAE,IAAI,EAAE,WAAW,EAAE,aAAa,EAAE,MAAM,kBAAqB,EAAE,CAAC,CAAC;wBAC7F,CAAC;qBACD,CAAC,CAAC,CAAC;iBACJ;gBAED,SAAS;qBACJ,IAAI,aAAa,EAAE;oBACvB,cAAc,CAAC,IAAI,CAAC,CAAA,GAAA,kBAAQ,CAAA,CAAC,EAAE,EAAE,EAAE,wBAAwB,EAAE,KAAK,EAAE,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAW,EAAE,IAAW,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,WAAW,EAAE,IAAI,EAAE,MAAM,kBAAqB,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACrL;gBAED,QAAQ;qBACH;oBACJ,cAAc,CAAC,IAAI,CAAC,CAAA,GAAA,kBAAQ,CAAA,CAAC,EAAE,EAAE,EAAE,uBAAuB,EAAE,KAAK,EAAE,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAO,EAAE,IAAO,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,kBAAqB,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;iBACzJ;gBAED,UAAU;gBACV,cAAc,CAAC,IAAI,CAAC,CAAA,GAAA,kBAAQ,CAAA,CAAC;oBAC5B,EAAE,EAAE,wBAAwB;oBAC5B,KAAK,EAAE,CAAA,GAAA,cAAQ,CAAA,CAAC,CAAQ,EAAE,IAAY,CAAC;oBACvC,GAAG,EAAE,GAAG,EAAE;wBACT,MAAM,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;wBAC9D,IAAI,MAAM,EAAE;4BACX,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,kBAAqB,EAAE,CAAC,CAAC;yBAC/E;oBACF,CAAC;iBACD,CAAC,CAAC,CAAC;gBAEJ,UAAU;gBACV,cAAc,CAAC,IAAI,CAAC,CAAA,GAAA,kBAAQ,CAAA,CAAC,EAAE,EAAE,EAAE,wBAAwB,EAAE,KAAK,EAAE,CAAA,GAAA,cAAQ,CAAA,CAAC,EAAS,EAAE,IAAS,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;gBAEjI,UAAU;gBACV,IAAI,aAAa,EAAE;oBAClB,IAAI,aAAa,IAAI,eAAe,EAAE;wBACrC,OAAO,GAAG,oBAAS,CAAC,CAAC;4BACpB,CAAA,GAAA,cAAQ,CAAA,CAAC,EAAwB,EAAE,IAAiG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;4BAClJ,CAAA,GAAA,cAAQ,CAAA,CAAC,EAAuB,EAAE,IAA4F,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;qBAC5I;yBAAM;wBACN,OAAO,GAAG,CAAA,GAAA,cAAQ,CAAA,CAAC,EAAmB,EAAE,IAA8F,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;qBACnJ;iBACD;qBAAM,IAAI,eAAe,IAAI,kBAAkB,EAAE;oBACjD,OAAO,GAAG,oBAAS,CAAC,CAAC;wBACpB,CAAA,GAAA,cAAQ,CAAA,CAAC,EAA2B,EAAE,IAAoG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;wBACxJ,CAAA,GAAA,cAAQ,CAAA,CAAC,EAA+B,EAAE,IAA+F,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;iBACvJ;qBAAM;oBACN,OAAO,GAAG,CAAA,GAAA,cAAQ,CAAA,CAAC,EAAE,AAAyG,EAAE,CAAxG,EAAE,CAAiI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAA,GAA5H,AAA4H,EAA1H,OAAO,EAAE,CAAC,iBAA8H,CAAA,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,iCAA3E,CAAC;iBAC5H;aACD;YAED,mCAAmC;YACnC,MAAM,MAAM,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,GAAG,CAAA,GAAA,WAAI,CAAA,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,EAAE,EAAE,QAAQ,EAAE,uBAAQ,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,EAAE,OAAO,EAAE,cAAc,EAAE,EAAE,CAAC,CAAC;YAErK,kDAAkD;YAClD,MAAM,QAAQ,GAAG,aAAK,CAAC,IAAI,CAAC,aAAK,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;YAC/F,aAAK,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC;QACzD,CAAC;QAEO,0BAA0B,CAAC,WAAkC;YAEpE,4BAA4B;YAC5B,IAAI,CAAC,IAAI,CAAC,oBAAoB,EAAE;gBAC/B,IAAI,CAAC,oBAAoB,GAAG,WAAW,CAAC;aACxC;YAED,qEAAqE;YACrE,4BAA4B;YAC5B,qEAAqE;YACrE,qEAAqE;YACrE,QAAQ;iBACH,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,IAAI,WAAW,CAAC,KAAK,EAAE;gBAC9D,IAAI,CAAC,oBAAoB,GAAG,WAAW,CAAC;aACxC;QACF,CAAC;QAED,YAAY;QAEZ,gBAAgB;QAEhB,KAAK,CAAC,MAAM,CAAC,OAAwB;YACpC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,KAAK,CAAA,CAAC,EAAE;gBAC3D,OAAO,CAAC,uDAAuD;aAC/D;YAED,cAAc;YACd,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;YAC5B,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YAE5C,6CAA6C;YAC7C,MAAM,QAAQ,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,IAAI,CAAC;YAC/B,IAAI,CAAC,QAAQ,EAAE;gBACd,IAAI;oBACH,MAAM,IAAI,CAAC,OAAO,CAAC,EAAE,iBAAiB,EAAE,IAAI,EAAE,CAAC,CAAC;iBAChD;gBAAC,OAAO,KAAK,EAAE;oBAEf,kEAAkE;oBAClE,IAAK,KAA4B,CAAC,mBAAmB,2BAAuC,EAAE;wBAE7F,yEAAyE;wBACzE,YAAY,EAAE,CAAC;wBAEf,MAAM,KAAK,CAAC;qBACZ;iBACD;aACD;YAED,yBAAyB;YACzB,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;YAEzB,0BAA0B;YAC1B,IAAI,QAAQ,EAAE;gBACb,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC;aAC9B;QACF,CAAC;QASD,QAAQ,CAAC,KAA2B;YACnC,QAAQ,KAAK,EAAE;gBACd;oBACC,OAAO,IAAI,CAAC,cAAc,CAAC;gBAC5B;oBACC,OAAO,IAAI,CAAC,KAAK,CAAC;gBACnB;oBACC,OAAO,IAAI,CAAC,WAAW,CAAC;gBACzB;oBACC,OAAO,IAAI,CAAC,YAAY,CAAC;gBAC1B;oBACC,OAAO,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,CAAC;gBAC7C;oBACC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC;aACpB;QACF,CAAC;QAED,SAAS,CAAC,KAAwC;;YACjD,OAAO,MAAA,IAAI,CAAC,kBAAkB,CAAC,OAAO,mCAAI,OAAO,CAAC,OAAO,EAAE,CAAC;QAC7D,CAAC;QAED,YAAY;QAEZ,mBAAmB;QAEnB,UAAU;YACT,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;QACrB,CAAC;QAED,UAAU;YACT,OAAO,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,sBAA0C,CAAC;QAC/F,CAAC;QAEO,KAAK,CAAC,GAAW;YACxB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACvE,CAAC;QAQD,UAAU;YACT,OAAO,IAAI,CAAC,QAAQ,CAAC;QACtB,CAAC;QAEQ,OAAO;YACf,IAAI,CAAC,KAAK,CAAC,+BAA+B,CAAC,CAAC;YAE5C,QAAQ;YACR,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;YAC5B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;YAC1B,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;YAEzB,QAAQ;YACR,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;YAE3B,KAAK,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;QAED,YAAY;QAEZ,wGAAwG;QAEhG,eAAe,CAAC,KAAc;YACrC,MAAM,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAEpE,OAAO,CAAC,CAAC,CAAC,aAAa,IAAI,IAAI,CAAC,KAAK,IAAK,aAAyB,KAAM,IAAI,CAAC,KAAiB,CAAC,CAAC;QAClG,CAAC;KAGD,CAAA;IAlewB,wEAAwD,GAAG,GAAG,CAAC;IA5hB3E,eAAe;QAwCzB,WAAA,oBAAY,CAAA;QACZ,WAAA,iBAAW,CAAA;QACX,WAAA,4BAAgB,CAAA;QAChB,WAAA,sDAA0B,CAAA;QAC1B,WAAA,6CAAyB,CAAA;QACzB,WAAA,wCAAmB,CAAA;QACnB,YAAA,mCAAoB,CAAA;QACpB,YAAA,oDAAyB,CAAA;QACzB,YAAA,8BAAc,CAAA;QACd,YAAA,0CAAoB,CAAA;OAjDV,eAAe,CA8/B3B;IA9/BY,0CAAe","file":"fileWorkingCopy.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\nimport { URI } from 'vs/base/common/uri';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { ETAG_DISABLED, FileChangesEvent, FileChangeType, FileOperationError, FileOperationResult, FileSystemProviderCapabilities, IFileService, IFileStatWithMetadata, IFileStreamContent, IWriteFileOptions } from 'vs/platform/files/common/files';\nimport { ISaveOptions, IRevertOptions, SaveReason } from 'vs/workbench/common/editor';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { IWorkingCopy, IWorkingCopyBackup, IWorkingCopyBackupMeta, WorkingCopyCapabilities } from 'vs/workbench/services/workingCopy/common/workingCopy';\nimport { raceCancellation, TaskSequentializer, timeout } from 'vs/base/common/async';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { assertIsDefined } from 'vs/base/common/types';\nimport { ITextFileEditorModel, ITextFileService } from 'vs/workbench/services/textfile/common/textfiles';\nimport { VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { IFilesConfigurationService } from 'vs/workbench/services/filesConfiguration/common/filesConfigurationService';\nimport { IWorkingCopyBackupService, IResolvedWorkingCopyBackup } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { INotificationService, Severity } from 'vs/platform/notification/common/notification';\nimport { hash } from 'vs/base/common/hash';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { IAction, toAction } from 'vs/base/common/actions';\nimport { isWindows } from 'vs/base/common/platform';\nimport { IWorkingCopyEditorService } from 'vs/workbench/services/workingCopy/common/workingCopyEditorService';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IElevatedFileService } from 'vs/workbench/services/files/common/elevatedFileService';\n\nexport interface IFileWorkingCopyModelFactory<T extends IFileWorkingCopyModel> {\n\n\t/**\n\t * Asks the file working copy delegate to create a model from the given\n\t * content under the provided resource. The content may originate from\n\t * different sources depending on context:\n\t * - from a backup if that exists\n\t * - from the underlying file resource\n\t * - passed in from the caller\n\t *\n\t * @param resource the `URI` of the model\n\t * @param contents the content of the model to create it\n\t * @param token support for cancellation\n\t */\n\tcreateModel(resource: URI, contents: VSBufferReadableStream, token: CancellationToken): Promise<T>;\n}\n\n/**\n * The underlying model of a file working copy provides some\n * methods for the file working copy to function. The model is\n * typically only available after the working copy has been\n * resolved via it's `resolve()` method.\n */\nexport interface IFileWorkingCopyModel extends IDisposable {\n\n\t/**\n\t * This event signals ANY changes to the contents of the file\n\t * working copy model, for example:\n\t * - through the user typing into the editor\n\t * - from API usage (e.g. bulk edits)\n\t * - when `IFileWorkingCopyModel#update` is invoked with contents\n\t *   that are different from the current contents\n\t *\n\t * The file working copy will listen to these changes and mark\n\t * the working copy as dirty whenever this event fires.\n\t *\n\t * Note: ONLY report changes to the model but not the underlying\n\t * file. The file working copy is tracking changes to the file\n\t * automatically.\n\t */\n\treadonly onDidChangeContent: Event<IFileWorkingCopyModelContentChangedEvent>;\n\n\t/**\n\t * An event emitted right before disposing the model.\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * A version ID of the model. If a `onDidChangeContent` is fired\n\t * from the model and the last known saved `versionId` matches\n\t * with the `model.versionId`, the file working copy will discard\n\t * any dirty state.\n\t *\n\t * A use case is the following:\n\t * - a file working copy gets edited and thus dirty\n\t * - the user triggers undo to revert the changes\n\t * - at this point the `versionId` should match the one we had saved\n\t *\n\t * This requires the model to be aware of undo/redo operations.\n\t */\n\treadonly versionId: unknown;\n\n\t/**\n\t * Snapshots the model's current content for writing. This must include\n\t * any changes that were made to the model that are in memory.\n\t *\n\t * @param token support for cancellation\n\t */\n\tsnapshot(token: CancellationToken): Promise<VSBufferReadableStream>;\n\n\t/**\n\t * Updates the model with the provided contents. The implementation should\n\t * behave in a similar fashion as `IFileWorkingCopyModelFactory#createModel`\n\t * except that here the model already exists and just needs to update to\n\t * the provided contents.\n\t *\n\t * Note: it is expected that the model fires a `onDidChangeContent` event\n\t * as part of the update.\n\t *\n\t * @param the contents to use for the model\n\t * @param token support for cancellation\n\t */\n\tupdate(contents: VSBufferReadableStream, token: CancellationToken): Promise<void>;\n\n\t/**\n\t * Close the current undo-redo element. This offers a way\n\t * to create an undo/redo stop point.\n\t *\n\t * This method may for example be called right before the\n\t * save is triggered so that the user can always undo back\n\t * to the state before saving.\n\t */\n\tpushStackElement(): void;\n}\n\nexport interface IFileWorkingCopyModelContentChangedEvent {\n\n\t/**\n\t * Flag that indicates that this event was generated while undoing.\n\t */\n\treadonly isUndoing: boolean;\n\n\t/**\n\t * Flag that indicates that this event was generated while redoing.\n\t */\n\treadonly isRedoing: boolean;\n}\n\n/**\n * A file based `IWorkingCopy` is backed by a `URI` from a\n * known file system provider. Given this assumption, a lot\n * of functionality can be built on top, such as saving in\n * a secure way to prevent data loss.\n */\nexport interface IFileWorkingCopy<T extends IFileWorkingCopyModel> extends IWorkingCopy, Disposable {\n\n\t/**\n\t * An event for when a file working copy was resolved.\n\t */\n\treadonly onDidResolve: Event<void>;\n\n\t/**\n\t * An event for when a file working copy was saved successfully.\n\t */\n\treadonly onDidSave: Event<SaveReason>;\n\n\t/**\n\t * An event indicating that a file working copy save operation failed.\n\t */\n\treadonly onDidSaveError: Event<void>;\n\n\t/**\n\t * An event for when the file working copy was reverted.\n\t */\n\treadonly onDidRevert: Event<void>;\n\n\t/**\n\t * An event for when the orphaned state of the file working copy changes.\n\t */\n\treadonly onDidChangeOrphaned: Event<void>;\n\n\t/**\n\t * An event for when the file working copy has been disposed.\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * Provides access to the underlying model of this file\n\t * based working copy. As long as the file working copy\n\t * has not been resolved, the model is `undefined`.\n\t */\n\treadonly model: T | undefined;\n\n\t/**\n\t * Resolves a file working copy.\n\t */\n\tresolve(options?: IFileWorkingCopyResolveOptions): Promise<void>;\n\n\t/**\n\t * Explicitly sets the working copy to be dirty.\n\t */\n\tmarkDirty(): void;\n\n\t/**\n\t * Whether the file working copy is in the provided `state`\n\t * or not.\n\t *\n\t * @param state the `FileWorkingCopyState` to check on.\n\t */\n\thasState(state: FileWorkingCopyState): boolean;\n\n\t/**\n\t * Allows to join a state change away from the provided `state`.\n\t *\n\t * @param state currently only `FileWorkingCopyState.PENDING_SAVE`\n\t * can be awaited on to resolve.\n\t */\n\tjoinState(state: FileWorkingCopyState.PENDING_SAVE): Promise<void>;\n\n\t/**\n\t * Whether we have a resolved model or not.\n\t */\n\tisResolved(): this is IResolvedFileWorkingCopy<T>;\n\n\t/**\n\t * Whether the file working copy has been disposed or not.\n\t */\n\tisDisposed(): boolean;\n}\n\nexport interface IResolvedFileWorkingCopy<T extends IFileWorkingCopyModel> extends IFileWorkingCopy<T> {\n\n\t/**\n\t * A resolved file working copy has a resolved model `T`.\n\t */\n\treadonly model: T;\n}\n\n/**\n * States the file working copy can be in.\n */\nexport const enum FileWorkingCopyState {\n\n\t/**\n\t * A file working copy is saved.\n\t */\n\tSAVED,\n\n\t/**\n\t * A file working copy is dirty.\n\t */\n\tDIRTY,\n\n\t/**\n\t * A file working copy is currently being saved but\n\t * this operation has not completed yet.\n\t */\n\tPENDING_SAVE,\n\n\t/**\n\t * A file working copy is in conflict mode when changes\n\t * cannot be saved because the underlying file has changed.\n\t * File working copies in conflict mode are always dirty.\n\t */\n\tCONFLICT,\n\n\t/**\n\t * A file working copy is in orphan state when the underlying\n\t * file has been deleted.\n\t */\n\tORPHAN,\n\n\t/**\n\t * Any error that happens during a save that is not causing\n\t * the `FileWorkingCopyState.CONFLICT` state.\n\t * File working copies in error mode are always dirty.\n\t */\n\tERROR\n}\n\nexport interface IFileWorkingCopySaveOptions extends ISaveOptions {\n\n\t/**\n\t * Save the file working copy with an attempt to unlock it.\n\t */\n\twriteUnlock?: boolean;\n\n\t/**\n\t * Save the file working copy with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\twriteElevated?: boolean;\n\n\t/**\n\t * Allows to write to a file working copy even if it has been\n\t * modified on disk. This should only be triggered from an\n\t * explicit user action.\n\t */\n\tignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the file working copy save error to\n\t * the caller instead of handling it.\n\t */\n\tignoreErrorHandler?: boolean;\n}\n\nexport interface IFileWorkingCopyResolveOptions {\n\n\t/**\n\t * The contents to use for the file working copy if known. If not\n\t * provided, the contents will be retrieved from the underlying\n\t * resource or backup if present.\n\t *\n\t * If contents are provided, the file working copy will be marked\n\t * as dirty right from the beginning.\n\t */\n\tcontents?: VSBufferReadableStream;\n\n\t/**\n\t * Go to disk bypassing any cache of the file working copy if any.\n\t */\n\tforceReadFromFile?: boolean;\n}\n\n/**\n * Metadata associated with a file working copy backup.\n */\ninterface IFileWorkingCopyBackupMetaData extends IWorkingCopyBackupMeta {\n\tmtime: number;\n\tctime: number;\n\tsize: number;\n\tetag: string;\n\torphaned: boolean;\n}\n\nexport class FileWorkingCopy<T extends IFileWorkingCopyModel> extends Disposable implements IFileWorkingCopy<T>  {\n\n\treadonly capabilities: WorkingCopyCapabilities = WorkingCopyCapabilities.None;\n\n\tprivate _model: T | undefined = undefined;\n\tget model(): T | undefined { return this._model; }\n\n\t//#region events\n\n\tprivate readonly _onDidChangeContent = this._register(new Emitter<void>());\n\treadonly onDidChangeContent = this._onDidChangeContent.event;\n\n\tprivate readonly _onDidResolve = this._register(new Emitter<void>());\n\treadonly onDidResolve = this._onDidResolve.event;\n\n\tprivate readonly _onDidChangeDirty = this._register(new Emitter<void>());\n\treadonly onDidChangeDirty = this._onDidChangeDirty.event;\n\n\tprivate readonly _onDidSaveError = this._register(new Emitter<void>());\n\treadonly onDidSaveError = this._onDidSaveError.event;\n\n\tprivate readonly _onDidSave = this._register(new Emitter<SaveReason>());\n\treadonly onDidSave = this._onDidSave.event;\n\n\tprivate readonly _onDidRevert = this._register(new Emitter<void>());\n\treadonly onDidRevert = this._onDidRevert.event;\n\n\tprivate readonly _onDidChangeOrphaned = this._register(new Emitter<void>());\n\treadonly onDidChangeOrphaned = this._onDidChangeOrphaned.event;\n\n\tprivate readonly _onWillDispose = this._register(new Emitter<void>());\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\t//#endregion\n\n\tconstructor(\n\t\treadonly typeId: string,\n\t\treadonly resource: URI,\n\t\treadonly name: string,\n\t\tprivate readonly modelFactory: IFileWorkingCopyModelFactory<T>,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@ITextFileService private readonly textFileService: ITextFileService,\n\t\t@IFilesConfigurationService private readonly filesConfigurationService: IFilesConfigurationService,\n\t\t@IWorkingCopyBackupService private readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@IWorkingCopyService workingCopyService: IWorkingCopyService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IWorkingCopyEditorService private readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IElevatedFileService private readonly elevatedFileService: IElevatedFileService\n\t) {\n\t\tsuper();\n\n\t\tif (!fileService.canHandleResource(this.resource)) {\n\t\t\tthrow new Error(`The file working copy resource ${this.resource.toString(true)} does not have an associated file system provider.`);\n\t\t}\n\n\t\t// Make known to working copy service\n\t\tthis._register(workingCopyService.registerWorkingCopy(this));\n\n\t\tthis.registerListeners();\n\t}\n\n\t//#region Orphaned Tracking\n\n\tprivate inOrphanMode = false;\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));\n\t}\n\n\tprivate async onDidFilesChange(e: FileChangesEvent): Promise<void> {\n\t\tlet fileEventImpactsUs = false;\n\t\tlet newInOrphanModeGuess: boolean | undefined;\n\n\t\t// If we are currently orphaned, we check if the file was added back\n\t\tif (this.inOrphanMode) {\n\t\t\tconst fileWorkingCopyResourceAdded = e.contains(this.resource, FileChangeType.ADDED);\n\t\t\tif (fileWorkingCopyResourceAdded) {\n\t\t\t\tnewInOrphanModeGuess = false;\n\t\t\t\tfileEventImpactsUs = true;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise we check if the file was deleted\n\t\telse {\n\t\t\tconst fileWorkingCopyResourceDeleted = e.contains(this.resource, FileChangeType.DELETED);\n\t\t\tif (fileWorkingCopyResourceDeleted) {\n\t\t\t\tnewInOrphanModeGuess = true;\n\t\t\t\tfileEventImpactsUs = true;\n\t\t\t}\n\t\t}\n\n\t\tif (fileEventImpactsUs && this.inOrphanMode !== newInOrphanModeGuess) {\n\t\t\tlet newInOrphanModeValidated: boolean = false;\n\t\t\tif (newInOrphanModeGuess) {\n\n\t\t\t\t// We have received reports of users seeing delete events even though the file still\n\t\t\t\t// exists (network shares issue: https://github.com/microsoft/vscode/issues/13665).\n\t\t\t\t// Since we do not want to mark the working copy as orphaned, we have to check if the\n\t\t\t\t// file is really gone and not just a faulty file event.\n\t\t\t\tawait timeout(100);\n\n\t\t\t\tif (this.isDisposed()) {\n\t\t\t\t\tnewInOrphanModeValidated = true;\n\t\t\t\t} else {\n\t\t\t\t\tconst exists = await this.fileService.exists(this.resource);\n\t\t\t\t\tnewInOrphanModeValidated = !exists;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.inOrphanMode !== newInOrphanModeValidated && !this.isDisposed()) {\n\t\t\t\tthis.setOrphaned(newInOrphanModeValidated);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setOrphaned(orphaned: boolean): void {\n\t\tif (this.inOrphanMode !== orphaned) {\n\t\t\tthis.inOrphanMode = orphaned;\n\n\t\t\tthis._onDidChangeOrphaned.fire();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Dirty\n\n\tprivate dirty = false;\n\tprivate savedVersionId: unknown;\n\n\tisDirty(): this is IResolvedFileWorkingCopy<T> {\n\t\treturn this.dirty;\n\t}\n\n\tmarkDirty(): void {\n\t\tthis.setDirty(true);\n\t}\n\n\tprivate setDirty(dirty: boolean): void {\n\t\tif (!this.isResolved()) {\n\t\t\treturn; // only resolved working copies can be marked dirty\n\t\t}\n\n\t\t// Track dirty state and version id\n\t\tconst wasDirty = this.dirty;\n\t\tthis.doSetDirty(dirty);\n\n\t\t// Emit as Event if dirty changed\n\t\tif (dirty !== wasDirty) {\n\t\t\tthis._onDidChangeDirty.fire();\n\t\t}\n\t}\n\n\tprivate doSetDirty(dirty: boolean): () => void {\n\t\tconst wasDirty = this.dirty;\n\t\tconst wasInConflictMode = this.inConflictMode;\n\t\tconst wasInErrorMode = this.inErrorMode;\n\t\tconst oldSavedVersionId = this.savedVersionId;\n\n\t\tif (!dirty) {\n\t\t\tthis.dirty = false;\n\t\t\tthis.inConflictMode = false;\n\t\t\tthis.inErrorMode = false;\n\n\t\t\t// we remember the models alternate version id to remember when the version\n\t\t\t// of the model matches with the saved version on disk. we need to keep this\n\t\t\t// in order to find out if the model changed back to a saved version (e.g.\n\t\t\t// when undoing long enough to reach to a version that is saved and then to\n\t\t\t// clear the dirty flag)\n\t\t\tif (this.isResolved()) {\n\t\t\t\tthis.savedVersionId = this.model.versionId;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.dirty = true;\n\t\t}\n\n\t\t// Return function to revert this call\n\t\treturn () => {\n\t\t\tthis.dirty = wasDirty;\n\t\t\tthis.inConflictMode = wasInConflictMode;\n\t\t\tthis.inErrorMode = wasInErrorMode;\n\t\t\tthis.savedVersionId = oldSavedVersionId;\n\t\t};\n\t}\n\n\t//#endregion\n\n\t//#region Resolve\n\n\tprivate lastResolvedFileStat: IFileStatWithMetadata | undefined;\n\n\tasync resolve(options?: IFileWorkingCopyResolveOptions): Promise<void> {\n\t\tthis.trace('[file working copy] resolve() - enter');\n\n\t\t// Return early if we are disposed\n\t\tif (this.isDisposed()) {\n\t\t\tthis.trace('[file working copy] resolve() - exit - without resolving because file working copy is disposed');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Unless there are explicit contents provided, it is important that we do not\n\t\t// resolve a working copy that is dirty or is in the process of saving to prevent\n\t\t// data loss.\n\t\tif (!options?.contents && (this.dirty || this.saveSequentializer.hasPending())) {\n\t\t\tthis.trace('[file working copy] resolve() - exit - without resolving because file working copy is dirty or being saved');\n\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.doResolve(options);\n\t}\n\n\tprivate async doResolve(options?: IFileWorkingCopyResolveOptions): Promise<void> {\n\n\t\t// First check if we have contents to use for the working copy\n\t\tif (options?.contents) {\n\t\t\treturn this.resolveFromBuffer(options.contents);\n\t\t}\n\n\t\t// Second, check if we have a backup to resolve from (only for new working copies)\n\t\tconst isNew = !this.isResolved();\n\t\tif (isNew) {\n\t\t\tconst resolvedFromBackup = await this.resolveFromBackup();\n\t\t\tif (resolvedFromBackup) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Finally, resolve from file resource\n\t\treturn this.resolveFromFile(options);\n\t}\n\n\tprivate async resolveFromBuffer(buffer: VSBufferReadableStream): Promise<void> {\n\t\tthis.trace('[file working copy] resolveFromBuffer()');\n\n\t\t// Try to resolve metdata from disk\n\t\tlet mtime: number;\n\t\tlet ctime: number;\n\t\tlet size: number;\n\t\tlet etag: string;\n\t\ttry {\n\t\t\tconst metadata = await this.fileService.resolve(this.resource, { resolveMetadata: true });\n\t\t\tmtime = metadata.mtime;\n\t\t\tctime = metadata.ctime;\n\t\t\tsize = metadata.size;\n\t\t\tetag = metadata.etag;\n\n\t\t\t// Clear orphaned state when resolving was successful\n\t\t\tthis.setOrphaned(false);\n\t\t} catch (error) {\n\n\t\t\t// Put some fallback values in error case\n\t\t\tmtime = Date.now();\n\t\t\tctime = Date.now();\n\t\t\tsize = 0;\n\t\t\tetag = ETAG_DISABLED;\n\n\t\t\t// Apply orphaned state based on error code\n\t\t\tthis.setOrphaned(error.fileOperationResult === FileOperationResult.FILE_NOT_FOUND);\n\t\t}\n\n\t\t// Resolve with buffer\n\t\treturn this.resolveFromContent({\n\t\t\tresource: this.resource,\n\t\t\tname: this.name,\n\t\t\tmtime,\n\t\t\tctime,\n\t\t\tsize,\n\t\t\tetag,\n\t\t\tvalue: buffer\n\t\t}, true /* dirty (resolved from buffer) */);\n\t}\n\n\tprivate async resolveFromBackup(): Promise<boolean> {\n\n\t\t// Resolve backup if any\n\t\tconst backup = await this.workingCopyBackupService.resolve<IFileWorkingCopyBackupMetaData>(this);\n\n\t\t// Abort if someone else managed to resolve the working copy by now\n\t\tlet isNew = !this.isResolved();\n\t\tif (!isNew) {\n\t\t\tthis.trace('[file working copy] resolveFromBackup() - exit - withoutresolving because previously new file working copy got created meanwhile');\n\n\t\t\treturn true; // imply that resolving has happened in another operation\n\t\t}\n\n\t\t// Try to resolve from backup if we have any\n\t\tif (backup) {\n\t\t\tawait this.doResolveFromBackup(backup);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Otherwise signal back that resolving did not happen\n\t\treturn false;\n\t}\n\n\tprivate async doResolveFromBackup(backup: IResolvedWorkingCopyBackup<IFileWorkingCopyBackupMetaData>): Promise<void> {\n\t\tthis.trace('[file working copy] doResolveFromBackup()');\n\n\t\t// Resolve with backup\n\t\tawait this.resolveFromContent({\n\t\t\tresource: this.resource,\n\t\t\tname: this.name,\n\t\t\tmtime: backup.meta ? backup.meta.mtime : Date.now(),\n\t\t\tctime: backup.meta ? backup.meta.ctime : Date.now(),\n\t\t\tsize: backup.meta ? backup.meta.size : 0,\n\t\t\tetag: backup.meta ? backup.meta.etag : ETAG_DISABLED, // etag disabled if unknown!\n\t\t\tvalue: backup.value\n\t\t}, true /* dirty (resolved from backup) */);\n\n\t\t// Restore orphaned flag based on state\n\t\tif (backup.meta && backup.meta.orphaned) {\n\t\t\tthis.setOrphaned(true);\n\t\t}\n\t}\n\n\tprivate async resolveFromFile(options?: IFileWorkingCopyResolveOptions): Promise<void> {\n\t\tthis.trace('[file working copy] resolveFromFile()');\n\n\t\tconst forceReadFromFile = options?.forceReadFromFile;\n\n\t\t// Decide on etag\n\t\tlet etag: string | undefined;\n\t\tif (forceReadFromFile) {\n\t\t\tetag = ETAG_DISABLED; // disable ETag if we enforce to read from disk\n\t\t} else if (this.lastResolvedFileStat) {\n\t\t\tetag = this.lastResolvedFileStat.etag; // otherwise respect etag to support caching\n\t\t}\n\n\t\t// Remember current version before doing any long running operation\n\t\t// to ensure we are not changing a working copy that was changed\n\t\t// meanwhile\n\t\tconst currentVersionId = this.versionId;\n\n\t\t// Resolve Content\n\t\ttry {\n\t\t\tconst content = await this.fileService.readFileStream(this.resource, { etag });\n\n\t\t\t// Clear orphaned state when resolving was successful\n\t\t\tthis.setOrphaned(false);\n\n\t\t\t// Return early if the working copy content has changed\n\t\t\t// meanwhile to prevent loosing any changes\n\t\t\tif (currentVersionId !== this.versionId) {\n\t\t\t\tthis.trace('[file working copy] resolveFromFile() - exit - without resolving because file working copy content changed');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait this.resolveFromContent(content, false /* not dirty (resolved from file) */);\n\t\t} catch (error) {\n\t\t\tconst result = error.fileOperationResult;\n\n\t\t\t// Apply orphaned state based on error code\n\t\t\tthis.setOrphaned(result === FileOperationResult.FILE_NOT_FOUND);\n\n\t\t\t// NotModified status is expected and can be handled gracefully\n\t\t\t// if we are resolved\n\t\t\tif (this.isResolved() && result === FileOperationResult.FILE_NOT_MODIFIED_SINCE) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Unless we are forced to read from the file, ignore when a working copy has\n\t\t\t// been resolved once and the file was deleted meanwhile. Since we already have\n\t\t\t// the working copy resolved, we can return to this state and update the orphaned\n\t\t\t// flag to indicate that this working copy has no version on disk anymore.\n\t\t\tif (this.isResolved() && result === FileOperationResult.FILE_NOT_FOUND && !forceReadFromFile) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise bubble up the error\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async resolveFromContent(content: IFileStreamContent, dirty: boolean): Promise<void> {\n\t\tthis.trace('[file working copy] resolveFromContent() - enter');\n\n\t\t// Return early if we are disposed\n\t\tif (this.isDisposed()) {\n\t\t\tthis.trace('[file working copy] resolveFromContent() - exit - because working copy is disposed');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Update our resolved disk stat\n\t\tthis.updateLastResolvedFileStat({\n\t\t\tresource: this.resource,\n\t\t\tname: content.name,\n\t\t\tmtime: content.mtime,\n\t\t\tctime: content.ctime,\n\t\t\tsize: content.size,\n\t\t\tetag: content.etag,\n\t\t\tisFile: true,\n\t\t\tisDirectory: false,\n\t\t\tisSymbolicLink: false\n\t\t});\n\n\t\t// Update existing model if we had been resolved\n\t\tif (this.isResolved()) {\n\t\t\tawait this.doUpdateModel(content.value);\n\t\t}\n\n\t\t// Create new model otherwise\n\t\telse {\n\t\t\tawait this.doCreateModel(content.value);\n\t\t}\n\n\t\t// Update working copy dirty flag. This is very important to call\n\t\t// in both cases of dirty or not because it conditionally updates\n\t\t// the `savedVersionId` to determine the version when to consider\n\t\t// the working copy as saved again (e.g. when undoing back to the\n\t\t// saved state)\n\t\tthis.setDirty(!!dirty);\n\n\t\t// Emit as event\n\t\tthis._onDidResolve.fire();\n\t}\n\n\tprivate async doCreateModel(contents: VSBufferReadableStream): Promise<void> {\n\t\tthis.trace('[file working copy] doCreateModel()');\n\n\t\t// Create model and dispose it when we get disposed\n\t\tthis._model = this._register(await this.modelFactory.createModel(this.resource, contents, CancellationToken.None));\n\n\t\t// Model listeners\n\t\tthis.installModelListeners(this._model);\n\t}\n\n\tprivate ignoreDirtyOnModelContentChange = false;\n\n\tprivate async doUpdateModel(contents: VSBufferReadableStream): Promise<void> {\n\t\tthis.trace('[file working copy] doUpdateModel()');\n\n\t\t// Update model value in a block that ignores content change events for dirty tracking\n\t\tthis.ignoreDirtyOnModelContentChange = true;\n\t\ttry {\n\t\t\tawait this.model?.update(contents, CancellationToken.None);\n\t\t} finally {\n\t\t\tthis.ignoreDirtyOnModelContentChange = false;\n\t\t}\n\t}\n\n\tprivate installModelListeners(model: IFileWorkingCopyModel): void {\n\n\t\t// See https://github.com/microsoft/vscode/issues/30189\n\t\t// This code has been extracted to a different method because it caused a memory leak\n\t\t// where `value` was captured in the content change listener closure scope.\n\n\t\t// Content Change\n\t\tthis._register(model.onDidChangeContent(e => this.onModelContentChanged(model, e.isUndoing || e.isRedoing)));\n\n\t\t// Lifecycle\n\t\tthis._register(model.onWillDispose(() => this.dispose()));\n\t}\n\n\tprivate onModelContentChanged(model: IFileWorkingCopyModel, isUndoingOrRedoing: boolean): void {\n\t\tthis.trace(`[file working copy] onModelContentChanged() - enter`);\n\n\t\t// In any case increment the version id because it tracks the textual content state of the model at all times\n\t\tthis.versionId++;\n\t\tthis.trace(`[file working copy] onModelContentChanged() - new versionId ${this.versionId}`);\n\n\t\t// Remember when the user changed the model through a undo/redo operation.\n\t\t// We need this information to throttle save participants to fix\n\t\t// https://github.com/microsoft/vscode/issues/102542\n\t\tif (isUndoingOrRedoing) {\n\t\t\tthis.lastContentChangeFromUndoRedo = Date.now();\n\t\t}\n\n\t\t// We mark check for a dirty-state change upon model content change, unless:\n\t\t// - explicitly instructed to ignore it (e.g. from model.resolve())\n\t\t// - the model is readonly (in that case we never assume the change was done by the user)\n\t\tif (!this.ignoreDirtyOnModelContentChange && !this.isReadonly()) {\n\n\t\t\t// The contents changed as a matter of Undo and the version reached matches the saved one\n\t\t\t// In this case we clear the dirty flag and emit a SAVED event to indicate this state.\n\t\t\tif (model.versionId === this.savedVersionId) {\n\t\t\t\tthis.trace('[file working copy] onModelContentChanged() - model content changed back to last saved version');\n\n\t\t\t\t// Clear flags\n\t\t\t\tconst wasDirty = this.dirty;\n\t\t\t\tthis.setDirty(false);\n\n\t\t\t\t// Emit revert event if we were dirty\n\t\t\t\tif (wasDirty) {\n\t\t\t\t\tthis._onDidRevert.fire();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise the content has changed and we signal this as becoming dirty\n\t\t\telse {\n\t\t\t\tthis.trace('[file working copy] onModelContentChanged() - model content changed and marked as dirty');\n\n\t\t\t\t// Mark as dirty\n\t\t\t\tthis.setDirty(true);\n\t\t\t}\n\t\t}\n\n\t\t// Emit as event\n\t\tthis._onDidChangeContent.fire();\n\t}\n\n\t//#endregion\n\n\t//#region Backup\n\n\tasync backup(token: CancellationToken): Promise<IWorkingCopyBackup> {\n\n\t\t// Fill in metadata if we are resolved\n\t\tlet meta: IFileWorkingCopyBackupMetaData | undefined = undefined;\n\t\tif (this.lastResolvedFileStat) {\n\t\t\tmeta = {\n\t\t\t\tmtime: this.lastResolvedFileStat.mtime,\n\t\t\t\tctime: this.lastResolvedFileStat.ctime,\n\t\t\t\tsize: this.lastResolvedFileStat.size,\n\t\t\t\tetag: this.lastResolvedFileStat.etag,\n\t\t\t\torphaned: this.inOrphanMode\n\t\t\t};\n\t\t}\n\n\t\t// Fill in content if we are resolved\n\t\tlet content: VSBufferReadableStream | undefined = undefined;\n\t\tif (this.isResolved()) {\n\t\t\tcontent = await raceCancellation(this.model.snapshot(token), token);\n\t\t}\n\n\t\treturn { meta, content };\n\t}\n\n\t//#endregion\n\n\t//#region Save\n\n\tprivate versionId = 0;\n\n\tprivate static readonly UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD = 500;\n\tprivate lastContentChangeFromUndoRedo: number | undefined = undefined;\n\n\tprivate readonly saveSequentializer = new TaskSequentializer();\n\n\tasync save(options: IFileWorkingCopySaveOptions = Object.create(null)): Promise<boolean> {\n\t\tif (!this.isResolved()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.isReadonly()) {\n\t\t\tthis.trace('[file working copy] save() - ignoring request for readonly resource');\n\n\t\t\treturn false; // if working copy is readonly we do not attempt to save at all\n\t\t}\n\n\t\tif (\n\t\t\t(this.hasState(FileWorkingCopyState.CONFLICT) || this.hasState(FileWorkingCopyState.ERROR)) &&\n\t\t\t(options.reason === SaveReason.AUTO || options.reason === SaveReason.FOCUS_CHANGE || options.reason === SaveReason.WINDOW_CHANGE)\n\t\t) {\n\t\t\tthis.trace('[file working copy] save() - ignoring auto save request for file working copy that is in conflict or error');\n\n\t\t\treturn false; // if working copy is in save conflict or error, do not save unless save reason is explicit\n\t\t}\n\n\t\t// Actually do save\n\t\tthis.trace('[file working copy] save() - enter');\n\t\tawait this.doSave(options);\n\t\tthis.trace('[file working copy] save() - exit');\n\n\t\treturn true;\n\t}\n\n\tprivate async doSave(options: IFileWorkingCopySaveOptions): Promise<void> {\n\t\tif (typeof options.reason !== 'number') {\n\t\t\toptions.reason = SaveReason.EXPLICIT;\n\t\t}\n\n\t\tlet versionId = this.versionId;\n\t\tthis.trace(`[file working copy] doSave(${versionId}) - enter with versionId ${versionId}`);\n\n\t\t// Lookup any running pending save for this versionId and return it if found\n\t\t//\n\t\t// Scenario: user invoked the save action multiple times quickly for the same contents\n\t\t//           while the save was not yet finished to disk\n\t\t//\n\t\tif (this.saveSequentializer.hasPending(versionId)) {\n\t\t\tthis.trace(`[file working copy] doSave(${versionId}) - exit - found a pending save for versionId ${versionId}`);\n\n\t\t\treturn this.saveSequentializer.pending;\n\t\t}\n\n\t\t// Return early if not dirty (unless forced)\n\t\t//\n\t\t// Scenario: user invoked save action even though the working copy is not dirty\n\t\tif (!options.force && !this.dirty) {\n\t\t\tthis.trace(`[file working copy] doSave(${versionId}) - exit - because not dirty and/or versionId is different (this.isDirty: ${this.dirty}, this.versionId: ${this.versionId})`);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Return if currently saving by storing this save request as the next save that should happen.\n\t\t// Never ever must 2 saves execute at the same time because this can lead to dirty writes and race conditions.\n\t\t//\n\t\t// Scenario A: auto save was triggered and is currently busy saving to disk. this takes long enough that another auto save\n\t\t//             kicks in.\n\t\t// Scenario B: save is very slow (e.g. network share) and the user manages to change the working copy and trigger another save\n\t\t//             while the first save has not returned yet.\n\t\t//\n\t\tif (this.saveSequentializer.hasPending()) {\n\t\t\tthis.trace(`[file working copy] doSave(${versionId}) - exit - because busy saving`);\n\n\t\t\t// Indicate to the save sequentializer that we want to\n\t\t\t// cancel the pending operation so that ours can run\n\t\t\t// before the pending one finishes.\n\t\t\t// Currently this will try to cancel pending save\n\t\t\t// participants and pending snapshots from the\n\t\t\t// save operation, but not the actual save which does\n\t\t\t// not support cancellation yet.\n\t\t\tthis.saveSequentializer.cancelPending();\n\n\t\t\t// Register this as the next upcoming save and return\n\t\t\treturn this.saveSequentializer.setNext(() => this.doSave(options));\n\t\t}\n\n\t\t// Push all edit operations to the undo stack so that the user has a chance to\n\t\t// Ctrl+Z back to the saved version.\n\t\tif (this.isResolved()) {\n\t\t\tthis.model.pushStackElement();\n\t\t}\n\n\t\tconst saveCancellation = new CancellationTokenSource();\n\n\t\treturn this.saveSequentializer.setPending(versionId, (async () => {\n\n\t\t\t// A save participant can still change the working copy now\n\t\t\t// and since we are so close to saving we do not want to trigger\n\t\t\t// another auto save or similar, so we block this\n\t\t\t// In addition we update our version right after in case it changed\n\t\t\t// because of a working copy change\n\t\t\t// Save participants can also be skipped through API.\n\t\t\tif (this.isResolved() && !options.skipSaveParticipants && this.isTextFileModel(this.model)) {\n\t\t\t\ttry {\n\n\t\t\t\t\t// Measure the time it took from the last undo/redo operation to this save. If this\n\t\t\t\t\t// time is below `UNDO_REDO_SAVE_PARTICIPANTS_THROTTLE_THRESHOLD`, we make sure to\n\t\t\t\t\t// delay the save participant for the remaining time if the reason is auto save.\n\t\t\t\t\t//\n\t\t\t\t\t// This fixes the following issue:\n\t\t\t\t\t// - the user has configured auto save with delay of 100ms or shorter\n\t\t\t\t\t// - the user has a save participant enabled that modifies the file on each save\n\t\t\t\t\t// - the user types into the file and the file gets saved\n\t\t\t\t\t// - the user triggers undo operation\n\t\t\t\t\t// - this will undo the save participant change but trigger the save participant right after\n\t\t\t\t\t// - the user has no chance to undo over the save participant\n\t\t\t\t\t//\n\t\t\t\t\t// Reported as: https://github.com/microsoft/vscode/issues/102542\n\t\t\t\t\tif (options.reason === SaveReason.AUTO && typeof this.lastContentChangeFromUndoRedo === 'number') {\n\t\t\t\t\t\tconst timeFromUndoRedoToSave = Date.now() - this.lastContentChangeFromUndoRedo;\n\t\t\t\t\t\tif (timeFromUndoRedoToSave < FileWorkingCopy.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD) {\n\t\t\t\t\t\t\tawait timeout(FileWorkingCopy.UNDO_REDO_SAVE_PARTICIPANTS_AUTO_SAVE_THROTTLE_THRESHOLD - timeFromUndoRedoToSave);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Run save participants unless save was cancelled meanwhile\n\t\t\t\t\tif (!saveCancellation.token.isCancellationRequested) {\n\t\t\t\t\t\tawait this.textFileService.files.runSaveParticipants(this.model, { reason: options.reason ?? SaveReason.EXPLICIT }, saveCancellation.token);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(`[file working copy] runSaveParticipants(${versionId}) - resulted in an error: ${error.toString()}`, this.resource.toString(true), this.typeId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// It is possible that a subsequent save is cancelling this\n\t\t\t// running save. As such we return early when we detect that.\n\t\t\tif (saveCancellation.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We have to protect against being disposed at this point. It could be that the save() operation\n\t\t\t// was triggerd followed by a dispose() operation right after without waiting. Typically we cannot\n\t\t\t// be disposed if we are dirty, but if we are not dirty, save() and dispose() can still be triggered\n\t\t\t// one after the other without waiting for the save() to complete. If we are disposed(), we risk\n\t\t\t// saving contents to disk that are stale (see https://github.com/microsoft/vscode/issues/50942).\n\t\t\t// To fix this issue, we will not store the contents to disk when we got disposed.\n\t\t\tif (this.isDisposed()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We require a resolved working copy from this point on, since we are about to write data to disk.\n\t\t\tif (!this.isResolved()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// update versionId with its new value (if pre-save changes happened)\n\t\t\tversionId = this.versionId;\n\n\t\t\t// Clear error flag since we are trying to save again\n\t\t\tthis.inErrorMode = false;\n\n\t\t\t// Save to Disk. We mark the save operation as currently pending with\n\t\t\t// the latest versionId because it might have changed from a save\n\t\t\t// participant triggering\n\t\t\tthis.trace(`[file working copy] doSave(${versionId}) - before write()`);\n\t\t\tconst lastResolvedFileStat = assertIsDefined(this.lastResolvedFileStat);\n\t\t\tconst resolvedFileWorkingCopy = this;\n\t\t\treturn this.saveSequentializer.setPending(versionId, (async () => {\n\t\t\t\ttry {\n\n\t\t\t\t\t// Snapshot working copy model contents\n\t\t\t\t\tconst snapshot = await raceCancellation(resolvedFileWorkingCopy.model.snapshot(saveCancellation.token), saveCancellation.token);\n\n\t\t\t\t\t// It is possible that a subsequent save is cancelling this\n\t\t\t\t\t// running save. As such we return early when we detect that\n\t\t\t\t\t// However, we do not pass the token into the file service\n\t\t\t\t\t// because that is an atomic operation currently without\n\t\t\t\t\t// cancellation support, so we dispose the cancellation if\n\t\t\t\t\t// it was not cancelled yet.\n\t\t\t\t\tif (saveCancellation.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsaveCancellation.dispose();\n\t\t\t\t\t}\n\n\t\t\t\t\tconst writeFileOptions: IWriteFileOptions = {\n\t\t\t\t\t\tmtime: lastResolvedFileStat.mtime,\n\t\t\t\t\t\tetag: (options.ignoreModifiedSince || !this.filesConfigurationService.preventSaveConflicts(lastResolvedFileStat.resource)) ? ETAG_DISABLED : lastResolvedFileStat.etag,\n\t\t\t\t\t\tunlock: options.writeUnlock\n\t\t\t\t\t};\n\n\t\t\t\t\t// Write them to disk\n\t\t\t\t\tlet stat: IFileStatWithMetadata;\n\t\t\t\t\tif (options?.writeElevated && this.elevatedFileService.isSupported(lastResolvedFileStat.resource)) {\n\t\t\t\t\t\tstat = await this.elevatedFileService.writeFileElevated(lastResolvedFileStat.resource, assertIsDefined(snapshot), writeFileOptions);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstat = await this.fileService.writeFile(lastResolvedFileStat.resource, assertIsDefined(snapshot), writeFileOptions);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.handleSaveSuccess(stat, versionId, options);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.handleSaveError(error, versionId, options);\n\t\t\t\t}\n\t\t\t})(), () => saveCancellation.cancel());\n\t\t})(), () => saveCancellation.cancel());\n\t}\n\n\tprivate handleSaveSuccess(stat: IFileStatWithMetadata, versionId: number, options: IFileWorkingCopySaveOptions): void {\n\n\t\t// Updated resolved stat with updated stat\n\t\tthis.updateLastResolvedFileStat(stat);\n\n\t\t// Update dirty state unless working copy has changed meanwhile\n\t\tif (versionId === this.versionId) {\n\t\t\tthis.trace(`[file working copy] handleSaveSuccess(${versionId}) - setting dirty to false because versionId did not change`);\n\t\t\tthis.setDirty(false);\n\t\t} else {\n\t\t\tthis.trace(`[file working copy] handleSaveSuccess(${versionId}) - not setting dirty to false because versionId did change meanwhile`);\n\t\t}\n\n\t\t// Update orphan state given save was successful\n\t\tthis.setOrphaned(false);\n\n\t\t// Emit Save Event\n\t\tthis._onDidSave.fire(options.reason ?? SaveReason.EXPLICIT);\n\t}\n\n\tprivate handleSaveError(error: Error, versionId: number, options: IFileWorkingCopySaveOptions): void {\n\t\tthis.logService.error(`[file working copy] handleSaveError(${versionId}) - exit - resulted in a save error: ${error.toString()}`, this.resource.toString(true), this.typeId);\n\n\t\t// Return early if the save() call was made asking to\n\t\t// handle the save error itself.\n\t\tif (options.ignoreErrorHandler) {\n\t\t\tthrow error;\n\t\t}\n\n\t\t// In any case of an error, we mark the working copy as dirty to prevent data loss\n\t\t// It could be possible that the write corrupted the file on disk (e.g. when\n\t\t// an error happened after truncating the file) and as such we want to preserve\n\t\t// the working copy contents to prevent data loss.\n\t\tthis.setDirty(true);\n\n\t\t// Flag as error state\n\t\tthis.inErrorMode = true;\n\n\t\t// Look out for a save conflict\n\t\tif ((error as FileOperationError).fileOperationResult === FileOperationResult.FILE_MODIFIED_SINCE) {\n\t\t\tthis.inConflictMode = true;\n\t\t}\n\n\t\t// Delegate to save error handler\n\t\tif (this.isTextFileModel(this.model)) {\n\t\t\tthis.textFileService.files.saveErrorHandler.onSaveError(error, this.model);\n\t\t} else {\n\t\t\tthis.doHandleSaveError(error);\n\t\t}\n\n\t\t// Emit as event\n\t\tthis._onDidSaveError.fire();\n\t}\n\n\tprivate doHandleSaveError(error: Error): void {\n\t\tconst fileOperationError = error as FileOperationError;\n\t\tconst primaryActions: IAction[] = [];\n\n\t\tlet message: string;\n\n\t\t// Dirty write prevention\n\t\tif (fileOperationError.fileOperationResult === FileOperationResult.FILE_MODIFIED_SINCE) {\n\t\t\tmessage = localize('staleSaveError', \"Failed to save '{0}': The content of the file is newer. Do you want to overwrite the file with your changes?\", this.name);\n\n\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.overwrite', label: localize('overwrite', \"Overwrite\"), run: () => this.save({ ignoreModifiedSince: true }) }));\n\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.revert', label: localize('discard', \"Discard\"), run: () => this.revert() }));\n\t\t}\n\n\t\t// Any other save error\n\t\telse {\n\t\t\tconst isWriteLocked = fileOperationError.fileOperationResult === FileOperationResult.FILE_WRITE_LOCKED;\n\t\t\tconst triedToUnlock = isWriteLocked && fileOperationError.options?.unlock;\n\t\t\tconst isPermissionDenied = fileOperationError.fileOperationResult === FileOperationResult.FILE_PERMISSION_DENIED;\n\t\t\tconst canSaveElevated = this.elevatedFileService.isSupported(this.resource);\n\n\t\t\t// Save Elevated\n\t\t\tif (canSaveElevated && (isPermissionDenied || triedToUnlock)) {\n\t\t\t\tprimaryActions.push(toAction({\n\t\t\t\t\tid: 'fileWorkingCopy.saveElevated',\n\t\t\t\t\tlabel: triedToUnlock ?\n\t\t\t\t\t\tisWindows ? localize('overwriteElevated', \"Overwrite as Admin...\") : localize('overwriteElevatedSudo', \"Overwrite as Sudo...\") :\n\t\t\t\t\t\tisWindows ? localize('saveElevated', \"Retry as Admin...\") : localize('saveElevatedSudo', \"Retry as Sudo...\"),\n\t\t\t\t\trun: () => {\n\t\t\t\t\t\tthis.save({ writeElevated: true, writeUnlock: triedToUnlock, reason: SaveReason.EXPLICIT });\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Unlock\n\t\t\telse if (isWriteLocked) {\n\t\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.unlock', label: localize('overwrite', \"Overwrite\"), run: () => this.save({ writeUnlock: true, reason: SaveReason.EXPLICIT }) }));\n\t\t\t}\n\n\t\t\t// Retry\n\t\t\telse {\n\t\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.retry', label: localize('retry', \"Retry\"), run: () => this.save({ reason: SaveReason.EXPLICIT }) }));\n\t\t\t}\n\n\t\t\t// Save As\n\t\t\tprimaryActions.push(toAction({\n\t\t\t\tid: 'fileWorkingCopy.saveAs',\n\t\t\t\tlabel: localize('saveAs', \"Save As...\"),\n\t\t\t\trun: () => {\n\t\t\t\t\tconst editor = this.workingCopyEditorService.findEditor(this);\n\t\t\t\t\tif (editor) {\n\t\t\t\t\t\tthis.editorService.save(editor, { saveAs: true, reason: SaveReason.EXPLICIT });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\t// Discard\n\t\t\tprimaryActions.push(toAction({ id: 'fileWorkingCopy.revert', label: localize('discard', \"Discard\"), run: () => this.revert() }));\n\n\t\t\t// Message\n\t\t\tif (isWriteLocked) {\n\t\t\t\tif (triedToUnlock && canSaveElevated) {\n\t\t\t\t\tmessage = isWindows ?\n\t\t\t\t\t\tlocalize('readonlySaveErrorAdmin', \"Failed to save '{0}': File is read-only. Select 'Overwrite as Admin' to retry as administrator.\", this.name) :\n\t\t\t\t\t\tlocalize('readonlySaveErrorSudo', \"Failed to save '{0}': File is read-only. Select 'Overwrite as Sudo' to retry as superuser.\", this.name);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = localize('readonlySaveError', \"Failed to save '{0}': File is read-only. Select 'Overwrite' to attempt to make it writeable.\", this.name);\n\t\t\t\t}\n\t\t\t} else if (canSaveElevated && isPermissionDenied) {\n\t\t\t\tmessage = isWindows ?\n\t\t\t\t\tlocalize('permissionDeniedSaveError', \"Failed to save '{0}': Insufficient permissions. Select 'Retry as Admin' to retry as administrator.\", this.name) :\n\t\t\t\t\tlocalize('permissionDeniedSaveErrorSudo', \"Failed to save '{0}': Insufficient permissions. Select 'Retry as Sudo' to retry as superuser.\", this.name);\n\t\t\t} else {\n\t\t\t\tmessage = localize({ key: 'genericSaveError', comment: ['{0} is the resource that failed to save and {1} the error message'] }, \"Failed to save '{0}': {1}\", this.name, toErrorMessage(error, false));\n\t\t\t}\n\t\t}\n\n\t\t// Show to the user as notification\n\t\tconst handle = this.notificationService.notify({ id: `${hash(this.resource.toString())}`, severity: Severity.Error, message, actions: { primary: primaryActions } });\n\n\t\t// Remove automatically when we get saved/reverted\n\t\tconst listener = Event.once(Event.any(this.onDidSave, this.onDidRevert))(() => handle.close());\n\t\tEvent.once(handle.onDidClose)(() => listener.dispose());\n\t}\n\n\tprivate updateLastResolvedFileStat(newFileStat: IFileStatWithMetadata): void {\n\n\t\t// First resolve - just take\n\t\tif (!this.lastResolvedFileStat) {\n\t\t\tthis.lastResolvedFileStat = newFileStat;\n\t\t}\n\n\t\t// Subsequent resolve - make sure that we only assign it if the mtime\n\t\t// is equal or has advanced.\n\t\t// This prevents race conditions from resolving and saving. If a save\n\t\t// comes in late after a revert was called, the mtime could be out of\n\t\t// sync.\n\t\telse if (this.lastResolvedFileStat.mtime <= newFileStat.mtime) {\n\t\t\tthis.lastResolvedFileStat = newFileStat;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Revert\n\n\tasync revert(options?: IRevertOptions): Promise<void> {\n\t\tif (!this.isResolved() || (!this.dirty && !options?.force)) {\n\t\t\treturn; // ignore if not resolved or not dirty and not enforced\n\t\t}\n\n\t\t// Unset flags\n\t\tconst wasDirty = this.dirty;\n\t\tconst undoSetDirty = this.doSetDirty(false);\n\n\t\t// Force read from disk unless reverting soft\n\t\tconst softUndo = options?.soft;\n\t\tif (!softUndo) {\n\t\t\ttry {\n\t\t\t\tawait this.resolve({ forceReadFromFile: true });\n\t\t\t} catch (error) {\n\n\t\t\t\t// FileNotFound means the file got deleted meanwhile, so ignore it\n\t\t\t\tif ((error as FileOperationError).fileOperationResult !== FileOperationResult.FILE_NOT_FOUND) {\n\n\t\t\t\t\t// Set flags back to previous values, we are still dirty if revert failed\n\t\t\t\t\tundoSetDirty();\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Emit file change event\n\t\tthis._onDidRevert.fire();\n\n\t\t// Emit dirty change event\n\t\tif (wasDirty) {\n\t\t\tthis._onDidChangeDirty.fire();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region State\n\n\tprivate inConflictMode = false;\n\tprivate inErrorMode = false;\n\n\thasState(state: FileWorkingCopyState): boolean {\n\t\tswitch (state) {\n\t\t\tcase FileWorkingCopyState.CONFLICT:\n\t\t\t\treturn this.inConflictMode;\n\t\t\tcase FileWorkingCopyState.DIRTY:\n\t\t\t\treturn this.dirty;\n\t\t\tcase FileWorkingCopyState.ERROR:\n\t\t\t\treturn this.inErrorMode;\n\t\t\tcase FileWorkingCopyState.ORPHAN:\n\t\t\t\treturn this.inOrphanMode;\n\t\t\tcase FileWorkingCopyState.PENDING_SAVE:\n\t\t\t\treturn this.saveSequentializer.hasPending();\n\t\t\tcase FileWorkingCopyState.SAVED:\n\t\t\t\treturn !this.dirty;\n\t\t}\n\t}\n\n\tjoinState(state: FileWorkingCopyState.PENDING_SAVE): Promise<void> {\n\t\treturn this.saveSequentializer.pending ?? Promise.resolve();\n\t}\n\n\t//#endregion\n\n\t//#region Utilities\n\n\tisResolved(): this is IResolvedFileWorkingCopy<T> {\n\t\treturn !!this.model;\n\t}\n\n\tisReadonly(): boolean {\n\t\treturn this.fileService.hasCapability(this.resource, FileSystemProviderCapabilities.Readonly);\n\t}\n\n\tprivate trace(msg: string): void {\n\t\tthis.logService.trace(msg, this.resource.toString(true), this.typeId);\n\t}\n\n\t//#endregion\n\n\t//#region Dispose\n\n\tprivate disposed = false;\n\n\tisDisposed(): boolean {\n\t\treturn this.disposed;\n\t}\n\n\toverride dispose(): void {\n\t\tthis.trace('[file working copy] dispose()');\n\n\t\t// State\n\t\tthis.disposed = true;\n\t\tthis.inConflictMode = false;\n\t\tthis.inOrphanMode = false;\n\t\tthis.inErrorMode = false;\n\n\t\t// Event\n\t\tthis._onWillDispose.fire();\n\n\t\tsuper.dispose();\n\t}\n\n\t//#endregion\n\n\t//#region Remainders of text file model world (TODO@bpasero callers have to be handled in a generic way)\n\n\tprivate isTextFileModel(model: unknown): model is ITextFileEditorModel {\n\t\tconst textFileModel = this.textFileService.files.get(this.resource);\n\n\t\treturn !!(textFileModel && this.model && (textFileModel as unknown) === (this.model as unknown));\n\t}\n\n\t//#endregion\n}\n"]}