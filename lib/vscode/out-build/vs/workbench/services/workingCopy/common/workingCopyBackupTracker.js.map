{"version":3,"file":"workingCopyBackupTracker.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/workingCopy/common/workingCopyBackupTracker.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { Disposable, IDisposable, dispose, toDisposable } from 'vs/base/common/lifecycle';\nimport { IWorkingCopyService } from 'vs/workbench/services/workingCopy/common/workingCopyService';\nimport { IWorkingCopy, IWorkingCopyIdentifier, WorkingCopyCapabilities } from 'vs/workbench/services/workingCopy/common/workingCopy';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { ShutdownReason, ILifecycleService, LifecyclePhase } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { AutoSaveMode, IFilesConfigurationService } from 'vs/workbench/services/filesConfiguration/common/filesConfigurationService';\nimport { IWorkingCopyEditorHandler, IWorkingCopyEditorService } from 'vs/workbench/services/workingCopy/common/workingCopyEditorService';\nimport { Promises } from 'vs/base/common/async';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IEditorInput } from 'vs/workbench/common/editor';\nimport { EditorOverride } from 'vs/platform/editor/common/editor';\n\n/**\n * The working copy backup tracker deals with:\n * - restoring backups that exist\n * - creating backups for dirty working copies\n * - deleting backups for saved working copies\n * - handling backups on shutdown\n */\nexport abstract class WorkingCopyBackupTracker extends Disposable {\n\n\tconstructor(\n\t\tprotected readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\tprotected readonly workingCopyService: IWorkingCopyService,\n\t\tprotected readonly logService: ILogService,\n\t\tprivate readonly lifecycleService: ILifecycleService,\n\t\tprotected readonly filesConfigurationService: IFilesConfigurationService,\n\t\tprivate readonly workingCopyEditorService: IWorkingCopyEditorService,\n\t\tprotected readonly editorService: IEditorService\n\t) {\n\t\tsuper();\n\n\t\t// Fill in initial dirty working copies\n\t\tthis.workingCopyService.dirtyWorkingCopies.forEach(workingCopy => this.onDidRegister(workingCopy));\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Working Copy events\n\t\tthis._register(this.workingCopyService.onDidRegister(workingCopy => this.onDidRegister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidUnregister(workingCopy => this.onDidUnregister(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.onDidChangeDirty(workingCopy)));\n\t\tthis._register(this.workingCopyService.onDidChangeContent(workingCopy => this.onDidChangeContent(workingCopy)));\n\n\t\t// Lifecycle (handled in subclasses)\n\t\tthis.lifecycleService.onBeforeShutdown(event => event.veto(this.onBeforeShutdown(event.reason), 'veto.backups'));\n\n\t\t// Once a handler registers, restore backups\n\t\tthis._register(this.workingCopyEditorService.onDidRegisterHandler(handler => this.restoreBackups(handler)));\n\t}\n\n\n\t//#region Backup Creator\n\n\t// A map from working copy to a version ID we compute on each content\n\t// change. This version ID allows to e.g. ask if a backup for a specific\n\t// content has been made before closing.\n\tprivate readonly mapWorkingCopyToContentVersion = new Map<IWorkingCopy, number>();\n\n\t// A map of scheduled pending backups for working copies\n\tprotected readonly pendingBackups = new Map<IWorkingCopy, IDisposable>();\n\n\t// Delay creation of backups when content changes to avoid too much\n\t// load on the backup service when the user is typing into the editor\n\t// Since we always schedule a backup, even when auto save is on, we\n\t// have different scheduling delays based on auto save. This helps to\n\t// avoid a (not critical but also not really wanted) race between saving\n\t// (after 1s per default) and making a backup of the working copy.\n\tprivate static readonly BACKUP_SCHEDULE_DELAYS = {\n\t\t[AutoSaveMode.OFF]: 1000,\n\t\t[AutoSaveMode.ON_FOCUS_CHANGE]: 1000,\n\t\t[AutoSaveMode.ON_WINDOW_CHANGE]: 1000,\n\t\t[AutoSaveMode.AFTER_SHORT_DELAY]: 2000, // explicitly higher to prevent races\n\t\t[AutoSaveMode.AFTER_LONG_DELAY]: 1000\n\t};\n\n\tprivate onDidRegister(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidUnregister(workingCopy: IWorkingCopy): void {\n\n\t\t// Remove from content version map\n\t\tthis.mapWorkingCopyToContentVersion.delete(workingCopy);\n\n\t\t// Discard backup\n\t\tthis.discardBackup(workingCopy);\n\t}\n\n\tprivate onDidChangeDirty(workingCopy: IWorkingCopy): void {\n\t\tif (workingCopy.isDirty()) {\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t} else {\n\t\t\tthis.discardBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate onDidChangeContent(workingCopy: IWorkingCopy): void {\n\n\t\t// Increment content version ID\n\t\tconst contentVersionId = this.getContentVersion(workingCopy);\n\t\tthis.mapWorkingCopyToContentVersion.set(workingCopy, contentVersionId + 1);\n\n\t\t// Schedule backup if dirty\n\t\tif (workingCopy.isDirty()) {\n\t\t\t// this listener will make sure that the backup is\n\t\t\t// pushed out for as long as the user is still changing\n\t\t\t// the content of the working copy.\n\t\t\tthis.scheduleBackup(workingCopy);\n\t\t}\n\t}\n\n\tprivate scheduleBackup(workingCopy: IWorkingCopy): void {\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackup(workingCopy);\n\n\t\tthis.logService.trace(`[backup tracker] scheduling backup`, workingCopy.resource.toString(true), workingCopy.typeId);\n\n\t\t// Schedule new backup\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst handle = setTimeout(async () => {\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Backup if dirty\n\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\tthis.logService.trace(`[backup tracker] creating backup`, workingCopy.resource.toString(true), workingCopy.typeId);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst backup = await workingCopy.backup(cts.token);\n\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (workingCopy.isDirty()) {\n\t\t\t\t\t\tthis.logService.trace(`[backup tracker] storing backup`, workingCopy.resource.toString(true), workingCopy.typeId);\n\n\t\t\t\t\t\tawait this.workingCopyBackupService.backup(workingCopy, backup.content, this.getContentVersion(workingCopy), backup.meta, cts.token);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Clear disposable\n\t\t\tthis.pendingBackups.delete(workingCopy);\n\n\t\t}, this.getBackupScheduleDelay(workingCopy));\n\n\t\t// Keep in map for disposal as needed\n\t\tthis.pendingBackups.set(workingCopy, toDisposable(() => {\n\t\t\tthis.logService.trace(`[backup tracker] clearing pending backup`, workingCopy.resource.toString(true), workingCopy.typeId);\n\n\t\t\tcts.dispose(true);\n\t\t\tclearTimeout(handle);\n\t\t}));\n\t}\n\n\tprotected getBackupScheduleDelay(workingCopy: IWorkingCopy): number {\n\t\tlet autoSaveMode = this.filesConfigurationService.getAutoSaveMode();\n\t\tif (workingCopy.capabilities & WorkingCopyCapabilities.Untitled) {\n\t\t\tautoSaveMode = AutoSaveMode.OFF; // auto-save is never on for untitled working copies\n\t\t}\n\n\t\treturn WorkingCopyBackupTracker.BACKUP_SCHEDULE_DELAYS[autoSaveMode];\n\t}\n\n\tprotected getContentVersion(workingCopy: IWorkingCopy): number {\n\t\treturn this.mapWorkingCopyToContentVersion.get(workingCopy) || 0;\n\t}\n\n\tprivate discardBackup(workingCopy: IWorkingCopy): void {\n\t\tthis.logService.trace(`[backup tracker] discarding backup`, workingCopy.resource.toString(true), workingCopy.typeId);\n\n\t\t// Clear any running backup operation\n\t\tthis.cancelBackup(workingCopy);\n\n\t\t// Forward to working copy backup service\n\t\tthis.workingCopyBackupService.discardBackup(workingCopy);\n\t}\n\n\tprivate cancelBackup(workingCopy: IWorkingCopy): void {\n\t\tdispose(this.pendingBackups.get(workingCopy));\n\t\tthis.pendingBackups.delete(workingCopy);\n\t}\n\n\tprotected abstract onBeforeShutdown(reason: ShutdownReason): boolean | Promise<boolean>;\n\n\t//#endregion\n\n\n\t//#region Backup Restorer\n\n\tprotected readonly unrestoredBackups = new Set<IWorkingCopyIdentifier>();\n\tprivate readonly whenReady = this.resolveBackupsToRestore();\n\n\tprivate async resolveBackupsToRestore(): Promise<void> {\n\n\t\t// Wait for resolving backups until we are restored to reduce startup pressure\n\t\tawait this.lifecycleService.when(LifecyclePhase.Restored);\n\n\t\t// Remember each backup that needs to restore\n\t\tfor (const backup of await this.workingCopyBackupService.getBackups()) {\n\t\t\tthis.unrestoredBackups.add(backup);\n\t\t}\n\t}\n\n\tprotected async restoreBackups(handler: IWorkingCopyEditorHandler): Promise<void> {\n\n\t\t// Wait for backups to be resolved\n\t\tawait this.whenReady;\n\n\t\t// Figure out already opened editors for backups vs\n\t\t// non-opened.\n\t\tconst openedEditorsForBackups: IEditorInput[] = [];\n\t\tconst nonOpenedEditorsForBackups: IEditorInput[] = [];\n\n\t\t// Ensure each backup that can be handled has an\n\t\t// associated editor.\n\t\tconst restoredBackups = new Set<IWorkingCopyIdentifier>();\n\t\tfor (const unrestoredBackup of this.unrestoredBackups) {\n\t\t\tconst canHandleUnrestoredBackup = handler.handles(unrestoredBackup);\n\t\t\tif (!canHandleUnrestoredBackup) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Collect already opened editors for backup\n\t\t\tlet hasOpenedEditorForBackup = false;\n\t\t\tfor (const editor of this.editorService.editors) {\n\t\t\t\tconst isUnrestoredBackupOpened = handler.isOpen(unrestoredBackup, editor);\n\t\t\t\tif (isUnrestoredBackupOpened) {\n\t\t\t\t\topenedEditorsForBackups.push(editor);\n\t\t\t\t\thasOpenedEditorForBackup = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, make sure to create at least one editor\n\t\t\t// for the backup to show\n\t\t\tif (!hasOpenedEditorForBackup) {\n\t\t\t\tnonOpenedEditorsForBackups.push(handler.createEditor(unrestoredBackup));\n\t\t\t}\n\n\t\t\t// Remember as (potentially) restored\n\t\t\trestoredBackups.add(unrestoredBackup);\n\t\t}\n\n\t\t// Ensure editors are opened for each backup without editor\n\t\t// in the background without stealing focus\n\t\tif (nonOpenedEditorsForBackups.length > 0) {\n\t\t\tawait this.editorService.openEditors(nonOpenedEditorsForBackups.map(nonOpenedEditorForBackup => ({\n\t\t\t\teditor: nonOpenedEditorForBackup,\n\t\t\t\toptions: {\n\t\t\t\t\tpinned: true,\n\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\tinactive: true,\n\t\t\t\t\toverride: EditorOverride.DISABLED\n\t\t\t\t}\n\t\t\t})));\n\n\t\t\topenedEditorsForBackups.push(...nonOpenedEditorsForBackups);\n\t\t}\n\n\t\t// Then, resolve each editor to make sure the working copy\n\t\t// is loaded and the dirty editor appears properly\n\t\tawait Promises.settled(openedEditorsForBackups.map(openedEditorsForBackup => openedEditorsForBackup.resolve()));\n\n\t\t// Finally, remove all handled backups from the list\n\t\tfor (const restoredBackup of restoredBackups) {\n\t\t\tthis.unrestoredBackups.delete(restoredBackup);\n\t\t}\n\t}\n\n\t//#endregion\n}\n"]}