{"version":3,"file":"legacyBackupRestorer.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/workingCopy/common/legacyBackupRestorer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkbenchContribution } from 'vs/workbench/common/contributions';\nimport { IWorkingCopyBackupService } from 'vs/workbench/services/workingCopy/common/workingCopyBackup';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IResourceEditorInput } from 'vs/platform/editor/common/editor';\nimport { Schemas } from 'vs/base/common/network';\nimport { ILifecycleService, LifecyclePhase } from 'vs/workbench/services/lifecycle/common/lifecycle';\nimport { IUntitledTextResourceEditorInput, IEditorInput, IEditorInputFactoryRegistry, EditorExtensions, IEditorInputWithOptions } from 'vs/workbench/common/editor';\nimport { toLocalResource, isEqual } from 'vs/base/common/resources';\nimport { IWorkbenchEnvironmentService } from 'vs/workbench/services/environment/common/environmentService';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { IPathService } from 'vs/workbench/services/path/common/pathService';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { Promises } from 'vs/base/common/async';\nimport { IWorkingCopyIdentifier } from 'vs/workbench/services/workingCopy/common/workingCopy';\n\n/**\n * @deprecated TODO@bpasero remove me once all backups are handled properly\n */\nexport class LegacyWorkingCopyBackupRestorer implements IWorkbenchContribution {\n\n\tprivate static readonly UNTITLED_REGEX = /Untitled-\\d+/;\n\n\tprivate readonly editorInputFactories = Registry.as<IEditorInputFactoryRegistry>(EditorExtensions.EditorInputFactories);\n\n\tconstructor(\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IWorkingCopyBackupService private readonly workingCopyBackupService: IWorkingCopyBackupService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@IWorkbenchEnvironmentService private readonly environmentService: IWorkbenchEnvironmentService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IPathService private readonly pathService: IPathService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tthis.restoreLegacyBackups();\n\t}\n\n\tprivate restoreLegacyBackups(): void {\n\t\tthis.lifecycleService.when(LifecyclePhase.Restored).then(() => this.doRestoreLegacyBackups());\n\t}\n\n\tprotected async doRestoreLegacyBackups(): Promise<void> {\n\n\t\t// Resolve all backup resources that exist for this window\n\t\t// that have not yet adopted the working copy editor handler\n\t\t// - any working copy without `typeId`\n\t\t// - not `search-edior:/` (supports migration to typeId)\n\t\tconst backups = (await this.workingCopyBackupService.getBackups())\n\t\t\t.filter(backup => backup.typeId.length === 0)\n\t\t\t.filter(backup => backup.resource.scheme !== 'search-editor');\n\n\t\t// Trigger `resolve` in each opened editor that can be found\n\t\t// for the given resource and keep track of backups that are\n\t\t// not opened.\n\t\tconst unresolvedBackups = await this.resolveOpenedBackupEditors(backups);\n\n\t\t// For remaining unresolved backups, explicitly open an editor\n\t\tif (unresolvedBackups.length > 0) {\n\t\t\ttry {\n\t\t\t\tawait this.openEditors(unresolvedBackups);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.error(error);\n\t\t\t}\n\n\t\t\t// Finally trigger `resolve` in the newly opened editors\n\t\t\tawait this.resolveOpenedBackupEditors(unresolvedBackups);\n\t\t}\n\t}\n\n\tprivate async resolveOpenedBackupEditors(backups: readonly IWorkingCopyIdentifier[]): Promise<IWorkingCopyIdentifier[]> {\n\t\tconst unresolvedBackups: IWorkingCopyIdentifier[] = [];\n\n\t\tawait Promises.settled(backups.map(async backup => {\n\t\t\tconst openedEditor = this.findOpenedEditor(backup);\n\t\t\tif (openedEditor) {\n\t\t\t\ttry {\n\t\t\t\t\tawait openedEditor.resolve();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tunresolvedBackups.push(backup); // ignore error and remember as unresolved\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunresolvedBackups.push(backup);\n\t\t\t}\n\t\t}));\n\n\t\treturn unresolvedBackups;\n\t}\n\n\tprivate findOpenedEditor(backup: IWorkingCopyIdentifier): IEditorInput | undefined {\n\t\tfor (const editor of this.editorService.editors) {\n\t\t\tconst customFactory = this.editorInputFactories.getCustomEditorInputFactory(backup.resource.scheme);\n\t\t\tif (customFactory?.canResolveBackup(editor, backup.resource) || isEqual(editor.resource, backup.resource)) {\n\t\t\t\treturn editor;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate async openEditors(backups: IWorkingCopyIdentifier[]): Promise<void> {\n\t\tconst hasOpenedEditors = this.editorService.visibleEditors.length > 0;\n\t\tconst editors = await Promises.settled(backups.map((backup, index) => this.resolveEditor(backup, index, hasOpenedEditors)));\n\n\t\tawait this.editorService.openEditors(editors);\n\t}\n\n\tprivate async resolveEditor(backup: IWorkingCopyIdentifier, index: number, hasOpenedEditors: boolean): Promise<IResourceEditorInput | IUntitledTextResourceEditorInput | IEditorInputWithOptions> {\n\n\t\t// Set editor as `inactive` if we have other editors\n\t\tconst options = { pinned: true, preserveFocus: true, inactive: index > 0 || hasOpenedEditors };\n\n\t\t// This is a (weak) strategy to find out if the untitled input had\n\t\t// an associated file path or not by just looking at the path. and\n\t\t// if so, we must ensure to restore the local resource it had.\n\t\tif (backup.resource.scheme === Schemas.untitled && !LegacyWorkingCopyBackupRestorer.UNTITLED_REGEX.test(backup.resource.path)) {\n\t\t\treturn { resource: toLocalResource(backup.resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme), options, forceUntitled: true };\n\t\t}\n\n\t\t// Handle custom editors by asking the custom editor input factory\n\t\t// to create the input.\n\t\tconst customFactory = this.editorInputFactories.getCustomEditorInputFactory(backup.resource.scheme);\n\t\tif (customFactory) {\n\t\t\tconst editor = await customFactory.createCustomEditorInput(backup.resource, this.instantiationService);\n\n\t\t\treturn { editor, options };\n\t\t}\n\n\t\t// Finally return with a simple resource based input\n\t\treturn { resource: backup.resource, options };\n\t}\n}\n"]}