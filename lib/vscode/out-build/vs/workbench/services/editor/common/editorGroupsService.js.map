{"version":3,"file":"editorGroupsService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/editor/common/editorGroupsService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAYnF,QAAA,oBAAoB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAuB,qBAAqB,CAAC,CAAC;IAEjG,IAAkB,cAKjB;IALD,WAAkB,cAAc;QAC/B,+CAAE,CAAA;QACF,mDAAI,CAAA;QACJ,mDAAI,CAAA;QACJ,qDAAK,CAAA;IACN,CAAC,EALiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAK/B;IAED,IAAkB,gBAGjB;IAHD,WAAkB,gBAAgB;QACjC,mEAAU,CAAA;QACV,+DAAQ,CAAA;IACT,CAAC,EAHiB,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAGjC;IAED,IAAkB,aAKjB;IALD,WAAkB,aAAa;QAC9B,mDAAK,CAAA;QACL,iDAAI,CAAA;QACJ,iDAAI,CAAA;QACJ,yDAAQ,CAAA;IACT,CAAC,EALiB,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAK9B;IAOD,IAAkB,iBAkBjB;IAlBD,WAAkB,iBAAiB;QAElC;;;WAGG;QACH,+EAAe,CAAA;QAEf;;WAEG;QACH,yDAAI,CAAA;QAEJ;;;WAGG;QACH,6DAAM,CAAA;IACP,CAAC,EAlBiB,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QAkBlC;IAgBD,IAAkB,cAGjB;IAHD,WAAkB,cAAc;QAC/B,mEAAY,CAAA;QACZ,mEAAY,CAAA;IACb,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B;IAkCD,IAAkB,WAgBjB;IAhBD,WAAkB,WAAW;QAE5B;;WAEG;QACH,+DAAa,CAAA;QAEb;;WAEG;QACH,6EAAoB,CAAA;QAEpB;;WAEG;QACH,mEAAe,CAAA;IAChB,CAAC,EAhBiB,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAgB5B;IA+OD,IAAkB,eAejB;IAfD,WAAkB,eAAe;QAEhC,mBAAmB;QACnB,qEAAY,CAAA;QACZ,mEAAW,CAAA;QAEX,oBAAoB;QACpB,mEAAW,CAAA;QACX,qEAAY,CAAA;QACZ,mEAAW,CAAA;QACX,uEAAa,CAAA;QACb,qEAAY,CAAA;QACZ,iEAAU,CAAA;QACV,uEAAa,CAAA;QACb,qEAAY,CAAA;IACb,CAAC,EAfiB,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAehC;IAQD,IAAkB,iBAIjB;IAJD,WAAkB,iBAAiB;QAClC,qEAAc,CAAA;QACd,uEAAe,CAAA;QACf,uEAAe,CAAA;IAChB,CAAC,EAJiB,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QAIlC;IAoPD,8BAA8B;IAE9B,SAAgB,iCAAiC,CAAC,oBAA2C;QAC5F,MAAM,uBAAuB,GAAG,oBAAoB,CAAC,QAAQ,CAAmB,0CAA0C,CAAC,CAAC;QAE5H,IAAI,uBAAuB,KAAK,MAAM,EAAE;YACvC,oBAA2B;SAC3B;QAED,qBAA4B;IAC7B,CAAC;IARD,8EAQC;;AAED,YAAY","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IEditorInput, IEditorPane, GroupIdentifier, IEditorInputWithOptions, CloseDirection, IEditorPartOptions, IEditorPartOptionsChangeEvent, EditorsOrder, IVisibleEditorPane, IEditorCloseEvent, IEditorMoveEvent } from 'vs/workbench/common/editor';\nimport { IEditorOptions, ITextEditorOptions } from 'vs/platform/editor/common/editor';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IDimension } from 'vs/editor/common/editorCommon';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { IContextKeyService } from 'vs/platform/contextkey/common/contextkey';\nimport { URI } from 'vs/base/common/uri';\n\nexport const IEditorGroupsService = createDecorator<IEditorGroupsService>('editorGroupsService');\n\nexport const enum GroupDirection {\n\tUP,\n\tDOWN,\n\tLEFT,\n\tRIGHT\n}\n\nexport const enum GroupOrientation {\n\tHORIZONTAL,\n\tVERTICAL\n}\n\nexport const enum GroupLocation {\n\tFIRST,\n\tLAST,\n\tNEXT,\n\tPREVIOUS\n}\n\nexport interface IFindGroupScope {\n\tdirection?: GroupDirection;\n\tlocation?: GroupLocation;\n}\n\nexport const enum GroupsArrangement {\n\n\t/**\n\t * Make the current active group consume the maximum\n\t * amount of space possible.\n\t */\n\tMINIMIZE_OTHERS,\n\n\t/**\n\t * Size all groups evenly.\n\t */\n\tEVEN,\n\n\t/**\n\t * Will behave like MINIMIZE_OTHERS if the active\n\t * group is not already maximized and EVEN otherwise\n\t */\n\tTOGGLE\n}\n\nexport interface GroupLayoutArgument {\n\tsize?: number;\n\tgroups?: GroupLayoutArgument[];\n}\n\nexport interface EditorGroupLayout {\n\torientation: GroupOrientation;\n\tgroups: GroupLayoutArgument[];\n}\n\nexport interface IAddGroupOptions {\n\tactivate?: boolean;\n}\n\nexport const enum MergeGroupMode {\n\tCOPY_EDITORS,\n\tMOVE_EDITORS\n}\n\nexport interface IMergeGroupOptions {\n\tmode?: MergeGroupMode;\n\tindex?: number;\n}\n\nexport interface ICloseEditorOptions {\n\tpreserveFocus?: boolean;\n}\n\nexport type ICloseEditorsFilter = {\n\texcept?: IEditorInput,\n\tdirection?: CloseDirection,\n\tsavedOnly?: boolean,\n\texcludeSticky?: boolean\n};\n\nexport interface ICloseAllEditorsOptions {\n\texcludeSticky?: boolean;\n}\n\nexport interface IEditorReplacement {\n\teditor: IEditorInput;\n\treplacement: IEditorInput;\n\toptions?: IEditorOptions | ITextEditorOptions;\n\n\t/**\n\t * Skips asking the user for confirmation and doesn't\n\t * save the document. Only use this if you really need to!\n\t */\n\tforceReplaceDirty?: boolean;\n}\n\nexport const enum GroupsOrder {\n\n\t/**\n\t * Groups sorted by creation order (oldest one first)\n\t */\n\tCREATION_TIME,\n\n\t/**\n\t * Groups sorted by most recent activity (most recent active first)\n\t */\n\tMOST_RECENTLY_ACTIVE,\n\n\t/**\n\t * Groups sorted by grid widget order\n\t */\n\tGRID_APPEARANCE\n}\n\nexport interface IEditorGroupsService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event for when the active editor group changes. The active editor\n\t * group is the default location for new editors to open.\n\t */\n\treadonly onDidChangeActiveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a new group was added.\n\t */\n\treadonly onDidAddGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was removed.\n\t */\n\treadonly onDidRemoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was moved.\n\t */\n\treadonly onDidMoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group gets activated.\n\t */\n\treadonly onDidActivateGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the group container is layed out.\n\t */\n\treadonly onDidLayout: Event<IDimension>;\n\n\t/**\n\t * An event for when the index of a group changes.\n\t */\n\treadonly onDidChangeGroupIndex: Event<IEditorGroup>;\n\n\t/**\n\t * The size of the editor groups area.\n\t */\n\treadonly contentDimension: IDimension;\n\n\t/**\n\t * An active group is the default location for new editors to open.\n\t */\n\treadonly activeGroup: IEditorGroup;\n\n\t/**\n\t * All groups that are currently visible in the editor area in the\n\t * order of their creation (oldest first).\n\t */\n\treadonly groups: readonly IEditorGroup[];\n\n\t/**\n\t * The number of editor groups that are currently opened.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * The current layout orientation of the root group.\n\t */\n\treadonly orientation: GroupOrientation;\n\n\t/**\n\t * A promise that resolves when groups have been created\n\t * and are ready to be used.\n\t *\n\t * Await this promise to safely work on the editor groups model\n\t * (for example, install editor group listeners).\n\t *\n\t * Use the `whenRestored` property to await visible editors\n\t * having fully resolved.\n\t */\n\treadonly whenReady: Promise<void>;\n\n\t/**\n\t * A promise that resolves when groups have been restored.\n\t *\n\t * For groups with active editor, the promise will resolve\n\t * when the visible editor has finished to resolve.\n\t *\n\t * Use the `whenReady` property to not await editors to\n\t * resolve.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Will return `true` as soon as `whenRestored` is resolved.\n\t */\n\tisRestored(): boolean;\n\n\t/**\n\t * Find out if the editor group service has UI state to restore\n\t * from a previous session.\n\t */\n\treadonly hasRestorableState: boolean;\n\n\t/**\n\t * Get all groups that are currently visible in the editor area.\n\t *\n\t * @param order the order of the editors to use\n\t */\n\tgetGroups(order: GroupsOrder): readonly IEditorGroup[];\n\n\t/**\n\t * Allows to convert a group identifier to a group.\n\t */\n\tgetGroup(identifier: GroupIdentifier): IEditorGroup | undefined;\n\n\t/**\n\t * Set a group as active. An active group is the default location for new editors to open.\n\t */\n\tactivateGroup(group: IEditorGroup | GroupIdentifier): IEditorGroup;\n\n\t/**\n\t * Returns the size of a group.\n\t */\n\tgetSize(group: IEditorGroup | GroupIdentifier): { width: number, height: number };\n\n\t/**\n\t * Sets the size of a group.\n\t */\n\tsetSize(group: IEditorGroup | GroupIdentifier, size: { width: number, height: number }): void;\n\n\t/**\n\t * Arrange all groups according to the provided arrangement.\n\t */\n\tarrangeGroups(arrangement: GroupsArrangement): void;\n\n\t/**\n\t * Applies the provided layout by either moving existing groups or creating new groups.\n\t */\n\tapplyLayout(layout: EditorGroupLayout): void;\n\n\t/**\n\t * Enable or disable centered editor layout.\n\t */\n\tcenterLayout(active: boolean): void;\n\n\t/**\n\t * Find out if the editor layout is currently centered.\n\t */\n\tisLayoutCentered(): boolean;\n\n\t/**\n\t * Sets the orientation of the root group to be either vertical or horizontal.\n\t */\n\tsetGroupOrientation(orientation: GroupOrientation): void;\n\n\t/**\n\t * Find a groupd in a specific scope:\n\t * * `GroupLocation.FIRST`: the first group\n\t * * `GroupLocation.LAST`: the last group\n\t * * `GroupLocation.NEXT`: the next group from either the active one or `source`\n\t * * `GroupLocation.PREVIOUS`: the previous group from either the active one or `source`\n\t * * `GroupDirection.UP`: the next group above the active one or `source`\n\t * * `GroupDirection.DOWN`: the next group below the active one or `source`\n\t * * `GroupDirection.LEFT`: the next group to the left of the active one or `source`\n\t * * `GroupDirection.RIGHT`: the next group to the right of the active one or `source`\n\t *\n\t * @param scope the scope of the group to search in\n\t * @param source optional source to search from\n\t * @param wrap optionally wrap around if reaching the edge of groups\n\t */\n\tfindGroup(scope: IFindGroupScope, source?: IEditorGroup | GroupIdentifier, wrap?: boolean): IEditorGroup;\n\n\t/**\n\t * Add a new group to the editor area. A new group is added by splitting a provided one in\n\t * one of the four directions.\n\t *\n\t * @param location the group from which to split to add a new group\n\t * @param direction the direction of where to split to\n\t * @param options configure the newly group with options\n\t */\n\taddGroup(location: IEditorGroup | GroupIdentifier, direction: GroupDirection, options?: IAddGroupOptions): IEditorGroup;\n\n\t/**\n\t * Remove a group from the editor area.\n\t */\n\tremoveGroup(group: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Move a group to a new group in the editor area.\n\t *\n\t * @param group the group to move\n\t * @param location the group from which to split to add the moved group\n\t * @param direction the direction of where to split to\n\t */\n\tmoveGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Merge the editors of a group into a target group. By default, all editors will\n\t * move and the source group will close. This behaviour can be configured via the\n\t * `IMergeGroupOptions` options.\n\t *\n\t * @param group the group to merge\n\t * @param target the target group to merge into\n\t * @param options controls how the merge should be performed. by default all editors\n\t * will be moved over to the target and the source group will close. Configure to\n\t * `MOVE_EDITORS_KEEP_GROUP` to prevent the source group from closing. Set to\n\t * `COPY_EDITORS` to copy the editors into the target instead of moding them.\n\t */\n\tmergeGroup(group: IEditorGroup | GroupIdentifier, target: IEditorGroup | GroupIdentifier, options?: IMergeGroupOptions): IEditorGroup;\n\n\t/**\n\t * Merge all editor groups into the active one.\n\t */\n\tmergeAllGroups(): IEditorGroup;\n\n\t/**\n\t * Copy a group to a new group in the editor area.\n\t *\n\t * @param group the group to copy\n\t * @param location the group from which to split to add the copied group\n\t * @param direction the direction of where to split to\n\t */\n\tcopyGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Access the options of the editor part.\n\t */\n\treadonly partOptions: IEditorPartOptions;\n\n\t/**\n\t * An event that notifies when editor part options change.\n\t */\n\treadonly onDidChangeEditorPartOptions: Event<IEditorPartOptionsChangeEvent>;\n\n\t/**\n\t * Enforce editor part options temporarily.\n\t */\n\tenforcePartOptions(options: IEditorPartOptions): IDisposable;\n}\n\nexport const enum GroupChangeKind {\n\n\t/* Group Changes */\n\tGROUP_ACTIVE,\n\tGROUP_INDEX,\n\n\t/* Editor Changes */\n\tEDITOR_OPEN,\n\tEDITOR_CLOSE,\n\tEDITOR_MOVE,\n\tEDITOR_ACTIVE,\n\tEDITOR_LABEL,\n\tEDITOR_PIN,\n\tEDITOR_STICKY,\n\tEDITOR_DIRTY\n}\n\nexport interface IGroupChangeEvent {\n\tkind: GroupChangeKind;\n\teditor?: IEditorInput;\n\teditorIndex?: number;\n}\n\nexport const enum OpenEditorContext {\n\tNEW_EDITOR = 1,\n\tMOVE_EDITOR = 2,\n\tCOPY_EDITOR = 3\n}\n\nexport interface IEditorGroup {\n\n\t/**\n\t * An aggregated event for when the group changes in any way.\n\t */\n\treadonly onDidGroupChange: Event<IGroupChangeEvent>;\n\n\t/**\n\t * An event that is fired when the group gets disposed.\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * An event that is fired when an editor is about to close.\n\t */\n\treadonly onWillCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * An event that is fired when an editor is about to move to\n\t * a different group.\n\t */\n\treadonly onWillMoveEditor: Event<IEditorMoveEvent>;\n\n\t/**\n\t * A unique identifier of this group that remains identical even if the\n\t * group is moved to different locations.\n\t */\n\treadonly id: GroupIdentifier;\n\n\t/**\n\t * A number that indicates the position of this group in the visual\n\t * order of groups from left to right and top to bottom. The lowest\n\t * index will likely be top-left while the largest index in most\n\t * cases should be bottom-right, but that depends on the grid.\n\t */\n\treadonly index: number;\n\n\t/**\n\t * A human readable label for the group. This label can change depending\n\t * on the layout of all editor groups. Clients should listen on the\n\t * `onDidGroupChange` event to react to that.\n\t */\n\treadonly label: string;\n\n\t/**\n\t * A human readable label for the group to be used by screen readers.\n\t */\n\treadonly ariaLabel: string;\n\n\t/**\n\t * The active editor pane is the currently visible editor pane of the group.\n\t */\n\treadonly activeEditorPane: IVisibleEditorPane | undefined;\n\n\t/**\n\t * The active editor is the currently visible editor of the group\n\t * within the current active editor pane.\n\t */\n\treadonly activeEditor: IEditorInput | null;\n\n\t/**\n\t * The editor in the group that is in preview mode if any. There can\n\t * only ever be one editor in preview mode.\n\t */\n\treadonly previewEditor: IEditorInput | null;\n\n\t/**\n\t * The number of opened editors in this group.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * Whether the group has editors or not.\n\t */\n\treadonly isEmpty: boolean;\n\n\t/**\n\t * The number of sticky editors in this group.\n\t */\n\treadonly stickyCount: number;\n\n\t/**\n\t * All opened editors in the group in sequential order of their appearance.\n\t */\n\treadonly editors: readonly IEditorInput[];\n\n\t/**\n\t * The scoped context key service for this group.\n\t */\n\treadonly scopedContextKeyService: IContextKeyService;\n\n\t/**\n\t * Get all editors that are currently opened in the group.\n\t *\n\t * @param order the order of the editors to use\n\t * @param options options to select only specific editors as instructed\n\t */\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): readonly IEditorInput[];\n\n\t/**\n\t * Finds all editors for the given resource that are currently\n\t * opened in the group. This method will return an entry for\n\t * each editor that reports a `resource` that matches the\n\t * provided one.\n\t *\n\t * @param resource The resource of the editor to find\n\t */\n\tfindEditors(resource: URI): readonly IEditorInput[];\n\n\t/**\n\t * Returns the editor at a specific index of the group.\n\t */\n\tgetEditorByIndex(index: number): IEditorInput | undefined;\n\n\t/**\n\t * Returns the index of the editor in the group or -1 if not opened.\n\t */\n\tgetIndexOfEditor(editor: IEditorInput): number;\n\n\t/**\n\t * Open an editor in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor.\n\t */\n\topenEditor(editor: IEditorInput, options?: IEditorOptions | ITextEditorOptions): Promise<IEditorPane | undefined>;\n\n\t/**\n\t * Opens editors in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor. Since\n\t * a group can only ever have one active editor, even if many editors are\n\t * opened, the result will only be one editor.\n\t */\n\topenEditors(editors: IEditorInputWithOptions[]): Promise<IEditorPane | null>;\n\n\t/**\n\t * Find out if the provided editor is pinned in the group.\n\t */\n\tisPinned(editor: IEditorInput): boolean;\n\n\t/**\n\t * Find out if the provided editor or index of editor is sticky in the group.\n\t */\n\tisSticky(editorOrIndex: IEditorInput | number): boolean;\n\n\t/**\n\t * Find out if the provided editor is active in the group.\n\t */\n\tisActive(editor: IEditorInput): boolean;\n\n\t/**\n\t * Find out if a certain editor is included in the group.\n\t *\n\t * @param candidate the editor to find\n\t */\n\tcontains(candidate: IEditorInput): boolean;\n\n\t/**\n\t * Move an editor from this group either within this group or to another group.\n\t */\n\tmoveEditor(editor: IEditorInput, target: IEditorGroup, options?: IEditorOptions | ITextEditorOptions): void;\n\n\t/**\n\t * Copy an editor from this group to another group.\n\t *\n\t * Note: It is currently not supported to show the same editor more than once in the same group.\n\t */\n\tcopyEditor(editor: IEditorInput, target: IEditorGroup, options?: IEditorOptions | ITextEditorOptions): void;\n\n\t/**\n\t * Close an editor from the group. This may trigger a confirmation dialog if\n\t * the editor is dirty and thus returns a promise as value.\n\t *\n\t * @param editor the editor to close, or the currently active editor\n\t * if unspecified.\n\t *\n\t * @returns a promise when the editor is closed.\n\t */\n\tcloseEditor(editor?: IEditorInput, options?: ICloseEditorOptions): Promise<void>;\n\n\t/**\n\t * Closes specific editors in this group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise when all editors are closed.\n\t */\n\tcloseEditors(editors: IEditorInput[] | ICloseEditorsFilter, options?: ICloseEditorOptions): Promise<void>;\n\n\t/**\n\t * Closes all editors from the group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise when all editors are closed.\n\t */\n\tcloseAllEditors(options?: ICloseAllEditorsOptions): Promise<void>;\n\n\t/**\n\t * Replaces editors in this group with the provided replacement.\n\t *\n\t * @param editors the editors to replace\n\t *\n\t * @returns a promise that is resolved when the replaced active\n\t * editor (if any) has finished loading.\n\t */\n\treplaceEditors(editors: IEditorReplacement[]): Promise<void>;\n\n\t/**\n\t * Set an editor to be pinned. A pinned editor is not replaced\n\t * when another editor opens at the same location.\n\t *\n\t * @param editor the editor to pin, or the currently active editor\n\t * if unspecified.\n\t */\n\tpinEditor(editor?: IEditorInput): void;\n\n\t/**\n\t * Set an editor to be sticky. A sticky editor is showing in the beginning\n\t * of the tab stripe and will not be impacted by close operations.\n\t *\n\t * @param editor the editor to make sticky, or the currently active editor\n\t * if unspecified.\n\t */\n\tstickEditor(editor?: IEditorInput): void;\n\n\t/**\n\t * Set an editor to be non-sticky and thus moves back to a location after\n\t * sticky editors and can be closed normally.\n\t *\n\t * @param editor the editor to make unsticky, or the currently active editor\n\t * if unspecified.\n\t */\n\tunstickEditor(editor?: IEditorInput): void;\n\n\t/**\n\t * Move keyboard focus into the group.\n\t */\n\tfocus(): void;\n}\n\n\n//#region Editor Group Helpers\n\nexport function preferredSideBySideGroupDirection(configurationService: IConfigurationService): GroupDirection.DOWN | GroupDirection.RIGHT {\n\tconst openSideBySideDirection = configurationService.getValue<'right' | 'down'>('workbench.editor.openSideBySideDirection');\n\n\tif (openSideBySideDirection === 'down') {\n\t\treturn GroupDirection.DOWN;\n\t}\n\n\treturn GroupDirection.RIGHT;\n}\n\n//#endregion\n"]}