{"version":3,"file":"editorService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/editor/common/editorService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAWnF,QAAA,cAAc,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAiB,eAAe,CAAC,CAAC;IASlE,QAAA,YAAY,GAAG,CAAC,CAAC,CAAC;IAGlB,QAAA,UAAU,GAAG,CAAC,CAAC,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IResourceEditorInput, IEditorOptions, ITextEditorOptions, IResourceEditorInputIdentifier } from 'vs/platform/editor/common/editor';\nimport { IEditorInput, IEditorPane, GroupIdentifier, IEditorInputWithOptions, IUntitledTextResourceEditorInput, IResourceDiffEditorInput, ITextEditorPane, ITextDiffEditorPane, IEditorIdentifier, ISaveOptions, IRevertOptions, EditorsOrder, IVisibleEditorPane, IEditorCloseEvent } from 'vs/workbench/common/editor';\nimport { Event } from 'vs/base/common/event';\nimport { IEditor, IDiffEditor } from 'vs/editor/common/editorCommon';\nimport { IEditorGroup, IEditorReplacement } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport const IEditorService = createDecorator<IEditorService>('editorService');\n\nexport type IResourceEditorInputType = IResourceEditorInput | IUntitledTextResourceEditorInput | IResourceDiffEditorInput;\n\nexport interface IResourceEditorReplacement {\n\treadonly editor: IResourceEditorInputType;\n\treadonly replacement: IResourceEditorInputType;\n}\n\nexport const ACTIVE_GROUP = -1;\nexport type ACTIVE_GROUP_TYPE = typeof ACTIVE_GROUP;\n\nexport const SIDE_GROUP = -2;\nexport type SIDE_GROUP_TYPE = typeof SIDE_GROUP;\n\nexport interface IOpenEditorOverrideEntry {\n\treadonly id: string;\n\treadonly label: string;\n\treadonly active: boolean;\n\treadonly detail?: string;\n}\n\nexport interface IOpenEditorOverrideHandler {\n\topen(editor: IEditorInput, options: IEditorOptions | ITextEditorOptions | undefined, group: IEditorGroup): IOpenEditorOverride | undefined;\n\tgetEditorOverrides?(resource: URI, options: IEditorOptions | undefined, group: IEditorGroup | undefined): IOpenEditorOverrideEntry[];\n}\n\nexport interface IOpenEditorOverride {\n\n\t/**\n\t * If defined, will prevent the opening of an editor and replace the resulting\n\t * promise with the provided promise for the openEditor() call.\n\t */\n\toverride?: Promise<IEditorPane | undefined>;\n}\n\nexport interface ISaveEditorsOptions extends ISaveOptions {\n\n\t/**\n\t * If true, will ask for a location of the editor to save to.\n\t */\n\treadonly saveAs?: boolean;\n}\n\nexport interface IBaseSaveRevertAllEditorOptions {\n\n\t/**\n\t * Whether to include untitled editors as well.\n\t */\n\treadonly includeUntitled?: boolean;\n\n\t/**\n\t * Whether to exclude sticky editors.\n\t */\n\treadonly excludeSticky?: boolean;\n}\n\nexport interface ISaveAllEditorsOptions extends ISaveEditorsOptions, IBaseSaveRevertAllEditorOptions { }\n\nexport interface IRevertAllEditorsOptions extends IRevertOptions, IBaseSaveRevertAllEditorOptions { }\n\nexport interface IEditorService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Emitted when the currently active editor changes.\n\t *\n\t * @see `IEditorService.activeEditorPane`\n\t */\n\treadonly onDidActiveEditorChange: Event<void>;\n\n\t/**\n\t * Emitted when any of the current visible editors changes.\n\t *\n\t * @see `IEditorService.visibleEditorPanes`\n\t */\n\treadonly onDidVisibleEditorsChange: Event<void>;\n\n\t/**\n\t * Emitted when an editor is closed.\n\t */\n\treadonly onDidCloseEditor: Event<IEditorCloseEvent>;\n\n\t/**\n\t * The currently active editor pane or `undefined` if none. The editor pane is\n\t * the workbench container for editors of any kind.\n\t *\n\t * @see `IEditorService.activeEditor` for access to the active editor input\n\t */\n\treadonly activeEditorPane: IVisibleEditorPane | undefined;\n\n\t/**\n\t * The currently active editor or `undefined` if none. An editor is active when it is\n\t * located in the currently active editor group. It will be `undefined` if the active\n\t * editor group has no editors open.\n\t */\n\treadonly activeEditor: IEditorInput | undefined;\n\n\t/**\n\t * The currently active text editor control or `undefined` if there is currently no active\n\t * editor or the active editor widget is neither a text nor a diff editor.\n\t *\n\t * @see `IEditorService.activeEditor`\n\t */\n\treadonly activeTextEditorControl: IEditor | IDiffEditor | undefined;\n\n\t/**\n\t * The currently active text editor mode or `undefined` if there is currently no active\n\t * editor or the active editor control is neither a text nor a diff editor. If the active\n\t * editor is a diff editor, the modified side's mode will be taken.\n\t */\n\treadonly activeTextEditorMode: string | undefined;\n\n\t/**\n\t * All editor panes that are currently visible across all editor groups.\n\t *\n\t * @see `IEditorService.visibleEditors` for access to the visible editor inputs\n\t */\n\treadonly visibleEditorPanes: readonly IVisibleEditorPane[];\n\n\t/**\n\t * All editors that are currently visible. An editor is visible when it is opened in an\n\t * editor group and active in that group. Multiple editor groups can be opened at the same time.\n\t */\n\treadonly visibleEditors: readonly IEditorInput[];\n\n\t/**\n\t * All text editor widgets that are currently visible across all editor groups. A text editor\n\t * widget is either a text or a diff editor.\n\t */\n\treadonly visibleTextEditorControls: readonly (IEditor | IDiffEditor)[];\n\n\t/**\n\t * All editors that are opened across all editor groups in sequential order\n\t * of appearance.\n\t *\n\t * This includes active as well as inactive editors in each editor group.\n\t */\n\treadonly editors: readonly IEditorInput[];\n\n\t/**\n\t * The total number of editors that are opened either inactive or active.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * All editors that are opened across all editor groups with their group\n\t * identifier.\n\t *\n\t * @param order the order of the editors to use\n\t * @param options whether to exclude sticky editors or not\n\t */\n\tgetEditors(order: EditorsOrder, options?: { excludeSticky?: boolean }): readonly IEditorIdentifier[];\n\n\t/**\n\t * Open an editor in an editor group.\n\t *\n\t * @param editor the editor to open\n\t * @param options the options to use for the editor\n\t * @param group the target group. If unspecified, the editor will open in the currently\n\t * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side\n\t * of the currently active group.\n\t *\n\t * @returns the editor that opened or `undefined` if the operation failed or the editor was not\n\t * opened to be active.\n\t */\n\topenEditor(editor: IEditorInput, options?: IEditorOptions | ITextEditorOptions, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<IEditorPane | undefined>;\n\topenEditor(editor: IResourceEditorInput | IUntitledTextResourceEditorInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<ITextEditorPane | undefined>;\n\topenEditor(editor: IResourceDiffEditorInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<ITextDiffEditorPane | undefined>;\n\n\t/**\n\t * Open editors in an editor group.\n\t *\n\t * @param editors the editors to open with associated options\n\t * @param group the target group. If unspecified, the editor will open in the currently\n\t * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side\n\t * of the currently active group.\n\t *\n\t * @returns the editors that opened. The array can be empty or have less elements for editors\n\t * that failed to open or were instructed to open as inactive.\n\t */\n\topenEditors(editors: IEditorInputWithOptions[], group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<readonly IEditorPane[]>;\n\topenEditors(editors: IResourceEditorInputType[], group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<readonly IEditorPane[]>;\n\n\t/**\n\t * Replaces editors in an editor group with the provided replacement.\n\t *\n\t * @param editors the editors to replace\n\t * @param group the editor group\n\t *\n\t * @returns a promise that is resolved when the replaced active\n\t * editor (if any) has finished loading.\n\t */\n\treplaceEditors(editors: IResourceEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\treplaceEditors(editors: IEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\n\t/**\n\t * Find out if the provided editor is opened in any editor group.\n\t *\n\t * Note: An editor can be opened but not actively visible.\n\t *\n\t * Note: This method will return `true` if a side by side editor\n\t * is opened where the `primary` editor matches too.\n\t */\n\tisOpened(editor: IResourceEditorInputIdentifier): boolean;\n\n\t/**\n\t * This method will return an entry for each editor that reports\n\t * a `resource` that matches the provided one in the group or\n\t * across all groups.\n\t *\n\t * It is possible that multiple editors are returned in case the\n\t * same resource is opened in different editors. To find the specific\n\t * editor, use the `IResourceEditorInputIdentifier` as input.\n\t */\n\tfindEditors(resource: URI): readonly IEditorIdentifier[];\n\tfindEditors(resource: IResourceEditorInputIdentifier): readonly IEditorIdentifier[];\n\tfindEditors(resource: URI, group: IEditorGroup | GroupIdentifier): readonly IEditorInput[];\n\tfindEditors(resource: IResourceEditorInputIdentifier, group: IEditorGroup | GroupIdentifier): IEditorInput | undefined;\n\n\t/**\n\t * Get all available editor overrides for the editor input.\n\t */\n\tgetEditorOverrides(resource: URI, options: IEditorOptions | undefined, group: IEditorGroup | undefined): [IOpenEditorOverrideHandler, IOpenEditorOverrideEntry][];\n\n\t/**\n\t * Allows to override the opening of editors by installing a handler that will\n\t * be called each time an editor is about to open allowing to override the\n\t * operation to open a different editor.\n\t */\n\toverrideOpenEditor(handler: IOpenEditorOverrideHandler): IDisposable;\n\n\t/**\n\t * Converts a lightweight input to a workbench editor input.\n\t */\n\tcreateEditorInput(input: IResourceEditorInputType): IEditorInput;\n\n\t/**\n\t * Save the provided list of editors.\n\t *\n\t * @returns `true` if all editors saved and `false` otherwise.\n\t */\n\tsave(editors: IEditorIdentifier | IEditorIdentifier[], options?: ISaveEditorsOptions): Promise<boolean>;\n\n\t/**\n\t * Save all editors.\n\t *\n\t * @returns `true` if all editors saved and `false` otherwise.\n\t */\n\tsaveAll(options?: ISaveAllEditorsOptions): Promise<boolean>;\n\n\t/**\n\t * Reverts the provided list of editors.\n\t *\n\t * @returns `true` if all editors reverted and `false` otherwise.\n\t */\n\trevert(editors: IEditorIdentifier | IEditorIdentifier[], options?: IRevertOptions): Promise<boolean>;\n\n\t/**\n\t * Reverts all editors.\n\t *\n\t * @returns `true` if all editors reverted and `false` otherwise.\n\t */\n\trevertAll(options?: IRevertAllEditorsOptions): Promise<boolean>;\n}\n"]}