{"version":3,"file":"extensions.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/extensions/common/extensions.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport Severity from 'vs/base/common/severity';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IExtensionPoint } from 'vs/workbench/services/extensions/common/extensionsRegistry';\nimport { ExtensionIdentifier, IExtension, ExtensionType, IExtensionDescription, IExtensionContributions } from 'vs/platform/extensions/common/extensions';\nimport { getGalleryExtensionId } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { IMessagePassingProtocol } from 'vs/base/parts/ipc/common/ipc';\nimport { ExtensionActivationReason } from 'vs/workbench/api/common/extHostExtensionActivator';\n\nexport const nullExtensionDescription = Object.freeze(<IExtensionDescription>{\n\tidentifier: new ExtensionIdentifier('nullExtensionDescription'),\n\tname: 'Null Extension Description',\n\tversion: '0.0.0',\n\tpublisher: 'vscode',\n\tenableProposedApi: false,\n\tengines: { vscode: '' },\n\textensionLocation: URI.parse('void:location'),\n\tisBuiltin: false,\n});\n\nexport const webWorkerExtHostConfig = 'extensions.webWorker';\n\nexport const IExtensionService = createDecorator<IExtensionService>('extensionService');\n\nexport interface IMessage {\n\ttype: Severity;\n\tmessage: string;\n\textensionId: ExtensionIdentifier;\n\textensionPointId: string;\n}\n\nexport interface IExtensionsStatus {\n\tmessages: IMessage[];\n\tactivationTimes: ActivationTimes | undefined;\n\truntimeErrors: Error[];\n}\n\nexport class MissingExtensionDependency {\n\tconstructor(readonly dependency: string) { }\n}\n\n/**\n * e.g.\n * ```\n * {\n *    startTime: 1511954813493000,\n *    endTime: 1511954835590000,\n *    deltas: [ 100, 1500, 123456, 1500, 100000 ],\n *    ids: [ 'idle', 'self', 'extension1', 'self', 'idle' ]\n * }\n * ```\n */\nexport interface IExtensionHostProfile {\n\t/**\n\t * Profiling start timestamp in microseconds.\n\t */\n\tstartTime: number;\n\t/**\n\t * Profiling end timestamp in microseconds.\n\t */\n\tendTime: number;\n\t/**\n\t * Duration of segment in microseconds.\n\t */\n\tdeltas: number[];\n\t/**\n\t * Segment identifier: extension id or one of the four known strings.\n\t */\n\tids: ProfileSegmentId[];\n\n\t/**\n\t * Get the information as a .cpuprofile.\n\t */\n\tdata: object;\n\n\t/**\n\t * Get the aggregated time per segmentId\n\t */\n\tgetAggregatedTimes(): Map<ProfileSegmentId, number>;\n}\n\nexport const enum ExtensionHostKind {\n\tLocalProcess,\n\tLocalWebWorker,\n\tRemote\n}\n\nexport interface IExtensionHost {\n\treadonly kind: ExtensionHostKind;\n\treadonly remoteAuthority: string | null;\n\treadonly onExit: Event<[number, string | null]>;\n\n\tstart(): Promise<IMessagePassingProtocol> | null;\n\tgetInspectPort(): number | undefined;\n\tenableInspectPort(): Promise<boolean>;\n\tdispose(): void;\n}\n\n\n/**\n * Extension id or one of the four known program states.\n */\nexport type ProfileSegmentId = string | 'idle' | 'program' | 'gc' | 'self';\n\nexport class ActivationTimes {\n\tconstructor(\n\t\tpublic readonly codeLoadingTime: number,\n\t\tpublic readonly activateCallTime: number,\n\t\tpublic readonly activateResolvedTime: number,\n\t\tpublic readonly activationReason: ExtensionActivationReason\n\t) {\n\t}\n}\n\nexport class ExtensionPointContribution<T> {\n\treadonly description: IExtensionDescription;\n\treadonly value: T;\n\n\tconstructor(description: IExtensionDescription, value: T) {\n\t\tthis.description = description;\n\t\tthis.value = value;\n\t}\n}\n\nexport const ExtensionHostLogFileName = 'exthost';\n\nexport interface IWillActivateEvent {\n\treadonly event: string;\n\treadonly activation: Promise<void>;\n}\n\nexport interface IResponsiveStateChangeEvent {\n\tisResponsive: boolean;\n}\n\nexport const enum ActivationKind {\n\tNormal = 0,\n\tImmediate = 1\n}\n\nexport interface IExtensionService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event emitted when extensions are registered after their extension points got handled.\n\t *\n\t * This event will also fire on startup to signal the installed extensions.\n\t *\n\t * @returns the extensions that got registered\n\t */\n\tonDidRegisterExtensions: Event<void>;\n\n\t/**\n\t * @event\n\t * Fired when extensions status changes.\n\t * The event contains the ids of the extensions that have changed.\n\t */\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]>;\n\n\t/**\n\t * Fired when the available extensions change (i.e. when extensions are added or removed).\n\t */\n\tonDidChangeExtensions: Event<void>;\n\n\t/**\n\t * An event that is fired when activation happens.\n\t */\n\tonWillActivateByEvent: Event<IWillActivateEvent>;\n\n\t/**\n\t * An event that is fired when an extension host changes its\n\t * responsive-state.\n\t */\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent>;\n\n\t/**\n\t * Send an activation event and activate interested extensions.\n\t *\n\t * This will wait for the normal startup of the extension host(s).\n\t *\n\t * In extraordinary circumstances, if the activation event needs to activate\n\t * one or more extensions before the normal startup is finished, then you can use\n\t * `ActivationKind.Immediate`. Please do not use this flag unless really necessary\n\t * and you understand all consequences.\n\t */\n\tactivateByEvent(activationEvent: string, activationKind?: ActivationKind): Promise<void>;\n\n\t/**\n\t * An promise that resolves when the installed extensions are registered after\n\t * their extension points got handled.\n\t */\n\twhenInstalledExtensionsRegistered(): Promise<boolean>;\n\n\t/**\n\t * Return all registered extensions\n\t */\n\tgetExtensions(): Promise<IExtensionDescription[]>;\n\n\t/**\n\t * Return a specific extension\n\t * @param id An extension id\n\t */\n\tgetExtension(id: string): Promise<IExtensionDescription | undefined>;\n\n\t/**\n\t * Returns `true` if the given extension can be added. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanAddExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Returns `true` if the given extension can be removed. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanRemoveExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Read all contributions to an extension point.\n\t */\n\treadExtensionPointContributions<T extends IExtensionContributions[keyof IExtensionContributions]>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;\n\n\t/**\n\t * Get information about extensions status.\n\t */\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus };\n\n\t/**\n\t * Return the inspect port or `0`, the latter means inspection\n\t * is not possible.\n\t */\n\tgetInspectPort(tryEnableInspector: boolean): Promise<number>;\n\n\t/**\n\t * Stops the extension hosts.\n\t */\n\tstopExtensionHosts(): void;\n\n\t/**\n\t * Restarts the extension host.\n\t */\n\trestartExtensionHost(): Promise<void>;\n\n\t/**\n\t * Starts the extension hosts.\n\t */\n\tstartExtensionHosts(): Promise<void>;\n\n\t/**\n\t * Modify the environment of the remote extension host\n\t * @param env New properties for the remote extension host\n\t */\n\tsetRemoteEnvironment(env: { [key: string]: string | null }): Promise<void>;\n\n\t_activateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;\n\t_onWillActivateExtension(extensionId: ExtensionIdentifier): void;\n\t_onDidActivateExtension(extensionId: ExtensionIdentifier, codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationReason: ExtensionActivationReason): void;\n\t_onDidActivateExtensionError(extensionId: ExtensionIdentifier, error: Error): void;\n\t_onExtensionRuntimeError(extensionId: ExtensionIdentifier, err: Error): void;\n}\n\nexport interface ProfileSession {\n\tstop(): Promise<IExtensionHostProfile>;\n}\n\nexport function checkProposedApiEnabled(extension: IExtensionDescription): void {\n\tif (!extension.enableProposedApi) {\n\t\tthrowProposedApiError(extension);\n\t}\n}\n\nexport function throwProposedApiError(extension: IExtensionDescription): never {\n\tthrow new Error(`[${extension.identifier.value}]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api ${extension.identifier.value}`);\n}\n\nexport function toExtension(extensionDescription: IExtensionDescription): IExtension {\n\treturn {\n\t\ttype: extensionDescription.isBuiltin ? ExtensionType.System : ExtensionType.User,\n\t\tisBuiltin: extensionDescription.isBuiltin || extensionDescription.isUserBuiltin,\n\t\tidentifier: { id: getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n\t\tmanifest: extensionDescription,\n\t\tlocation: extensionDescription.extensionLocation,\n\t};\n}\n\nexport function toExtensionDescription(extension: IExtension): IExtensionDescription {\n\treturn {\n\t\tidentifier: new ExtensionIdentifier(extension.identifier.id),\n\t\tisBuiltin: extension.type === ExtensionType.System,\n\t\tisUserBuiltin: extension.type === ExtensionType.User && extension.isBuiltin,\n\t\tisUnderDevelopment: false,\n\t\textensionLocation: extension.location,\n\t\t...extension.manifest,\n\t\tuuid: extension.identifier.uuid\n\t};\n}\n\n\nexport class NullExtensionService implements IExtensionService {\n\tdeclare readonly _serviceBrand: undefined;\n\tonDidRegisterExtensions: Event<void> = Event.None;\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]> = Event.None;\n\tonDidChangeExtensions: Event<void> = Event.None;\n\tonWillActivateByEvent: Event<IWillActivateEvent> = Event.None;\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent> = Event.None;\n\tactivateByEvent(_activationEvent: string): Promise<void> { return Promise.resolve(undefined); }\n\twhenInstalledExtensionsRegistered(): Promise<boolean> { return Promise.resolve(true); }\n\tgetExtensions(): Promise<IExtensionDescription[]> { return Promise.resolve([]); }\n\tgetExtension() { return Promise.resolve(undefined); }\n\treadExtensionPointContributions<T>(_extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]> { return Promise.resolve(Object.create(null)); }\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus; } { return Object.create(null); }\n\tgetInspectPort(_tryEnableInspector: boolean): Promise<number> { return Promise.resolve(0); }\n\tstopExtensionHosts(): void { }\n\tasync restartExtensionHost(): Promise<void> { }\n\tasync startExtensionHosts(): Promise<void> { }\n\tasync setRemoteEnvironment(_env: { [key: string]: string | null }): Promise<void> { }\n\tcanAddExtension(): boolean { return false; }\n\tcanRemoveExtension(): boolean { return false; }\n\t_activateById(_extensionId: ExtensionIdentifier, _reason: ExtensionActivationReason): Promise<void> { return Promise.resolve(); }\n\t_onWillActivateExtension(_extensionId: ExtensionIdentifier): void { }\n\t_onDidActivateExtension(_extensionId: ExtensionIdentifier, _codeLoadingTime: number, _activateCallTime: number, _activateResolvedTime: number, _activationReason: ExtensionActivationReason): void { }\n\t_onDidActivateExtensionError(_extensionId: ExtensionIdentifier, _error: Error): void { }\n\t_onExtensionRuntimeError(_extensionId: ExtensionIdentifier, _err: Error): void { }\n\t_onExtensionHostExit(code: number): void { }\n}\n"]}