{"version":3,"file":"textfiles.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/textfile/common/textfiles.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAmBnF,QAAA,gBAAgB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAmB,iBAAiB,CAAC,CAAC;IAqIrF,IAAkB,uBAEjB;IAFD,WAAkB,uBAAuB;QACxC,yFAAc,CAAA;IACf,CAAC,EAFiB,uBAAuB,GAAvB,+BAAuB,KAAvB,+BAAuB,QAExC;IAED,MAAa,sBAAuB,SAAQ,0BAAkB;QAQ7D,YACC,OAAe,EACR,uBAAgD,EACvD,OAAsD;YAEtD,KAAK,CAAC,OAAO,4BAAuC,CAAC;YAH9C,4BAAuB,GAAvB,uBAAuB,CAAyB;YAKvD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACxB,CAAC;QAdD,MAAM,CAAC,wBAAwB,CAAC,GAAY;YAC3C,OAAO,GAAG,YAAY,KAAK,IAAI,CAAC,CAAA,GAAA,yBAAiB,CAAA,CAAE,GAA8B,CAAC,uBAAuB,CAAC,CAAC;QAC5G,CAAC;KAaD;IAjBD,wDAiBC;IAsBD;;OAEG;IACH,IAAkB,wBAiCjB;IAjCD,WAAkB,wBAAwB;QAEzC;;WAEG;QACH,yEAAK,CAAA;QAEL;;WAEG;QACH,yEAAK,CAAA;QAEL;;WAEG;QACH,uFAAY,CAAA;QAEZ;;;WAGG;QACH,+EAAQ,CAAA;QAER;;WAEG;QACH,2EAAM,CAAA;QAEN;;;WAGG;QACH,yEAAK,CAAA;IACN,CAAC,EAjCiB,wBAAwB,GAAxB,gCAAwB,KAAxB,gCAAwB,QAiCzC;IAED,IAAkB,qBAIjB;IAJD,WAAkB,qBAAqB;QACtC,qEAAU,CAAA;QACV,2EAAa,CAAA;QACb,mEAAS,CAAA;IACV,CAAC,EAJiB,qBAAqB,GAArB,6BAAqB,KAArB,6BAAqB,QAItC;IAuMD,IAAkB,YAWjB;IAXD,WAAkB,YAAY;QAE7B;;WAEG;QACH,mDAAM,CAAA;QAEN;;WAEG;QACH,mDAAM,CAAA;IACP,CAAC,EAXiB,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAW7B;IA+CD,SAAgB,qBAAqB,CAAC,KAAuB;QAC5D,MAAM,SAAS,GAAG,KAA6B,CAAC;QAEhD,OAAO,CAAA,GAAA,oBAAY,CAAA,CAAC,SAAS,CAAC,WAAW,EAAE,SAAS,CAAC,WAAW,EAAE,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,OAAO,EAAE,SAAS,CAAC,OAAO,CAAC,CAAC;IAC3I,CAAC;IAJD,sDAIC;IASD,SAAgB,gBAAgB,CAAC,QAAuB;QACvD,MAAM,MAAM,GAAa,EAAE,CAAC;QAE5B,IAAI,KAAoB,CAAC;QACzB,OAAO,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC,KAAK,QAAQ,EAAE;YACrD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACnB;QAED,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC;IATD,4CASC;IAED,SAAgB,gBAAgB,CAAC,KAAa;QAC7C,IAAI,IAAI,GAAG,KAAK,CAAC;QAEjB,OAAO;YACN,IAAI;gBACH,IAAI,CAAC,IAAI,EAAE;oBACV,IAAI,GAAG,IAAI,CAAC;oBAEZ,OAAO,KAAK,CAAC;iBACb;gBAED,OAAO,IAAI,CAAC;YACb,CAAC;SACD,CAAC;IACH,CAAC;IAdD,4CAcC;IAMD,SAAgB,kBAAkB,CAAC,KAAyC;QAC3E,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;YACjC,OAAO,SAAS,CAAC;SACjB;QAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC9B,OAAO,iBAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;SAClC;QAED,OAAO;YACN,IAAI,EAAE,GAAG,EAAE;gBACV,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;gBAC3B,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;oBAC9B,OAAO,iBAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;iBAClC;gBAED,OAAO,IAAI,CAAC;YACb,CAAC;SACD,CAAC;IACH,CAAC;IAnBD,gDAmBC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { ISaveOptions, IRevertOptions, SaveReason } from 'vs/workbench/common/editor';\nimport { ReadableStream } from 'vs/base/common/stream';\nimport { IBaseStatWithMetadata, IFileStatWithMetadata, IWriteFileOptions, FileOperationError, FileOperationResult, IReadFileStreamOptions } from 'vs/platform/files/common/files';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ITextEditorModel } from 'vs/editor/common/services/resolverService';\nimport { ITextBufferFactory, ITextModel, ITextSnapshot } from 'vs/editor/common/model';\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { areFunctions, isUndefinedOrNull } from 'vs/base/common/types';\nimport { IWorkingCopy } from 'vs/workbench/services/workingCopy/common/workingCopy';\nimport { IUntitledTextEditorModelManager } from 'vs/workbench/services/untitled/common/untitledTextEditorService';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IProgress, IProgressStep } from 'vs/platform/progress/common/progress';\nimport { IFileOperationUndoRedoInfo } from 'vs/workbench/services/workingCopy/common/workingCopyFileService';\n\nexport const ITextFileService = createDecorator<ITextFileService>('textFileService');\n\nexport interface ITextFileService extends IDisposable {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Access to the manager of text file editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly files: ITextFileEditorModelManager;\n\n\t/**\n\t * Access to the manager of untitled text editor models providing further\n\t * methods to work with them.\n\t */\n\treadonly untitled: IUntitledTextEditorModelManager;\n\n\t/**\n\t * Helper to determine encoding for resources.\n\t */\n\treadonly encoding: IResourceEncodings;\n\n\t/**\n\t * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.\n\t *\n\t * @param resource the resource to check for being dirty\n\t */\n\tisDirty(resource: URI): boolean;\n\n\t/**\n\t * Saves the resource.\n\t *\n\t * @param resource the resource to save\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsave(resource: URI, options?: ITextFileSaveOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Saves the provided resource asking the user for a file name or using the provided one.\n\t *\n\t * @param resource the resource to save as.\n\t * @param targetResource the optional target to save to.\n\t * @param options optional save options\n\t * @return Path of the saved resource or undefined if canceled.\n\t */\n\tsaveAs(resource: URI, targetResource?: URI, options?: ITextFileSaveAsOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Reverts the provided resource.\n\t *\n\t * @param resource the resource of the file to revert.\n\t * @param force to force revert even when the file is not dirty\n\t */\n\trevert(resource: URI, options?: IRevertOptions): Promise<void>;\n\n\t/**\n\t * Read the contents of a file identified by the resource.\n\t */\n\tread(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;\n\n\t/**\n\t * Read the contents of a file identified by the resource as stream.\n\t */\n\treadStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileStreamContent>;\n\n\t/**\n\t * Update a file with given contents.\n\t */\n\twrite(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Create files. If the file exists it will be overwritten with the contents if\n\t * the options enable to overwrite.\n\t */\n\tcreate(operations: { resource: URI, value?: string | ITextSnapshot, options?: { overwrite?: boolean } }[], undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;\n\n\t/**\n\t * Returns the readable that uses the appropriate encoding. This method should\n\t * be used whenever a `string` or `ITextSnapshot` is being persisted to the\n\t * file system.\n\t */\n\tgetEncodedReadable(resource: URI, value: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable>;\n\tgetEncodedReadable(resource: URI, value: string, options?: IWriteTextFileOptions): Promise<VSBuffer>;\n\tgetEncodedReadable(resource: URI, value?: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable | undefined>;\n\tgetEncodedReadable(resource: URI, value?: string, options?: IWriteTextFileOptions): Promise<VSBuffer | undefined>;\n\tgetEncodedReadable(resource: URI, value?: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;\n\n\t/**\n\t * Returns a stream of strings that uses the appropriate encoding. This method should\n\t * be used whenever a `VSBufferReadableStream` is being loaded from the file system.\n\t */\n\tgetDecodedStream(resource: URI, value: VSBufferReadableStream, options?: IReadTextFileEncodingOptions): Promise<ReadableStream<string>>;\n}\n\nexport interface IReadTextFileEncodingOptions {\n\n\t/**\n\t * The optional encoding parameter allows to specify the desired encoding when resolving\n\t * the contents of the file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * The optional guessEncoding parameter allows to guess encoding from content of the file.\n\t */\n\treadonly autoGuessEncoding?: boolean;\n}\n\nexport interface IReadTextFileOptions extends IReadTextFileEncodingOptions, IReadFileStreamOptions {\n\n\t/**\n\t * The optional acceptTextOnly parameter allows to fail this request early if the file\n\t * contents are not textual.\n\t */\n\treadonly acceptTextOnly?: boolean;\n}\n\nexport interface IWriteTextFileOptions extends IWriteFileOptions {\n\n\t/**\n\t * The encoding to use when updating a file.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * Whether to write to the file as elevated (admin) user. When setting this option a prompt will\n\t * ask the user to authenticate as super user.\n\t */\n\treadonly writeElevated?: boolean;\n}\n\nexport const enum TextFileOperationResult {\n\tFILE_IS_BINARY\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\n\tstatic isTextFileOperationError(obj: unknown): obj is TextFileOperationError {\n\t\treturn obj instanceof Error && !isUndefinedOrNull((obj as TextFileOperationError).textFileOperationResult);\n\t}\n\n\toverride readonly options?: IReadTextFileOptions & IWriteTextFileOptions;\n\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic textFileOperationResult: TextFileOperationResult,\n\t\toptions?: IReadTextFileOptions & IWriteTextFileOptions\n\t) {\n\t\tsuper(message, FileOperationResult.FILE_OTHER_ERROR);\n\n\t\tthis.options = options;\n\t}\n}\n\nexport interface IResourceEncodings {\n\tgetPreferredWriteEncoding(resource: URI, preferredEncoding?: string): Promise<IResourceEncoding>;\n}\n\nexport interface IResourceEncoding {\n\treadonly encoding: string;\n\treadonly hasBOM: boolean;\n}\n\n/**\n * The save error handler can be installed on the text file editor model to install code that executes when save errors occur.\n */\nexport interface ISaveErrorHandler {\n\n\t/**\n\t * Called whenever a save fails.\n\t */\n\tonSaveError(error: Error, model: ITextFileEditorModel): void;\n}\n\n/**\n * States the text file editor model can be in.\n */\nexport const enum TextFileEditorModelState {\n\n\t/**\n\t * A model is saved.\n\t */\n\tSAVED,\n\n\t/**\n\t * A model is dirty.\n\t */\n\tDIRTY,\n\n\t/**\n\t * A model is currently being saved but this operation has not completed yet.\n\t */\n\tPENDING_SAVE,\n\n\t/**\n\t * A model is in conflict mode when changes cannot be saved because the\n\t * underlying file has changed. Models in conflict mode are always dirty.\n\t */\n\tCONFLICT,\n\n\t/**\n\t * A model is in orphan state when the underlying file has been deleted.\n\t */\n\tORPHAN,\n\n\t/**\n\t * Any error that happens during a save that is not causing the CONFLICT state.\n\t * Models in error mode are always dirty.\n\t */\n\tERROR\n}\n\nexport const enum TextFileResolveReason {\n\tEDITOR = 1,\n\tREFERENCE = 2,\n\tOTHER = 3\n}\n\ninterface IBaseTextFileContent extends IBaseStatWithMetadata {\n\n\t/**\n\t * The encoding of the content if known.\n\t */\n\treadonly encoding: string;\n}\n\nexport interface ITextFileContent extends IBaseTextFileContent {\n\n\t/**\n\t * The content of a text file.\n\t */\n\treadonly value: string;\n}\n\nexport interface ITextFileStreamContent extends IBaseTextFileContent {\n\n\t/**\n\t * The line grouped content of a text file.\n\t */\n\treadonly value: ITextBufferFactory;\n}\n\nexport interface ITextFileEditorModelResolveOrCreateOptions {\n\n\t/**\n\t * Context why the model is being resolved or created.\n\t */\n\treadonly reason?: TextFileResolveReason;\n\n\t/**\n\t * The language mode to use for the model text content.\n\t */\n\treadonly mode?: string;\n\n\t/**\n\t * The encoding to use when resolving the model text content.\n\t */\n\treadonly encoding?: string;\n\n\t/**\n\t * The contents to use for the model if known. If not\n\t * provided, the contents will be retrieved from the\n\t * underlying resource or backup if present.\n\t */\n\treadonly contents?: ITextBufferFactory;\n\n\t/**\n\t * If the model was already resolved before, allows to trigger\n\t * a reload of it to fetch the latest contents:\n\t * - async: resolve() will return immediately and trigger\n\t * a reload that will run in the background.\n\t * - sync: resolve() will only return resolved when the\n\t * model has finished reloading.\n\t */\n\treadonly reload?: {\n\t\treadonly async: boolean\n\t};\n\n\t/**\n\t * Allow to resolve a model even if we think it is a binary file.\n\t */\n\treadonly allowBinary?: boolean;\n}\n\nexport interface ITextFileSaveEvent {\n\treadonly model: ITextFileEditorModel;\n\treadonly reason: SaveReason;\n}\n\nexport interface ITextFileResolveEvent {\n\treadonly model: ITextFileEditorModel;\n\treadonly reason: TextFileResolveReason;\n}\n\nexport interface ITextFileSaveParticipant {\n\n\t/**\n\t * Participate in a save of a model. Allows to change the model\n\t * before it is being saved to disk.\n\t */\n\tparticipate(\n\t\tmodel: ITextFileEditorModel,\n\t\tcontext: { reason: SaveReason },\n\t\tprogress: IProgress<IProgressStep>,\n\t\ttoken: CancellationToken\n\t): Promise<void>;\n}\n\nexport interface ITextFileEditorModelManager {\n\n\treadonly onDidCreate: Event<ITextFileEditorModel>;\n\treadonly onDidResolve: Event<ITextFileResolveEvent>;\n\treadonly onDidChangeDirty: Event<ITextFileEditorModel>;\n\treadonly onDidChangeEncoding: Event<ITextFileEditorModel>;\n\treadonly onDidSaveError: Event<ITextFileEditorModel>;\n\treadonly onDidSave: Event<ITextFileSaveEvent>;\n\treadonly onDidRevert: Event<ITextFileEditorModel>;\n\n\t/**\n\t * Access to all text file editor models in memory.\n\t */\n\treadonly models: ITextFileEditorModel[];\n\n\t/**\n\t * Allows to configure the error handler that is called on save errors.\n\t */\n\tsaveErrorHandler: ISaveErrorHandler;\n\n\t/**\n\t * Returns the text file editor model for the provided resource\n\t * or undefined if none.\n\t */\n\tget(resource: URI): ITextFileEditorModel | undefined;\n\n\t/**\n\t * Allows to resolve a text file model from disk.\n\t */\n\tresolve(resource: URI, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<ITextFileEditorModel>;\n\n\t/**\n\t * Adds a participant for saving text file models.\n\t */\n\taddSaveParticipant(participant: ITextFileSaveParticipant): IDisposable;\n\n\t/**\n\t * Runs the registered save participants on the provided model.\n\t */\n\trunSaveParticipants(model: ITextFileEditorModel, context: { reason: SaveReason; }, token: CancellationToken): Promise<void>\n\n\t/**\n\t * Waits for the model to be ready to be disposed. There may be conditions\n\t * under which the model cannot be disposed, e.g. when it is dirty. Once the\n\t * promise is settled, it is safe to dispose the model.\n\t */\n\tcanDispose(model: ITextFileEditorModel): true | Promise<true>;\n}\n\nexport interface ITextFileSaveOptions extends ISaveOptions {\n\n\t/**\n\t * Save the file with an attempt to unlock it.\n\t */\n\treadonly writeUnlock?: boolean;\n\n\t/**\n\t * Save the file with elevated privileges.\n\t *\n\t * Note: This may not be supported in all environments.\n\t */\n\treadonly writeElevated?: boolean;\n\n\t/**\n\t * Allows to write to a file even if it has been modified on disk.\n\t */\n\treadonly ignoreModifiedSince?: boolean;\n\n\t/**\n\t * If set, will bubble up the error to the caller instead of handling it.\n\t */\n\treadonly ignoreErrorHandler?: boolean;\n}\n\nexport interface ITextFileSaveAsOptions extends ITextFileSaveOptions {\n\n\t/**\n\t * Optional URI to use as suggested file path to save as.\n\t */\n\treadonly suggestedTarget?: URI;\n}\n\nexport interface ITextFileResolveOptions {\n\n\t/**\n\t * The contents to use for the model if known. If not\n\t * provided, the contents will be retrieved from the\n\t * underlying resource or backup if present.\n\t */\n\treadonly contents?: ITextBufferFactory;\n\n\t/**\n\t * Go to file bypassing any cache of the model if any.\n\t */\n\treadonly forceReadFromFile?: boolean;\n\n\t/**\n\t * Allow to resolve a model even if we think it is a binary file.\n\t */\n\treadonly allowBinary?: boolean;\n\n\t/**\n\t * Context why the model is being resolved.\n\t */\n\treadonly reason?: TextFileResolveReason;\n}\n\nexport const enum EncodingMode {\n\n\t/**\n\t * Instructs the encoding support to encode the object with the provided encoding\n\t */\n\tEncode,\n\n\t/**\n\t * Instructs the encoding support to decode the object with the provided encoding\n\t */\n\tDecode\n}\n\nexport interface IEncodingSupport {\n\n\t/**\n\t * Gets the encoding of the object if known.\n\t */\n\tgetEncoding(): string | undefined;\n\n\t/**\n\t * Sets the encoding for the object for saving.\n\t */\n\tsetEncoding(encoding: string, mode: EncodingMode): Promise<void>;\n}\n\nexport interface IModeSupport {\n\n\t/**\n\t * Sets the language mode of the object.\n\t */\n\tsetMode(mode: string): void;\n}\n\nexport interface ITextFileEditorModel extends ITextEditorModel, IEncodingSupport, IModeSupport, IWorkingCopy {\n\n\treadonly onDidChangeContent: Event<void>;\n\treadonly onDidSaveError: Event<void>;\n\treadonly onDidChangeOrphaned: Event<void>;\n\treadonly onDidChangeEncoding: Event<void>;\n\n\thasState(state: TextFileEditorModelState): boolean;\n\tjoinState(state: TextFileEditorModelState.PENDING_SAVE): Promise<void>;\n\n\tupdatePreferredEncoding(encoding: string | undefined): void;\n\n\tsave(options?: ITextFileSaveOptions): Promise<boolean>;\n\trevert(options?: IRevertOptions): Promise<void>;\n\n\tresolve(options?: ITextFileResolveOptions): Promise<void>;\n\n\tisDirty(): this is IResolvedTextFileEditorModel;\n\n\tgetMode(): string | undefined;\n\n\tisResolved(): this is IResolvedTextFileEditorModel;\n}\n\nexport function isTextFileEditorModel(model: ITextEditorModel): model is ITextFileEditorModel {\n\tconst candidate = model as ITextFileEditorModel;\n\n\treturn areFunctions(candidate.setEncoding, candidate.getEncoding, candidate.save, candidate.revert, candidate.isDirty, candidate.getMode);\n}\n\nexport interface IResolvedTextFileEditorModel extends ITextFileEditorModel {\n\n\treadonly textEditorModel: ITextModel;\n\n\tcreateSnapshot(): ITextSnapshot;\n}\n\nexport function snapshotToString(snapshot: ITextSnapshot): string {\n\tconst chunks: string[] = [];\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn chunks.join('');\n}\n\nexport function stringToSnapshot(value: string): ITextSnapshot {\n\tlet done = false;\n\n\treturn {\n\t\tread(): string | null {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\nexport function toBufferOrReadable(value: string): VSBuffer;\nexport function toBufferOrReadable(value: ITextSnapshot): VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot): VSBuffer | VSBufferReadable;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined;\nexport function toBufferOrReadable(value: string | ITextSnapshot | undefined): VSBuffer | VSBufferReadable | undefined {\n\tif (typeof value === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\tif (typeof value === 'string') {\n\t\treturn VSBuffer.fromString(value);\n\t}\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = value.read();\n\t\t\tif (typeof chunk === 'string') {\n\t\t\t\treturn VSBuffer.fromString(chunk);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}\n"]}