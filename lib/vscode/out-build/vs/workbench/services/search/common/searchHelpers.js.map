{"version":3,"file":"searchHelpers.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/search/common/searchHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from 'vs/editor/common/core/range';\nimport { FindMatch, ITextModel } from 'vs/editor/common/model';\nimport { ITextSearchPreviewOptions, TextSearchMatch, ITextSearchResult, ITextSearchMatch, ITextQuery, ITextSearchContext } from 'vs/workbench/services/search/common/search';\n\nfunction editorMatchToTextSearchResult(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch {\n\tconst firstLine = matches[0].range.startLineNumber;\n\tconst lastLine = matches[matches.length - 1].range.endLineNumber;\n\n\tconst lineTexts: string[] = [];\n\tfor (let i = firstLine; i <= lastLine; i++) {\n\t\tlineTexts.push(model.getLineContent(i));\n\t}\n\n\treturn new TextSearchMatch(\n\t\tlineTexts.join('\\n') + '\\n',\n\t\tmatches.map(m => new Range(m.range.startLineNumber - 1, m.range.startColumn - 1, m.range.endLineNumber - 1, m.range.endColumn - 1)),\n\t\tpreviewOptions);\n}\n\n/**\n * Combine a set of FindMatches into a set of TextSearchResults. They should be grouped by matches that start on the same line that the previous match ends on.\n */\nexport function editorMatchesToTextSearchResults(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch[] {\n\tlet previousEndLine = -1;\n\tconst groupedMatches: FindMatch[][] = [];\n\tlet currentMatches: FindMatch[] = [];\n\tmatches.forEach((match) => {\n\t\tif (match.range.startLineNumber !== previousEndLine) {\n\t\t\tcurrentMatches = [];\n\t\t\tgroupedMatches.push(currentMatches);\n\t\t}\n\n\t\tcurrentMatches.push(match);\n\t\tpreviousEndLine = match.range.endLineNumber;\n\t});\n\n\treturn groupedMatches.map(sameLineMatches => {\n\t\treturn editorMatchToTextSearchResult(sameLineMatches, model, previewOptions);\n\t});\n}\n\nexport function addContextToEditorMatches(matches: ITextSearchMatch[], model: ITextModel, query: ITextQuery): ITextSearchResult[] {\n\tconst results: ITextSearchResult[] = [];\n\n\tlet prevLine = -1;\n\tfor (let i = 0; i < matches.length; i++) {\n\t\tconst { start: matchStartLine, end: matchEndLine } = getMatchStartEnd(matches[i]);\n\t\tif (typeof query.beforeContext === 'number' && query.beforeContext > 0) {\n\t\t\tconst beforeContextStartLine = Math.max(prevLine + 1, matchStartLine - query.beforeContext);\n\t\t\tfor (let b = beforeContextStartLine; b < matchStartLine; b++) {\n\t\t\t\tresults.push(<ITextSearchContext>{\n\t\t\t\t\ttext: model.getLineContent(b + 1),\n\t\t\t\t\tlineNumber: b\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tresults.push(matches[i]);\n\n\t\tconst nextMatch = matches[i + 1];\n\t\tconst nextMatchStartLine = nextMatch ? getMatchStartEnd(nextMatch).start : Number.MAX_VALUE;\n\t\tif (typeof query.afterContext === 'number' && query.afterContext > 0) {\n\t\t\tconst afterContextToLine = Math.min(nextMatchStartLine - 1, matchEndLine + query.afterContext, model.getLineCount() - 1);\n\t\t\tfor (let a = matchEndLine + 1; a <= afterContextToLine; a++) {\n\t\t\t\tresults.push(<ITextSearchContext>{\n\t\t\t\t\ttext: model.getLineContent(a + 1),\n\t\t\t\t\tlineNumber: a\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tprevLine = matchEndLine;\n\t}\n\n\treturn results;\n}\n\nfunction getMatchStartEnd(match: ITextSearchMatch): { start: number, end: number } {\n\tconst matchRanges = match.ranges;\n\tconst matchStartLine = Array.isArray(matchRanges) ? matchRanges[0].startLineNumber : matchRanges.startLineNumber;\n\tconst matchEndLine = Array.isArray(matchRanges) ? matchRanges[matchRanges.length - 1].endLineNumber : matchRanges.endLineNumber;\n\n\treturn {\n\t\tstart: matchStartLine,\n\t\tend: matchEndLine\n\t};\n}"]}