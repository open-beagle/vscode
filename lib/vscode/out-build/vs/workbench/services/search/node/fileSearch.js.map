{"version":3,"file":"fileSearch.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/search/node/fileSearch.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAgChG,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAc,CAAC;IACvC,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE;QACvB,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;IAChC,CAAC,CAAC,CAAC;IAEH,MAAa,UAAU;QAuBtB,YAAY,MAAkB;YApBtB,mCAA8B,GAAkB,IAAI,CAAC;YAIrD,gBAAW,GAAkB,IAAI,CAAC;YAGlC,eAAU,GAAG,KAAK,CAAC;YACnB,eAAU,GAAqB,IAAI,CAAC;YAIpC,UAAK,GAAqB,IAAI,CAAC;YAC/B,mBAAc,GAAW,CAAC,CAAC;YAQlC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,WAAW,IAAI,EAAE,CAAC;YAC5C,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;YACjF,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,IAAI,IAAI,CAAC;YAC5C,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC;YAC9B,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACvC,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;YACrB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YACxB,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;YAC3B,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;YACrB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;YAEjB,IAAI,IAAI,CAAC,WAAW,EAAE;gBACrB,IAAI,CAAC,8BAA8B,GAAG,CAAA,GAAA,0BAAY,CAAA,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,mBAAmB,CAAC;aACzF;YAED,IAAI,CAAC,oBAAoB,GAAG,MAAM,CAAC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;YACvF,IAAI,CAAC,qBAAqB,GAAG,IAAI,GAAG,EAA+C,CAAC;YAEpF,MAAM,CAAC,aAAa,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;gBAC1C,MAAM,uBAAuB,GAAqB,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,WAAW,CAAC,cAAc,IAAI,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,cAAc,IAAI,EAAE,CAAC,CAAC;gBAExI,sCAAsC;gBACtC,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC;gBACzC,MAAM,CAAC,aAAa;qBAClB,GAAG,CAAC,eAAe,CAAC,EAAE,CAAC,eAAe,CAAC,MAAM,CAAC,MAAM,CAAC;qBACrD,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,KAAK,MAAM,CAAC;qBAC3C,OAAO,CAAC,eAAe,CAAC,EAAE;oBAC1B,8BAA8B;oBAC9B,IAAI,CAAA,GAAA,yBAAe,CAAA,CAAC,eAAe,EAAE,MAAM,CAAC,EAAE;wBAC7C,uBAAuB,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC,GAAG,IAAI,CAAC;qBACvE;gBACF,CAAC,CAAC,CAAC;gBAEJ,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,mCAAmC,CAAC,uBAAuB,EAAE,MAAM,CAAC,CAAC,CAAC;YAClH,CAAC,CAAC,CAAC;QACJ,CAAC;QAED,MAAM;YACL,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACxB,CAAC;QAED,IAAI,CAAC,aAA6B,EAAE,UAAiB,EAAE,QAAyC,EAAE,SAA8C,EAAE,IAAwD;YACzM,IAAI,CAAC,UAAU,GAAG,qBAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAE1C,qEAAqE;YACrE,IAAI,IAAI,CAAC,UAAU,EAAE;gBACpB,OAAO,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;aACnC;YAED,sBAAsB;YACtB,UAAU,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;gBAClC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;gBACrD,IAAI,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,oBAAoB,CAAC,aAAa,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE;oBAC3F,OAAO,CAAC,WAAW;iBACnB;gBAED,4DAA4D;gBAC5D,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,YAAY,EAAE,aAAa,CAAC,MAAM,CAAC,gCAAgC,EAAE,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC;YAC1H,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,KAAK,GAAG,qBAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAErC,uBAAuB;YACvB,IAAI,CAAC,QAAQ,CAAqB,aAAa,EAAE,CAAC,WAAyB,EAAE,cAAyD,EAAE,EAAE;gBACzI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC,GAAW,EAAE,EAAE;oBACpF,IAAI,GAAG,EAAE;wBACR,MAAM,YAAY,GAAG,CAAA,GAAA,6BAAc,CAAA,CAAC,GAAG,CAAC,CAAC;wBACzC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;wBAC5B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;wBAC/B,cAAc,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;qBAC/B;yBAAM;wBACN,cAAc,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;qBAChC;gBACF,CAAC,CAAC,CAAC;YACJ,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE;gBACtB,IAAI,CAAC,UAAW,CAAC,IAAI,EAAE,CAAC;gBACxB,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;gBACvD,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YAC5B,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,QAAQ,CAAO,IAAS,EAAE,EAA8E,EAAE,QAAgE;YACjL,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACvC,MAAM,MAAM,GAAG,IAAI,KAAK,CAAe,IAAI,CAAC,MAAM,CAAC,CAAC;YACpD,IAAI,aAAa,GAAG,KAAK,CAAC;YAC1B,IAAI,SAAS,GAAG,CAAC,CAAC;YAElB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBACtB,OAAO,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;aAC1B;YAED,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;gBAC5B,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE;oBAC1B,IAAI,KAAK,EAAE;wBACV,aAAa,GAAG,IAAI,CAAC;wBACrB,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;wBACtB,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;qBACtB;yBAAM;wBACN,OAAO,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC;wBACxB,MAAM,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;qBACrB;oBAED,IAAI,EAAE,SAAS,KAAK,IAAI,CAAC,MAAM,EAAE;wBAChC,OAAO,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;qBACxD;gBACF,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,IAAI,CAAqB,GAAM,EAAE,IAAS,EAAE,GAAG,IAAW;YACjE,IAAI;gBACH,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;aACtB;YAAC,OAAO,CAAC,EAAE;gBACX,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACzB;QACF,CAAC;QAEO,YAAY,CAAC,WAAyB,EAAE,QAAyC,EAAE,SAA8C,EAAE,EAAyB;YACnK,MAAM,UAAU,GAAG,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC;YAC7C,MAAM,KAAK,GAAG,QAAQ,CAAC,WAAW,CAAC;YACnC,IAAI,GAA8B,CAAC;YACnC,MAAM,OAAO,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC;YACxC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAEtB,IAAI,IAAI,GAAG,CAAC,GAAW,EAAE,EAAE;gBAC1B,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;gBACzB,IAAI,GAAG,GAAG,EAAE,GAAG,CAAC,CAAC;gBACjB,EAAE,CAAC,GAAG,CAAC,CAAC;YACT,CAAC,CAAC;YACF,IAAI,QAAQ,GAAG,EAAE,CAAC;YAClB,MAAM,IAAI,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAEtC,IAAI,iBAA0B,CAAC;YAC/B,MAAM,OAAO,GAAG,CAAA,GAAA,mCAAe,CAAA,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC,UAAU,CAAC,CAAC;YAC7J,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC;YAClB,iBAAiB,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC;YAEhE,MAAM,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI;iBACrC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC;iBAC9C,IAAI,CAAC,GAAG,CAAC,CAAC;YAEZ,IAAI,KAAK,GAAG,GAAG,OAAO,CAAC,UAAU,IAAI,WAAW,aAAa,OAAO,CAAC,GAAG,EAAE,CAAC;YAC3E,IAAI,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE;gBAClC,KAAK,IAAI,yBAAyB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC;aAClF;YACD,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,CAAC;YAE9B,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;YACxB,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC,GAAiB,EAAE,MAAe,EAAE,IAAc,EAAE,EAAE;gBACjG,IAAI,GAAG,EAAE;oBACR,IAAI,CAAC,GAAG,CAAC,CAAC;oBACV,OAAO;iBACP;gBACD,IAAI,IAAI,CAAC,UAAU,EAAE;oBACpB,IAAI,EAAE,CAAC;oBACP,OAAO;iBACP;gBAED,sDAAsD;gBACtD,MAAM,UAAU,GAAG,QAAQ,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,YAAY,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;gBAC1F,MAAM,aAAa,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBAE7C,IAAI,IAAI,EAAE;oBACT,MAAM,CAAC,GAAG,aAAa,CAAC,MAAM,CAAC;oBAC/B,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;oBACnD,IAAI,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;wBAC1B,aAAa,CAAC,GAAG,EAAE,CAAC;qBACpB;iBACD;qBAAM;oBACN,QAAQ,GAAG,aAAa,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC;iBACrC;gBAED,IAAI,aAAa,CAAC,MAAM,IAAI,aAAa,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;oBAClE,IAAI,CAAC,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC,CAAC;oBAC7C,OAAO;iBACP;gBAED,IAAI,CAAC,cAAc,IAAI,aAAa,CAAC,MAAM,CAAC;gBAE5C,IAAI,iBAAiB,EAAE;oBACtB,KAAK,MAAM,YAAY,IAAI,aAAa,EAAE;wBACzC,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,YAAY,EAAE,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC;wBACxH,IAAI,IAAI,CAAC,UAAU,EAAE;4BACpB,OAAO,EAAE,CAAC;4BACV,MAAM;yBACN;qBACD;oBACD,IAAI,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;wBAC5B,IAAI,EAAE,CAAC;qBACP;oBAED,OAAO;iBACP;gBAED,qDAAqD;gBACrD,IAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE,IAAI,EAAE,UAAU,EAAE,aAAa,EAAE,QAAQ,CAAC,CAAC;gBAEjF,IAAI,IAAI,EAAE;oBACT,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;oBACpD,IAAI,EAAE,CAAC;iBACP;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;QAED;;WAEG;QACH,YAAY,CAAC,WAAyB;YACrC,MAAM,cAAc,GAAG,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC;YAClF,MAAM,SAAS,GAAG,cAAc,CAAC,gBAAgB,EAAE,CAAC;YACpD,MAAM,SAAS,GAAG,cAAc,CAAC,YAAY,EAAE,CAAC;YAChD,MAAM,IAAI,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;YACzB,IAAI,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,EAAE;gBACzC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;gBAC5B,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;oBACjC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;oBAC7B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAChB;gBACD,KAAK,MAAM,IAAI,IAAI,SAAS,EAAE;oBAC7B,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;oBACzB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAChB;gBACD,IAAI,CAAC,GAAG,EAAE,CAAC;gBACX,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC;aAC9B;YACD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YACxB,OAAO,YAAY,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,WAAW,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;QAC7E,CAAC;QAED;;WAEG;QACH,UAAU,CAAC,GAA8B,EAAE,QAAwB,EAAE,EAAgD;YACpH,IAAI,GAAG,GAAG,EAAE,CAAC;YACb,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAiB,EAAE,MAAe,EAAE,IAAc,EAAE,EAAE;gBACnG,IAAI,GAAG,EAAE;oBACR,EAAE,CAAC,GAAG,CAAC,CAAC;oBACR,OAAO;iBACP;gBAED,GAAG,IAAI,MAAM,CAAC;gBACd,IAAI,IAAI,EAAE;oBACT,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;iBACd;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,aAAa,CAAC,GAA8B,EAAE,QAAwB,EAAE,SAA8C,EAAE,EAAgE;YAC/L,IAAI,MAAM,GAAG,CAAC,GAAiB,EAAE,MAAe,EAAE,IAAc,EAAE,EAAE;gBACnE,IAAI,GAAG,IAAI,IAAI,EAAE;oBAChB,MAAM,GAAG,GAAG,EAAE,GAAG,CAAC,CAAC;oBAEnB,IAAI,IAAI,CAAC,KAAK,EAAE;wBACf,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;qBAClB;iBACD;gBACD,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;YACvB,CAAC,CAAC;YAEF,IAAI,OAAO,GAAG,KAAK,CAAC;YACpB,IAAI,GAAG,CAAC,MAAM,EAAE;gBACf,iCAAiC;gBACjC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;gBAC/C,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,OAAO,GAAG,IAAI,CAAC,CAAC;aAC9C;iBAAM;gBACN,SAAS,CAAC,EAAE,OAAO,EAAE,gBAAgB,EAAE,CAAC,CAAC;aACzC;YAED,IAAI,MAAgB,CAAC;YACrB,IAAI,GAAG,CAAC,MAAM,EAAE;gBACf,iCAAiC;gBACjC,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;aACtC;iBAAM;gBACN,SAAS,CAAC,EAAE,OAAO,EAAE,gBAAgB,EAAE,CAAC,CAAC;aACzC;YAED,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAU,EAAE,EAAE;gBAC9B,MAAM,CAAC,GAAG,CAAC,CAAC;YACb,CAAC,CAAC,CAAC;YAEH,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,IAAY,EAAE,EAAE;gBAChC,mDAAmD;gBACnD,IAAI,UAAkB,CAAC;gBACvB,IAAI,CAAC,OAAO,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,IAAI,oBAAoB,CAAC,UAAU,CAAC,EAAE;oBACrG,MAAM,CAAC,IAAI,KAAK,CAAC,kCAAkC,IAAI,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;iBAClG;qBAAM;oBACN,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,KAAK,CAAC,EAAE;wBAC9B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;qBACvB;oBACD,MAAM,CAAC,IAAI,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;iBACvB;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,WAAW,CAAC,MAAgB,EAAE,QAAwB,EAAE,EAAgD;YAC/G,MAAM,OAAO,GAAG,IAAI,8BAAa,CAAC,QAAQ,CAAC,CAAC;YAC5C,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE;gBAClC,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;YACH,OAAO,OAAO,CAAC;QAChB,CAAC;QAEO,WAAW,CAAC,MAAgB;YACnC,MAAM,OAAO,GAAa,EAAE,CAAC;YAC7B,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE;gBAClC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACpB,CAAC,CAAC,CAAC;YACH,OAAO,OAAO,CAAC;QAChB,CAAC;QAEO,UAAU,CAAC,OAAiB,EAAE,QAAwB;YAC7D,MAAM,OAAO,GAAG,IAAI,8BAAa,CAAC,QAAQ,CAAC,CAAC;YAC5C,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC9D,CAAC;QAEO,iBAAiB;YACxB,MAAM,IAAI,GAAmB;gBAC5B,WAAW,EAAE,EAAE;gBACf,aAAa,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;aAClC,CAAC;YACF,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC;YAC3C,OAAO,IAAI,CAAC;QACb,CAAC;QAEO,mBAAmB,CAAC,WAAyB,EAAE,EAAE,aAAa,EAAkB,EAAE,IAAY,EAAE,aAAuB,EAAE,QAAyC;YACzK,0EAA0E;YAC1E,IAAI,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE;gBACnD,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;oBACxB,IAAI;oBACJ,YAAY,EAAE,IAAI,CAAC,WAAW;oBAC9B,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC;iBAC7D,CAAC,CAAC;aACH;YAED,MAAM,GAAG,GAAG,CAAC,YAAoB,EAAE,EAAE;gBACpC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;gBAC7C,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;gBAC3C,IAAI,OAAO,GAAG,aAAa,CAAC,OAAO,CAAC,CAAC;gBACrC,IAAI,CAAC,OAAO,EAAE;oBACb,OAAO,GAAG,aAAa,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;oBACtC,GAAG,CAAC,OAAO,CAAC,CAAC;iBACb;gBACD,OAAO,CAAC,IAAI,CAAC;oBACZ,IAAI;oBACJ,YAAY;oBACZ,QAAQ;oBACR,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,YAAY,CAAC;iBACzD,CAAC,CAAC;YACJ,CAAC,CAAC;YACF,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAC5B,CAAC;QAEO,kBAAkB,CAAC,EAAE,WAAW,EAAE,aAAa,EAAkB,EAAE,UAAkB,EAAE,QAAyC;YACvI,MAAM,IAAI,GAAG,IAAI,CAAC;YAClB,MAAM,cAAc,GAAG,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC;YACnE,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACrC,SAAS,cAAc,CAAC,OAA0B;gBACjD,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,MAAM,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACjF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;oBAC/C,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;oBACzB,MAAM,EAAE,YAAY,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAC;oBAEzC,wBAAwB;oBACxB,4EAA4E;oBAC5E,0EAA0E;oBAC1E,yEAAyE;oBACzE,IAAI,cAAc,CAAC,IAAI,CAAC,YAAY,EAAE,QAAQ,EAAE,WAAW,KAAK,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE;wBACnG,SAAS;qBACT;oBAED,MAAM,GAAG,GAAG,aAAa,CAAC,YAAY,CAAC,CAAC;oBACxC,IAAI,GAAG,EAAE;wBACR,cAAc,CAAC,GAAG,CAAC,CAAC;qBACpB;yBAAM;wBACN,IAAI,CAAC,WAAW,EAAE,CAAC;wBACnB,IAAI,YAAY,KAAK,WAAW,EAAE;4BACjC,SAAS,CAAC,8FAA8F;yBACxG;wBAED,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;qBAChC;oBAED,IAAI,IAAI,CAAC,UAAU,EAAE;wBACpB,MAAM;qBACN;iBACD;YACF,CAAC;YACD,cAAc,CAAC,WAAW,CAAC,CAAC;QAC7B,CAAC;QAED,QAAQ;YACP,OAAO;gBACN,OAAO,EAAE,IAAI,CAAC,KAAM,CAAC,OAAO,EAAE;gBAC9B,YAAY,EAAE,IAAI,CAAC,UAAW,CAAC,OAAO,EAAE;gBACxC,iBAAiB,EAAE,IAAI,CAAC,iBAAiB;gBACzC,WAAW,EAAE,IAAI,CAAC,WAAW;gBAC7B,cAAc,EAAE,IAAI,CAAC,cAAc;aACnC,CAAC;QACH,CAAC;QAEO,MAAM,CAAC,WAAyB,EAAE,kBAA0B,EAAE,KAAe,EAAE,QAAyC,EAAE,IAA6B;YAC9J,MAAM,UAAU,GAAG,WAAW,CAAC,MAAM,CAAC;YAEtC,gEAAgE;YAChE,MAAM,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;YAClD,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,IAAY,EAAE,GAA2C,EAAQ,EAAE;gBAExF,iBAAiB;gBACjB,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAAE;oBACvC,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;iBACjB;gBAED,wBAAwB;gBACxB,4EAA4E;gBAC5E,0EAA0E;gBAC1E,yEAAyE;gBACzE,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;gBAClG,IAAI,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW,KAAK,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE;oBAC1J,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;iBACjB;gBAED,4BAA4B;gBAC5B,MAAM,mBAAmB,GAAG,CAAC,UAAU,CAAC,MAAM,EAAE,mBAAmB,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACpF,EAAE,CAAC,KAAK,CAAC,mBAAmB,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;oBAC9C,IAAI,KAAK,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAAE;wBAChD,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;qBACjB;oBAED,0EAA0E;oBAC1E,0EAA0E;oBAC1E,mCAAmC;oBACnC,IAAI,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;wBACjE,IAAI,KAAK,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAAE;4BAChD,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;yBACjB;wBAED,gCAAgC;wBAChC,IAAI,IAAI,CAAC,WAAW,EAAE,EAAE;4BACvB,IAAI,CAAC,iBAAiB,EAAE,CAAC;4BAEzB,8EAA8E;4BAC9E,OAAO,IAAI,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE;gCAC5E,IAAI,KAAK,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAAE;oCAChD,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;iCACjB;gCAED,QAAQ,GAAG,QAAQ,IAAI,EAAE,CAAC;gCAC1B,IAAI,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;oCAC/B,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,0DAA0D;iCAC5E;gCAED,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC,qBAAqB;gCAExD,mBAAmB;gCACnB,OAAO,CAAA,GAAA,aAAO,CAAA,CAAC,mBAAmB,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;oCACnD,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAAE;wCACvC,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;qCACjB;oCAED,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,mBAAmB,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,CAAC,CAAC;gCAC5F,CAAC,EAAE,KAAK,CAAC,EAAE;oCACV,GAAG,CAAC,IAAI,CAAC,CAAC;gCACX,CAAC,CAAC,CAAC;4BACJ,CAAC,CAAC,CAAC;yBACH;wBAED,4DAA4D;6BACvD;4BACJ,IAAI,CAAC,WAAW,EAAE,CAAC;4BACnB,IAAI,mBAAmB,KAAK,IAAI,CAAC,WAAW,EAAE;gCAC7C,OAAO,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,oHAAoH;6BACjJ;4BAED,IAAI,IAAI,CAAC,WAAW,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE;gCAClF,OAAO,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,sCAAsC;6BACnE;4BAED,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;gCACxB,IAAI,EAAE,UAAU,CAAC,MAAM;gCACvB,YAAY,EAAE,mBAAmB;gCACjC,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,mBAAmB,CAAC;6BAChE,CAAC,CAAC;yBACH;wBAED,SAAS;wBACT,OAAO,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;oBAC7B,CAAC,CAAC,CAAC;gBACJ,CAAC,CAAC,CAAC;YACJ,CAAC,EAAE,CAAC,KAAiC,EAAQ,EAAE;gBAC9C,MAAM,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,+CAA+C;gBAC9G,OAAO,IAAI,CAAC,cAAc,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;YAC1F,CAAC,CAAC,CAAC;QACJ,CAAC;QAEO,SAAS,CAAC,QAAyC,EAAE,SAAwB;YACpF,IAAI,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE;gBAChJ,IAAI,CAAC,WAAW,EAAE,CAAC;gBAEnB,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,EAAE;oBAC3E,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;iBACvB;gBAED,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;oBACrB,QAAQ,CAAC,SAAS,CAAC,CAAC;iBACpB;aACD;QACF,CAAC;QAEO,WAAW,CAAC,SAAwB;YAC3C,2BAA2B;YAC3B,IAAI,IAAI,CAAC,WAAW,EAAE;gBACrB,IAAI,IAAI,CAAC,WAAW,KAAK,GAAG,EAAE;oBAC7B,OAAO,IAAI,CAAC,CAAC,oCAAoC;iBACjD;gBAED,IAAI,IAAI,CAAC,8BAA8B,EAAE;oBACxC,OAAO,CAAA,GAAA,2BAAkB,CAAA,CAAC,SAAS,EAAE,IAAI,CAAC,8BAA8B,CAAC,CAAC;iBAC1E;aACD;YAED,iCAAiC;YACjC,OAAO,IAAI,CAAC;QACb,CAAC;QAEO,gBAAgB,CAAC,IAAY,EAAE,KAAe,EAAE,GAAkD;YACzG,IAAI,KAAK,CAAC,cAAc,EAAE,EAAE;gBAC3B,OAAO,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,qCAAqC;aAChE;YAED,OAAO,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,+CAA+C;QACzE,CAAC;QAEO,gBAAgB,CAAC,IAAY,EAAE,KAAe,EAAE,GAAqD;YAC5G,IAAI,KAAK,CAAC,cAAc,EAAE,EAAE;gBAC3B,OAAO,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE;oBAC5C,IAAI,KAAK,EAAE;wBACV,OAAO,GAAG,CAAC,KAAK,CAAC,CAAC;qBAClB;oBAED,OAAO,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;gBAC5B,CAAC,CAAC,CAAC;aACH;YAED,OAAO,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACxB,CAAC;QAED;;;;;WAKG;QACK,aAAa,CAAC,WAAyB,EAAE,YAAoB;YACpE,IAAI,WAAW,CAAC,UAAU,EAAE;gBAC3B,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;aACvD;YACD,OAAO,YAAY,CAAC;QACrB,CAAC;KACD;IAxkBD,gCAwkBC;IAED,MAAa,MAAM;QAKlB,YAAY,MAAkB;YAC7B,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;YAC1C,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,kBAAkB,IAAI,EAAE,CAAC;YAElD,IAAI,CAAC,MAAM,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;QACtC,CAAC;QAED,MAAM,CAAC,QAAyC,EAAE,UAAgD,EAAE,IAAmE;YACtK,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,EAAE,UAAU,EAAE,CAAC,GAAiB,EAAE,UAAmB,EAAE,EAAE;gBACtH,IAAI,CAAC,GAAG,EAAE;oBACT,QAAQ,EAAE,UAAU;oBACpB,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;oBAC7B,QAAQ,EAAE,EAAE;iBACZ,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;QACJ,CAAC;QAED,MAAM;YACL,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QACtB,CAAC;KACD;IAzBD,wBAyBC;IAED;;;;OAIG;IACH,MAAM,mCAAmC;QAIxC,YAAmB,UAA4B,EAAU,IAAY;YAAlD,eAAU,GAAV,UAAU,CAAkB;YAAU,SAAI,GAAJ,IAAI,CAAQ;YACpE,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACvB,CAAC;QAED;;WAEG;QACK,IAAI,CAAC,IAAsB;YAClC,IAAI,gBAA8C,CAAC;YACnD,IAAI,gBAA8C,CAAC;YACnD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;iBACf,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBACxB,OAAO,CAAC,GAAG,CAAC,EAAE;gBACd,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;oBACzB,gBAAgB,GAAG,gBAAgB,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;oBACjE,gBAAgB,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;iBAClC;qBAAM;oBACN,gBAAgB,GAAG,gBAAgB,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;oBACjE,gBAAgB,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;iBAClC;YACF,CAAC,CAAC,CAAC;YAEJ,IAAI,CAAC,kBAAkB,GAAG,gBAAgB,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,EAAE,iBAAiB,EAAE,IAAI,EAAE,CAAC,CAAC;YACxG,IAAI,CAAC,kBAAkB,GAAG,gBAAgB,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,EAAE,iBAAiB,EAAE,IAAI,EAAE,CAAC,CAAC;QACzG,CAAC;QAED,IAAI,CAAC,KAAa,EAAE,QAAiB,EAAE,UAAyD;YAC/F,OAAO,CAAC,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;gBACvF,CAAC,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC,CAAC;QAC1G,CAAC;QAED,gBAAgB;YACf,MAAM,aAAa,GAAa,EAAE,CAAC;YACnC,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBAC5B,aAAa,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC;aACtE;YAED,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBAC5B,aAAa,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC;aACtE;YAED,OAAO,aAAa,CAAC;QACtB,CAAC;QAED,YAAY;YACX,MAAM,SAAS,GAAa,EAAE,CAAC;YAC/B,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBAC5B,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC;aAC9D;YAED,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBAC5B,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC;aAC9D;YAED,OAAO,SAAS,CAAC;QAClB,CAAC;KACD;IAED,SAAgB,oBAAoB,CAAC,GAAW;QAC/C,MAAM,KAAK,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACrC,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;QAElC,IAAI,SAAS,CAAC,UAAU,CAAC,qBAAqB,CAAC,EAAE;YAChD,OAAO,SAAS,CAAC;SACjB;QAED,IAAI,SAAS,CAAC,UAAU,CAAC,mBAAmB,CAAC,EAAE;YAC9C,OAAO,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;SACpE;QAED,IAAI,SAAS,CAAC,UAAU,CAAC,oBAAoB,CAAC;YAC7C,SAAS,CAAC,UAAU,CAAC,sBAAsB,CAAC,EAAE;YAC9C,yBAAyB;YACzB,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;SAC/D;QAED,IAAI,SAAS,KAAK,4BAA4B,EAAE;YAC/C,iFAAiF;YACjF,OAAO,uCAAuC,CAAC;SAC/C;QAED,IAAI,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;YACrC,0BAA0B;YAC1B,OAAO,SAAS,CAAC;SACjB;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IA7BD,oDA6BC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as childProcess from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'vs/base/common/path';\nimport { Readable } from 'stream';\nimport { StringDecoder } from 'string_decoder';\nimport * as arrays from 'vs/base/common/arrays';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport * as glob from 'vs/base/common/glob';\nimport * as normalization from 'vs/base/common/normalization';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport * as platform from 'vs/base/common/platform';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport * as strings from 'vs/base/common/strings';\nimport * as types from 'vs/base/common/types';\nimport { URI } from 'vs/base/common/uri';\nimport { readdir } from 'vs/base/node/pfs';\nimport { IFileQuery, IFolderQuery, IProgressMessage, ISearchEngineStats, IRawFileMatch, ISearchEngine, ISearchEngineSuccess, isFilePatternMatch } from 'vs/workbench/services/search/common/search';\nimport { spawnRipgrepCmd } from './ripgrepFileSearch';\nimport { prepareQuery } from 'vs/base/common/fuzzyScorer';\n\ninterface IDirectoryEntry extends IRawFileMatch {\n\tbase: string;\n\tbasename: string;\n}\n\ninterface IDirectoryTree {\n\trootEntries: IDirectoryEntry[];\n\tpathToEntries: { [relativePath: string]: IDirectoryEntry[] };\n}\n\nconst killCmds = new Set<() => void>();\nprocess.on('exit', () => {\n\tkillCmds.forEach(cmd => cmd());\n});\n\nexport class FileWalker {\n\tprivate config: IFileQuery;\n\tprivate filePattern: string;\n\tprivate normalizedFilePatternLowercase: string | null = null;\n\tprivate includePattern: glob.ParsedExpression | undefined;\n\tprivate maxResults: number | null;\n\tprivate exists: boolean;\n\tprivate maxFilesize: number | null = null;\n\tprivate isLimitHit: boolean;\n\tprivate resultCount: number;\n\tprivate isCanceled = false;\n\tprivate fileWalkSW: StopWatch | null = null;\n\tprivate directoriesWalked: number;\n\tprivate filesWalked: number;\n\tprivate errors: string[];\n\tprivate cmdSW: StopWatch | null = null;\n\tprivate cmdResultCount: number = 0;\n\n\tprivate folderExcludePatterns: Map<string, AbsoluteAndRelativeParsedExpression>;\n\tprivate globalExcludePattern: glob.ParsedExpression | undefined;\n\n\tprivate walkedPaths: { [path: string]: boolean; };\n\n\tconstructor(config: IFileQuery) {\n\t\tthis.config = config;\n\t\tthis.filePattern = config.filePattern || '';\n\t\tthis.includePattern = config.includePattern && glob.parse(config.includePattern);\n\t\tthis.maxResults = config.maxResults || null;\n\t\tthis.exists = !!config.exists;\n\t\tthis.walkedPaths = Object.create(null);\n\t\tthis.resultCount = 0;\n\t\tthis.isLimitHit = false;\n\t\tthis.directoriesWalked = 0;\n\t\tthis.filesWalked = 0;\n\t\tthis.errors = [];\n\n\t\tif (this.filePattern) {\n\t\t\tthis.normalizedFilePatternLowercase = prepareQuery(this.filePattern).normalizedLowercase;\n\t\t}\n\n\t\tthis.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n\t\tthis.folderExcludePatterns = new Map<string, AbsoluteAndRelativeParsedExpression>();\n\n\t\tconfig.folderQueries.forEach(folderQuery => {\n\t\t\tconst folderExcludeExpression: glob.IExpression = Object.assign({}, folderQuery.excludePattern || {}, this.config.excludePattern || {});\n\n\t\t\t// Add excludes for other root folders\n\t\t\tconst fqPath = folderQuery.folder.fsPath;\n\t\t\tconfig.folderQueries\n\t\t\t\t.map(rootFolderQuery => rootFolderQuery.folder.fsPath)\n\t\t\t\t.filter(rootFolder => rootFolder !== fqPath)\n\t\t\t\t.forEach(otherRootFolder => {\n\t\t\t\t\t// Exclude nested root folders\n\t\t\t\t\tif (isEqualOrParent(otherRootFolder, fqPath)) {\n\t\t\t\t\t\tfolderExcludeExpression[path.relative(fqPath, otherRootFolder)] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.folderExcludePatterns.set(fqPath, new AbsoluteAndRelativeParsedExpression(folderExcludeExpression, fqPath));\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.isCanceled = true;\n\t}\n\n\twalk(folderQueries: IFolderQuery[], extraFiles: URI[], onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgressMessage) => void, done: (error: Error | null, isLimitHit: boolean) => void): void {\n\t\tthis.fileWalkSW = StopWatch.create(false);\n\n\t\t// Support that the file pattern is a full path to a file that exists\n\t\tif (this.isCanceled) {\n\t\t\treturn done(null, this.isLimitHit);\n\t\t}\n\n\t\t// For each extra file\n\t\textraFiles.forEach(extraFilePath => {\n\t\t\tconst basename = path.basename(extraFilePath.fsPath);\n\t\t\tif (this.globalExcludePattern && this.globalExcludePattern(extraFilePath.fsPath, basename)) {\n\t\t\t\treturn; // excluded\n\t\t\t}\n\n\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\tthis.matchFile(onResult, { relativePath: extraFilePath.fsPath /* no workspace relative path */, searchPath: undefined });\n\t\t});\n\n\t\tthis.cmdSW = StopWatch.create(false);\n\n\t\t// For each root folder\n\t\tthis.parallel<IFolderQuery, void>(folderQueries, (folderQuery: IFolderQuery, rootFolderDone: (err: Error | null, result: void) => void) => {\n\t\t\tthis.call(this.cmdTraversal, this, folderQuery, onResult, onMessage, (err?: Error) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tconst errorMessage = toErrorMessage(err);\n\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t\tthis.errors.push(errorMessage);\n\t\t\t\t\trootFolderDone(err, undefined);\n\t\t\t\t} else {\n\t\t\t\t\trootFolderDone(null, undefined);\n\t\t\t\t}\n\t\t\t});\n\t\t}, (errors, _result) => {\n\t\t\tthis.fileWalkSW!.stop();\n\t\t\tconst err = errors ? arrays.coalesce(errors)[0] : null;\n\t\t\tdone(err, this.isLimitHit);\n\t\t});\n\t}\n\n\tprivate parallel<T, E>(list: T[], fn: (item: T, callback: (err: Error | null, result: E | null) => void) => void, callback: (err: Array<Error | null> | null, result: E[]) => void): void {\n\t\tconst results = new Array(list.length);\n\t\tconst errors = new Array<Error | null>(list.length);\n\t\tlet didErrorOccur = false;\n\t\tlet doneCount = 0;\n\n\t\tif (list.length === 0) {\n\t\t\treturn callback(null, []);\n\t\t}\n\n\t\tlist.forEach((item, index) => {\n\t\t\tfn(item, (error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tdidErrorOccur = true;\n\t\t\t\t\tresults[index] = null;\n\t\t\t\t\terrors[index] = error;\n\t\t\t\t} else {\n\t\t\t\t\tresults[index] = result;\n\t\t\t\t\terrors[index] = null;\n\t\t\t\t}\n\n\t\t\t\tif (++doneCount === list.length) {\n\t\t\t\t\treturn callback(didErrorOccur ? errors : null, results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate call<F extends Function>(fun: F, that: any, ...args: any[]): void {\n\t\ttry {\n\t\t\tfun.apply(that, args);\n\t\t} catch (e) {\n\t\t\targs[args.length - 1](e);\n\t\t}\n\t}\n\n\tprivate cmdTraversal(folderQuery: IFolderQuery, onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgressMessage) => void, cb: (err?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder.fsPath;\n\t\tconst isMac = platform.isMacintosh;\n\t\tlet cmd: childProcess.ChildProcess;\n\t\tconst killCmd = () => cmd && cmd.kill();\n\t\tkillCmds.add(killCmd);\n\n\t\tlet done = (err?: Error) => {\n\t\t\tkillCmds.delete(killCmd);\n\t\t\tdone = () => { };\n\t\t\tcb(err);\n\t\t};\n\t\tlet leftover = '';\n\t\tconst tree = this.initDirectoryTree();\n\n\t\tlet noSiblingsClauses: boolean;\n\t\tconst ripgrep = spawnRipgrepCmd(this.config, folderQuery, this.config.includePattern, this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.expression);\n\t\tcmd = ripgrep.cmd;\n\t\tnoSiblingsClauses = !Object.keys(ripgrep.siblingClauses).length;\n\n\t\tconst escapedArgs = ripgrep.rgArgs.args\n\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t.join(' ');\n\n\t\tlet rgCmd = `${ripgrep.rgDiskPath} ${escapedArgs}\\n - cwd: ${ripgrep.cwd}`;\n\t\tif (ripgrep.rgArgs.siblingClauses) {\n\t\t\trgCmd += `\\n - Sibling clauses: ${JSON.stringify(ripgrep.rgArgs.siblingClauses)}`;\n\t\t}\n\t\tonMessage({ message: rgCmd });\n\n\t\tthis.cmdResultCount = 0;\n\t\tthis.collectStdout(cmd, 'utf8', onMessage, (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tdone(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.isLimitHit) {\n\t\t\t\tdone();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\tconst normalized = leftover + (isMac ? normalization.normalizeNFC(stdout || '') : stdout);\n\t\t\tconst relativeFiles = normalized.split('\\n');\n\n\t\t\tif (last) {\n\t\t\t\tconst n = relativeFiles.length;\n\t\t\t\trelativeFiles[n - 1] = relativeFiles[n - 1].trim();\n\t\t\t\tif (!relativeFiles[n - 1]) {\n\t\t\t\t\trelativeFiles.pop();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tleftover = relativeFiles.pop() || '';\n\t\t\t}\n\n\t\t\tif (relativeFiles.length && relativeFiles[0].indexOf('\\n') !== -1) {\n\t\t\t\tdone(new Error('Splitting up files failed'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.cmdResultCount += relativeFiles.length;\n\n\t\t\tif (noSiblingsClauses) {\n\t\t\t\tfor (const relativePath of relativeFiles) {\n\t\t\t\t\tthis.matchFile(onResult, { base: rootFolder, relativePath, searchPath: this.getSearchPath(folderQuery, relativePath) });\n\t\t\t\t\tif (this.isLimitHit) {\n\t\t\t\t\t\tkillCmd();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (last || this.isLimitHit) {\n\t\t\t\t\tdone();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TODO: Optimize siblings clauses with ripgrep here.\n\t\t\tthis.addDirectoryEntries(folderQuery, tree, rootFolder, relativeFiles, onResult);\n\n\t\t\tif (last) {\n\t\t\t\tthis.matchDirectoryTree(tree, rootFolder, onResult);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\tspawnFindCmd(folderQuery: IFolderQuery) {\n\t\tconst excludePattern = this.folderExcludePatterns.get(folderQuery.folder.fsPath)!;\n\t\tconst basenames = excludePattern.getBasenameTerms();\n\t\tconst pathTerms = excludePattern.getPathTerms();\n\t\tconst args = ['-L', '.'];\n\t\tif (basenames.length || pathTerms.length) {\n\t\t\targs.push('-not', '(', '(');\n\t\t\tfor (const basename of basenames) {\n\t\t\t\targs.push('-name', basename);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\tfor (const path of pathTerms) {\n\t\t\t\targs.push('-path', path);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\targs.pop();\n\t\t\targs.push(')', '-prune', ')');\n\t\t}\n\t\targs.push('-type', 'f');\n\t\treturn childProcess.spawn('find', args, { cwd: folderQuery.folder.fsPath });\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\treadStdout(cmd: childProcess.ChildProcess, encoding: BufferEncoding, cb: (err: Error | null, stdout?: string) => void): void {\n\t\tlet all = '';\n\t\tthis.collectStdout(cmd, encoding, () => { }, (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tcb(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tall += stdout;\n\t\t\tif (last) {\n\t\t\t\tcb(null, all);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate collectStdout(cmd: childProcess.ChildProcess, encoding: BufferEncoding, onMessage: (message: IProgressMessage) => void, cb: (err: Error | null, stdout?: string, last?: boolean) => void): void {\n\t\tlet onData = (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err || last) {\n\t\t\t\tonData = () => { };\n\n\t\t\t\tif (this.cmdSW) {\n\t\t\t\t\tthis.cmdSW.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb(err, stdout, last);\n\t\t};\n\n\t\tlet gotData = false;\n\t\tif (cmd.stdout) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tthis.forwardData(cmd.stdout, encoding, onData);\n\t\t\tcmd.stdout.once('data', () => gotData = true);\n\t\t} else {\n\t\t\tonMessage({ message: 'stdout is null' });\n\t\t}\n\n\t\tlet stderr: Buffer[];\n\t\tif (cmd.stderr) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tstderr = this.collectData(cmd.stderr);\n\t\t} else {\n\t\t\tonMessage({ message: 'stderr is null' });\n\t\t}\n\n\t\tcmd.on('error', (err: Error) => {\n\t\t\tonData(err);\n\t\t});\n\n\t\tcmd.on('close', (code: number) => {\n\t\t\t// ripgrep returns code=1 when no results are found\n\t\t\tlet stderrText: string;\n\t\t\tif (!gotData && (stderrText = this.decodeData(stderr, encoding)) && rgErrorMsgForDisplay(stderrText)) {\n\t\t\t\tonData(new Error(`command failed with error code ${code}: ${this.decodeData(stderr, encoding)}`));\n\t\t\t} else {\n\t\t\t\tif (this.exists && code === 0) {\n\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t}\n\t\t\t\tonData(null, '', true);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate forwardData(stream: Readable, encoding: BufferEncoding, cb: (err: Error | null, stdout?: string) => void): StringDecoder {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tcb(null, decoder.write(data));\n\t\t});\n\t\treturn decoder;\n\t}\n\n\tprivate collectData(stream: Readable): Buffer[] {\n\t\tconst buffers: Buffer[] = [];\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tbuffers.push(data);\n\t\t});\n\t\treturn buffers;\n\t}\n\n\tprivate decodeData(buffers: Buffer[], encoding: BufferEncoding): string {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\treturn buffers.map(buffer => decoder.write(buffer)).join('');\n\t}\n\n\tprivate initDirectoryTree(): IDirectoryTree {\n\t\tconst tree: IDirectoryTree = {\n\t\t\trootEntries: [],\n\t\t\tpathToEntries: Object.create(null)\n\t\t};\n\t\ttree.pathToEntries['.'] = tree.rootEntries;\n\t\treturn tree;\n\t}\n\n\tprivate addDirectoryEntries(folderQuery: IFolderQuery, { pathToEntries }: IDirectoryTree, base: string, relativeFiles: string[], onResult: (result: IRawFileMatch) => void) {\n\t\t// Support relative paths to files from a root resource (ignores excludes)\n\t\tif (relativeFiles.indexOf(this.filePattern) !== -1) {\n\t\t\tthis.matchFile(onResult, {\n\t\t\t\tbase,\n\t\t\t\trelativePath: this.filePattern,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, this.filePattern)\n\t\t\t});\n\t\t}\n\n\t\tconst add = (relativePath: string) => {\n\t\t\tconst basename = path.basename(relativePath);\n\t\t\tconst dirname = path.dirname(relativePath);\n\t\t\tlet entries = pathToEntries[dirname];\n\t\t\tif (!entries) {\n\t\t\t\tentries = pathToEntries[dirname] = [];\n\t\t\t\tadd(dirname);\n\t\t\t}\n\t\t\tentries.push({\n\t\t\t\tbase,\n\t\t\t\trelativePath,\n\t\t\t\tbasename,\n\t\t\t\tsearchPath: this.getSearchPath(folderQuery, relativePath),\n\t\t\t});\n\t\t};\n\t\trelativeFiles.forEach(add);\n\t}\n\n\tprivate matchDirectoryTree({ rootEntries, pathToEntries }: IDirectoryTree, rootFolder: string, onResult: (result: IRawFileMatch) => void) {\n\t\tconst self = this;\n\t\tconst excludePattern = this.folderExcludePatterns.get(rootFolder)!;\n\t\tconst filePattern = this.filePattern;\n\t\tfunction matchDirectory(entries: IDirectoryEntry[]) {\n\t\t\tself.directoriesWalked++;\n\t\t\tconst hasSibling = glob.hasSiblingFn(() => entries.map(entry => entry.basename));\n\t\t\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\t\t\tconst entry = entries[i];\n\t\t\t\tconst { relativePath, basename } = entry;\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what she\n\t\t\t\t// is searching for and we want to include the result in that case anyway\n\t\t\t\tif (excludePattern.test(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst sub = pathToEntries[relativePath];\n\t\t\t\tif (sub) {\n\t\t\t\t\tmatchDirectory(sub);\n\t\t\t\t} else {\n\t\t\t\t\tself.filesWalked++;\n\t\t\t\t\tif (relativePath === filePattern) {\n\t\t\t\t\t\tcontinue; // ignore file if its path matches with the file pattern because that is already matched above\n\t\t\t\t\t}\n\n\t\t\t\t\tself.matchFile(onResult, entry);\n\t\t\t\t}\n\n\t\t\t\tif (self.isLimitHit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchDirectory(rootEntries);\n\t}\n\n\tgetStats(): ISearchEngineStats {\n\t\treturn {\n\t\t\tcmdTime: this.cmdSW!.elapsed(),\n\t\t\tfileWalkTime: this.fileWalkSW!.elapsed(),\n\t\t\tdirectoriesWalked: this.directoriesWalked,\n\t\t\tfilesWalked: this.filesWalked,\n\t\t\tcmdResultCount: this.cmdResultCount\n\t\t};\n\t}\n\n\tprivate doWalk(folderQuery: IFolderQuery, relativeParentPath: string, files: string[], onResult: (result: IRawFileMatch) => void, done: (error?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder;\n\n\t\t// Execute tasks on each file in parallel to optimize throughput\n\t\tconst hasSibling = glob.hasSiblingFn(() => files);\n\t\tthis.parallel(files, (file: string, clb: (error: Error | null, _?: any) => void): void => {\n\n\t\t\t// Check canceled\n\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Check exclude pattern\n\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t// to ignore filtering by siblings because the user seems to know what she\n\t\t\t// is searching for and we want to include the result in that case anyway\n\t\t\tconst currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(path.sep) : file;\n\t\t\tif (this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.test(currentRelativePath, file, this.config.filePattern !== file ? hasSibling : undefined)) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Use lstat to detect links\n\t\t\tconst currentAbsolutePath = [rootFolder.fsPath, currentRelativePath].join(path.sep);\n\t\t\tfs.lstat(currentAbsolutePath, (error, lstat) => {\n\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\treturn clb(null);\n\t\t\t\t}\n\n\t\t\t\t// If the path is a link, we must instead use fs.stat() to find out if the\n\t\t\t\t// link is a directory or not because lstat will always return the stat of\n\t\t\t\t// the link which is always a file.\n\t\t\t\tthis.statLinkIfNeeded(currentAbsolutePath, lstat, (error, stat) => {\n\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Directory: Follow directories\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\tthis.directoriesWalked++;\n\n\t\t\t\t\t\t// to really prevent loops with links we need to resolve the real path of them\n\t\t\t\t\t\treturn this.realPathIfNeeded(currentAbsolutePath, lstat, (error, realpath) => {\n\t\t\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trealpath = realpath || '';\n\t\t\t\t\t\t\tif (this.walkedPaths[realpath]) {\n\t\t\t\t\t\t\t\treturn clb(null); // escape when there are cycles (can happen with symlinks)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.walkedPaths[realpath] = true; // remember as walked\n\n\t\t\t\t\t\t\t// Continue walking\n\t\t\t\t\t\t\treturn readdir(currentAbsolutePath).then(children => {\n\t\t\t\t\t\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.doWalk(folderQuery, currentRelativePath, children, onResult, err => clb(err || null));\n\t\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\t\tclb(null);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.filesWalked++;\n\t\t\t\t\t\tif (currentRelativePath === this.filePattern) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.maxFilesize && types.isNumber(stat.size) && stat.size > this.maxFilesize) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if max file size is hit\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.matchFile(onResult, {\n\t\t\t\t\t\t\tbase: rootFolder.fsPath,\n\t\t\t\t\t\t\trelativePath: currentRelativePath,\n\t\t\t\t\t\t\tsearchPath: this.getSearchPath(folderQuery, currentRelativePath),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unwind\n\t\t\t\t\treturn clb(null, undefined);\n\t\t\t\t});\n\t\t\t});\n\t\t}, (error: Array<Error | null> | null): void => {\n\t\t\tconst filteredErrors = error ? arrays.coalesce(error) : error; // find any error by removing null values first\n\t\t\treturn done(filteredErrors && filteredErrors.length > 0 ? filteredErrors[0] : undefined);\n\t\t});\n\t}\n\n\tprivate matchFile(onResult: (result: IRawFileMatch) => void, candidate: IRawFileMatch): void {\n\t\tif (this.isFileMatch(candidate) && (!this.includePattern || this.includePattern(candidate.relativePath, path.basename(candidate.relativePath)))) {\n\t\t\tthis.resultCount++;\n\n\t\t\tif (this.exists || (this.maxResults && this.resultCount > this.maxResults)) {\n\t\t\t\tthis.isLimitHit = true;\n\t\t\t}\n\n\t\t\tif (!this.isLimitHit) {\n\t\t\t\tonResult(candidate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isFileMatch(candidate: IRawFileMatch): boolean {\n\t\t// Check for search pattern\n\t\tif (this.filePattern) {\n\t\t\tif (this.filePattern === '*') {\n\t\t\t\treturn true; // support the all-matching wildcard\n\t\t\t}\n\n\t\t\tif (this.normalizedFilePatternLowercase) {\n\t\t\t\treturn isFilePatternMatch(candidate, this.normalizedFilePatternLowercase);\n\t\t\t}\n\t\t}\n\n\t\t// No patterns means we match all\n\t\treturn true;\n\t}\n\n\tprivate statLinkIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, stat: fs.Stats) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.stat(path, clb); // stat the target the link points to\n\t\t}\n\n\t\treturn clb(null, lstat); // not a link, so the stat is already ok for us\n\t}\n\n\tprivate realPathIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, realpath?: string) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.realpath(path, (error, realpath) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn clb(error);\n\t\t\t\t}\n\n\t\t\t\treturn clb(null, realpath);\n\t\t\t});\n\t\t}\n\n\t\treturn clb(null, path);\n\t}\n\n\t/**\n\t * If we're searching for files in multiple workspace folders, then better prepend the\n\t * name of the workspace folder to the path of the file. This way we'll be able to\n\t * better filter files that are all on the top of a workspace folder and have all the\n\t * same name. A typical example are `package.json` or `README.md` files.\n\t */\n\tprivate getSearchPath(folderQuery: IFolderQuery, relativePath: string): string {\n\t\tif (folderQuery.folderName) {\n\t\t\treturn path.join(folderQuery.folderName, relativePath);\n\t\t}\n\t\treturn relativePath;\n\t}\n}\n\nexport class Engine implements ISearchEngine<IRawFileMatch> {\n\tprivate folderQueries: IFolderQuery[];\n\tprivate extraFiles: URI[];\n\tprivate walker: FileWalker;\n\n\tconstructor(config: IFileQuery) {\n\t\tthis.folderQueries = config.folderQueries;\n\t\tthis.extraFiles = config.extraFileResources || [];\n\n\t\tthis.walker = new FileWalker(config);\n\t}\n\n\tsearch(onResult: (result: IRawFileMatch) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void): void {\n\t\tthis.walker.walk(this.folderQueries, this.extraFiles, onResult, onProgress, (err: Error | null, isLimitHit: boolean) => {\n\t\t\tdone(err, {\n\t\t\t\tlimitHit: isLimitHit,\n\t\t\t\tstats: this.walker.getStats(),\n\t\t\t\tmessages: [],\n\t\t\t});\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.walker.cancel();\n\t}\n}\n\n/**\n * This class exists to provide one interface on top of two ParsedExpressions, one for absolute expressions and one for relative expressions.\n * The absolute and relative expressions don't \"have\" to be kept separate, but this keeps us from having to path.join every single\n * file searched, it's only used for a text search with a searchPath\n */\nclass AbsoluteAndRelativeParsedExpression {\n\tprivate absoluteParsedExpr: glob.ParsedExpression | undefined;\n\tprivate relativeParsedExpr: glob.ParsedExpression | undefined;\n\n\tconstructor(public expression: glob.IExpression, private root: string) {\n\t\tthis.init(expression);\n\t}\n\n\t/**\n\t * Split the IExpression into its absolute and relative components, and glob.parse them separately.\n\t */\n\tprivate init(expr: glob.IExpression): void {\n\t\tlet absoluteGlobExpr: glob.IExpression | undefined;\n\t\tlet relativeGlobExpr: glob.IExpression | undefined;\n\t\tObject.keys(expr)\n\t\t\t.filter(key => expr[key])\n\t\t\t.forEach(key => {\n\t\t\t\tif (path.isAbsolute(key)) {\n\t\t\t\t\tabsoluteGlobExpr = absoluteGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\tabsoluteGlobExpr[key] = expr[key];\n\t\t\t\t} else {\n\t\t\t\t\trelativeGlobExpr = relativeGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\trelativeGlobExpr[key] = expr[key];\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.absoluteParsedExpr = absoluteGlobExpr && glob.parse(absoluteGlobExpr, { trimForExclusions: true });\n\t\tthis.relativeParsedExpr = relativeGlobExpr && glob.parse(relativeGlobExpr, { trimForExclusions: true });\n\t}\n\n\ttest(_path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | Promise<string | null> | undefined | null {\n\t\treturn (this.relativeParsedExpr && this.relativeParsedExpr(_path, basename, hasSibling)) ||\n\t\t\t(this.absoluteParsedExpr && this.absoluteParsedExpr(path.join(this.root, _path), basename, hasSibling));\n\t}\n\n\tgetBasenameTerms(): string[] {\n\t\tconst basenameTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn basenameTerms;\n\t}\n\n\tgetPathTerms(): string[] {\n\t\tconst pathTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn pathTerms;\n\t}\n}\n\nexport function rgErrorMsgForDisplay(msg: string): string | undefined {\n\tconst lines = msg.trim().split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (firstLine.startsWith('Error parsing regex')) {\n\t\treturn firstLine;\n\t}\n\n\tif (firstLine.startsWith('regex parse error')) {\n\t\treturn strings.uppercaseFirstLetter(lines[lines.length - 1].trim());\n\t}\n\n\tif (firstLine.startsWith('error parsing glob') ||\n\t\tfirstLine.startsWith('unsupported encoding')) {\n\t\t// Uppercase first letter\n\t\treturn firstLine.charAt(0).toUpperCase() + firstLine.substr(1);\n\t}\n\n\tif (firstLine === `Literal '\\\\n' not allowed.`) {\n\t\t// I won't localize this because none of the Ripgrep error messages are localized\n\t\treturn `Literal '\\\\n' currently not supported`;\n\t}\n\n\tif (firstLine.startsWith('Literal ')) {\n\t\t// Other unsupported chars\n\t\treturn firstLine;\n\t}\n\n\treturn undefined;\n}\n"]}