{"version":3,"file":"ripgrepSearchProvider.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/search/node/ripgrepSearchProvider.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAShG,MAAa,qBAAqB;QAGjC,YAAoB,aAA4B;YAA5B,kBAAa,GAAb,aAAa,CAAe;YAFxC,eAAU,GAAiC,IAAI,GAAG,EAAE,CAAC;YAG5D,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;QAC5C,CAAC;QAED,wBAAwB,CAAC,KAAsB,EAAE,OAA0B,EAAE,QAAoC,EAAE,KAAwB;YAC1I,MAAM,MAAM,GAAG,IAAI,iDAAuB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAC/D,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,iBAAO,CAAC,QAAQ,EAAE;gBAC/C,4LAA4L;gBAC5L,yIAAyI;gBACzI,MAAM,iBAAiB,mCAAQ,OAAO,KAAE,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,iBAAO,CAAC,IAAI,EAAE,CAAC,GAAE,CAAC;gBAChG,MAAM,kBAAkB,GAAG,IAAI,mBAAQ,CAAmB,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,MAAM,iCAAM,IAAI,KAAE,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,IAAG,CAAC,CAAC;gBACvJ,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC,CAAC;aAC5H;iBAAM;gBACN,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;aACxG;QACF,CAAC;QAEO,KAAK,CAAC,SAAS,CAAI,KAAwB,EAAE,EAA4C;YAChG,MAAM,MAAM,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC;YACxC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YAC5B,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACtC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAE/B,OAAO,MAAM,CAAC;QACf,CAAC;QAEO,OAAO;YACd,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;QACpD,CAAC;KACD;IAhCD,sDAgCC;IAED,SAAS,iBAAiB,CAAC,KAAwB;QAClD,MAAM,WAAW,GAAG,IAAI,sCAAuB,EAAE,CAAC;QAClD,KAAK,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC;QAE1D,OAAO,WAAW,CAAC;IACpB,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource, CancellationToken } from 'vs/base/common/cancellation';\nimport { OutputChannel } from 'vs/workbench/services/search/node/ripgrepSearchUtils';\nimport { RipgrepTextSearchEngine } from 'vs/workbench/services/search/node/ripgrepTextSearchEngine';\nimport { TextSearchProvider, TextSearchComplete, TextSearchResult, TextSearchQuery, TextSearchOptions } from 'vs/workbench/services/search/common/searchExtTypes';\nimport { Progress } from 'vs/platform/progress/common/progress';\nimport { Schemas } from 'vs/base/common/network';\n\nexport class RipgrepSearchProvider implements TextSearchProvider {\n\tprivate inProgress: Set<CancellationTokenSource> = new Set();\n\n\tconstructor(private outputChannel: OutputChannel) {\n\t\tprocess.once('exit', () => this.dispose());\n\t}\n\n\tprovideTextSearchResults(query: TextSearchQuery, options: TextSearchOptions, progress: Progress<TextSearchResult>, token: CancellationToken): Promise<TextSearchComplete> {\n\t\tconst engine = new RipgrepTextSearchEngine(this.outputChannel);\n\t\tif (options.folder.scheme === Schemas.userData) {\n\t\t\t// Ripgrep search engine can only provide file-scheme results, but we want to use it to search some schemes that are backed by the filesystem, but with some other provider as the frontend,\n\t\t\t// case in point vscode-userdata. In these cases we translate the query to a file, and translate the results back to the frontend scheme.\n\t\t\tconst translatedOptions = { ...options, folder: options.folder.with({ scheme: Schemas.file }) };\n\t\t\tconst progressTranslator = new Progress<TextSearchResult>(data => progress.report({ ...data, uri: data.uri.with({ scheme: options.folder.scheme }) }));\n\t\t\treturn this.withToken(token, token => engine.provideTextSearchResults(query, translatedOptions, progressTranslator, token));\n\t\t} else {\n\t\t\treturn this.withToken(token, token => engine.provideTextSearchResults(query, options, progress, token));\n\t\t}\n\t}\n\n\tprivate async withToken<T>(token: CancellationToken, fn: (token: CancellationToken) => Promise<T>): Promise<T> {\n\t\tconst merged = mergedTokenSource(token);\n\t\tthis.inProgress.add(merged);\n\t\tconst result = await fn(merged.token);\n\t\tthis.inProgress.delete(merged);\n\n\t\treturn result;\n\t}\n\n\tprivate dispose() {\n\t\tthis.inProgress.forEach(engine => engine.cancel());\n\t}\n}\n\nfunction mergedTokenSource(token: CancellationToken): CancellationTokenSource {\n\tconst tokenSource = new CancellationTokenSource();\n\ttoken.onCancellationRequested(() => tokenSource.cancel());\n\n\treturn tokenSource;\n}\n"]}