{"version":3,"file":"textMateScopeMatcher.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/themes/common/textMateScopeMatcher.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nexport interface MatcherWithPriority<T> {\n\tmatcher: Matcher<T>;\n\tpriority: -1 | 0 | 1;\n}\n\nexport interface Matcher<T> {\n\t(matcherInput: T): number;\n}\n\nexport function createMatchers<T>(selector: string, matchesName: (names: string[], matcherInput: T) => number, results: MatcherWithPriority<T>[]): void {\n\tconst tokenizer = newTokenizer(selector);\n\tlet token = tokenizer.next();\n\twhile (token !== null) {\n\t\tlet priority: -1 | 0 | 1 = 0;\n\t\tif (token.length === 2 && token.charAt(1) === ':') {\n\t\t\tswitch (token.charAt(0)) {\n\t\t\t\tcase 'R': priority = 1; break;\n\t\t\t\tcase 'L': priority = -1; break;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(`Unknown priority ${token} in scope selector`);\n\t\t\t}\n\t\t\ttoken = tokenizer.next();\n\t\t}\n\t\tlet matcher = parseConjunction();\n\t\tif (matcher) {\n\t\t\tresults.push({ matcher, priority });\n\t\t}\n\t\tif (token !== ',') {\n\t\t\tbreak;\n\t\t}\n\t\ttoken = tokenizer.next();\n\t}\n\n\tfunction parseOperand(): Matcher<T> | null {\n\t\tif (token === '-') {\n\t\t\ttoken = tokenizer.next();\n\t\t\tconst expressionToNegate = parseOperand();\n\t\t\tif (!expressionToNegate) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn matcherInput => {\n\t\t\t\tconst score = expressionToNegate(matcherInput);\n\t\t\t\treturn score < 0 ? 0 : -1;\n\t\t\t};\n\t\t}\n\t\tif (token === '(') {\n\t\t\ttoken = tokenizer.next();\n\t\t\tconst expressionInParents = parseInnerExpression();\n\t\t\tif (token === ')') {\n\t\t\t\ttoken = tokenizer.next();\n\t\t\t}\n\t\t\treturn expressionInParents;\n\t\t}\n\t\tif (isIdentifier(token)) {\n\t\t\tconst identifiers: string[] = [];\n\t\t\tdo {\n\t\t\t\tidentifiers.push(token);\n\t\t\t\ttoken = tokenizer.next();\n\t\t\t} while (isIdentifier(token));\n\t\t\treturn matcherInput => matchesName(identifiers, matcherInput);\n\t\t}\n\t\treturn null;\n\t}\n\tfunction parseConjunction(): Matcher<T> | null {\n\t\tlet matcher = parseOperand();\n\t\tif (!matcher) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matchers: Matcher<T>[] = [];\n\t\twhile (matcher) {\n\t\t\tmatchers.push(matcher);\n\t\t\tmatcher = parseOperand();\n\t\t}\n\t\treturn matcherInput => {  // and\n\t\t\tlet min = matchers[0](matcherInput);\n\t\t\tfor (let i = 1; min >= 0 && i < matchers.length; i++) {\n\t\t\t\tmin = Math.min(min, matchers[i](matcherInput));\n\t\t\t}\n\t\t\treturn min;\n\t\t};\n\t}\n\tfunction parseInnerExpression(): Matcher<T> | null {\n\t\tlet matcher = parseConjunction();\n\t\tif (!matcher) {\n\t\t\treturn null;\n\t\t}\n\t\tconst matchers: Matcher<T>[] = [];\n\t\twhile (matcher) {\n\t\t\tmatchers.push(matcher);\n\t\t\tif (token === '|' || token === ',') {\n\t\t\t\tdo {\n\t\t\t\t\ttoken = tokenizer.next();\n\t\t\t\t} while (token === '|' || token === ','); // ignore subsequent commas\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatcher = parseConjunction();\n\t\t}\n\t\treturn matcherInput => {  // or\n\t\t\tlet max = matchers[0](matcherInput);\n\t\t\tfor (let i = 1; i < matchers.length; i++) {\n\t\t\t\tmax = Math.max(max, matchers[i](matcherInput));\n\t\t\t}\n\t\t\treturn max;\n\t\t};\n\t}\n}\n\nfunction isIdentifier(token: string | null): token is string {\n\treturn !!token && !!token.match(/[\\w\\.:]+/);\n}\n\nfunction newTokenizer(input: string): { next: () => string | null } {\n\tlet regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n\tlet match = regex.exec(input);\n\treturn {\n\t\tnext: () => {\n\t\t\tif (!match) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst res = match[0];\n\t\t\tmatch = regex.exec(input);\n\t\t\treturn res;\n\t\t}\n\t};\n}\n"]}