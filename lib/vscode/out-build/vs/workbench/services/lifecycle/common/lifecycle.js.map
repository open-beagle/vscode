{"version":3,"file":"lifecycle.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/lifecycle/common/lifecycle.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAKnF,QAAA,iBAAiB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAoB,kBAAkB,CAAC,CAAC;IAqDxF,IAAkB,cAajB;IAbD,WAAkB,cAAc;QAE/B,uBAAuB;QACvB,qDAAS,CAAA;QAET,0BAA0B;QAC1B,mDAAQ,CAAA;QAER,yBAAyB;QACzB,uDAAU,CAAA;QAEV,6CAA6C;QAC7C,mDAAQ,CAAA;IACT,CAAC,EAbiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAa/B;IAED,IAAkB,WAIjB;IAJD,WAAkB,WAAW;QAC5B,uDAAa,CAAA;QACb,iEAAkB,CAAA;QAClB,iEAAkB,CAAA;IACnB,CAAC,EAJiB,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAI5B;IAED,SAAgB,mBAAmB,CAAC,WAAwB;QAC3D,QAAQ,WAAW,EAAE;YACpB,sBAA0B,CAAC,CAAC,OAAO,WAAW,CAAC;YAC/C,2BAA+B,CAAC,CAAC,OAAO,gBAAgB,CAAC;YACzD,2BAA+B,CAAC,CAAC,OAAO,gBAAgB,CAAC;SACzD;IACF,CAAC;IAND,kDAMC;IAED,IAAkB,cA6BjB;IA7BD,WAAkB,cAAc;QAE/B;;;;;WAKG;QACH,2DAAY,CAAA;QAEZ;;;;;WAKG;QACH,qDAAS,CAAA;QAET;;;WAGG;QACH,2DAAY,CAAA;QAEZ;;;WAGG;QACH,+DAAc,CAAA;IACf,CAAC,EA7BiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QA6B/B;IAED,SAAgB,sBAAsB,CAAC,KAAqB;QAC3D,QAAQ,KAAK,EAAE;YACd,qBAA4B,CAAC,CAAC,OAAO,UAAU,CAAC;YAChD,kBAAyB,CAAC,CAAC,OAAO,OAAO,CAAC;YAC1C,qBAA4B,CAAC,CAAC,OAAO,UAAU,CAAC;YAChD,uBAA8B,CAAC,CAAC,OAAO,YAAY,CAAC;SACpD;IACF,CAAC;IAPD,wDAOC;IA8DY,QAAA,oBAAoB,GAAsB;QAEtD,aAAa,EAAE,SAAS;QAExB,gBAAgB,EAAE,aAAK,CAAC,IAAI;QAC5B,cAAc,EAAE,aAAK,CAAC,IAAI;QAC1B,aAAa,EAAE,aAAK,CAAC,IAAI;QAEzB,KAAK,kBAAyB;QAC9B,WAAW,mBAAuB;QAElC,KAAK,CAAC,IAAI,KAAK,CAAC;QAChB,QAAQ,KAAK,CAAC;KACd,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nexport const ILifecycleService = createDecorator<ILifecycleService>('lifecycleService');\n\n/**\n * An event that is send out when the window is about to close. Clients have a chance to veto\n * the closing by either calling veto with a boolean \"true\" directly or with a promise that\n * resolves to a boolean. Returning a promise is useful in cases of long running operations\n * on shutdown.\n *\n * Note: It is absolutely important to avoid long running promises if possible. Please try hard\n * to return a boolean directly. Returning a promise has quite an impact on the shutdown sequence!\n */\nexport interface BeforeShutdownEvent {\n\n\t/**\n\t * Allows to veto the shutdown. The veto can be a long running operation but it\n\t * will block the application from closing.\n\t *\n\t * @param id to identify the veto operation in case it takes very long or never\n\t * completes.\n\t */\n\tveto(value: boolean | Promise<boolean>, id: string): void;\n\n\t/**\n\t * The reason why the application will be shutting down.\n\t */\n\treadonly reason: ShutdownReason;\n}\n\n/**\n * An event that is send out when the window closes. Clients have a chance to join the closing\n * by providing a promise from the join method. Returning a promise is useful in cases of long\n * running operations on shutdown.\n *\n * Note: It is absolutely important to avoid long running promises if possible. Please try hard\n * to return a boolean directly. Returning a promise has quite an impact on the shutdown sequence!\n */\nexport interface WillShutdownEvent {\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t *\n\t * @param id to identify the join operation in case it takes very long or never\n\t * completes.\n\t */\n\tjoin(promise: Promise<void>, id: string): void;\n\n\t/**\n\t * The reason why the application is shutting down.\n\t */\n\treadonly reason: ShutdownReason;\n}\n\nexport const enum ShutdownReason {\n\n\t/** Window is closed */\n\tCLOSE = 1,\n\n\t/** Application is quit */\n\tQUIT = 2,\n\n\t/** Window is reloaded */\n\tRELOAD = 3,\n\n\t/** Other configuration loaded into window */\n\tLOAD = 4\n}\n\nexport const enum StartupKind {\n\tNewWindow = 1,\n\tReloadedWindow = 3,\n\tReopenedWindow = 4,\n}\n\nexport function StartupKindToString(startupKind: StartupKind): string {\n\tswitch (startupKind) {\n\t\tcase StartupKind.NewWindow: return 'NewWindow';\n\t\tcase StartupKind.ReloadedWindow: return 'ReloadedWindow';\n\t\tcase StartupKind.ReopenedWindow: return 'ReopenedWindow';\n\t}\n}\n\nexport const enum LifecyclePhase {\n\n\t/**\n\t * The first phase signals that we are about to startup getting ready.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use `Restored` phase.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and the window is about to restore its UI state.\n\t *\n\t * Note: doing work in this phase blocks an editor from showing to\n\t * the user, so please rather consider to use `Restored` phase.\n\t */\n\tReady = 2,\n\n\t/**\n\t * Views, panels and editors have restored. Editors are given a bit of\n\t * time to restore their contents.\n\t */\n\tRestored = 3,\n\n\t/**\n\t * The last phase after views, panels and editors have restored and\n\t * some time has passed (2-5 seconds).\n\t */\n\tEventually = 4\n}\n\nexport function LifecyclePhaseToString(phase: LifecyclePhase) {\n\tswitch (phase) {\n\t\tcase LifecyclePhase.Starting: return 'Starting';\n\t\tcase LifecyclePhase.Ready: return 'Ready';\n\t\tcase LifecyclePhase.Restored: return 'Restored';\n\t\tcase LifecyclePhase.Eventually: return 'Eventually';\n\t}\n}\n\n/**\n * A lifecycle service informs about lifecycle events of the\n * application, such as shutdown.\n */\nexport interface ILifecycleService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Value indicates how this window got loaded.\n\t */\n\treadonly startupKind: StartupKind;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecyclePhase;\n\n\t/**\n\t * Fired before shutdown happens. Allows listeners to veto against the\n\t * shutdown to prevent it from happening.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onBeforeShutdown: Event<BeforeShutdownEvent>;\n\n\t/**\n\t * Fired when no client is preventing the shutdown from happening (from `onBeforeShutdown`).\n\t *\n\t * This event can be joined with a long running operation via `WillShutdownEvent#join()` to\n\t * handle long running shutdown operations.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onWillShutdown: Event<WillShutdownEvent>;\n\n\t/**\n\t * Fired when the shutdown is about to happen after long running shutdown operations\n\t * have finished (from `onWillShutdown`).\n\t *\n\t * This event should be used to dispose resources.\n\t */\n\treadonly onDidShutdown: Event<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecyclePhase): Promise<void>;\n\n\t/**\n\t * Triggers a shutdown of the workbench. Depending on native or web, this can have\n\t * different implementations and behaviour.\n\t *\n\t * **Note:** this should normally not be called. See related methods in `IHostService`\n\t * and `INativeHostService` to close a window or quit the application.\n\t */\n\tshutdown(): void;\n}\n\nexport const NullLifecycleService: ILifecycleService = {\n\n\t_serviceBrand: undefined,\n\n\tonBeforeShutdown: Event.None,\n\tonWillShutdown: Event.None,\n\tonDidShutdown: Event.None,\n\n\tphase: LifecyclePhase.Restored,\n\tstartupKind: StartupKind.NewWindow,\n\n\tasync when() { },\n\tshutdown() { }\n};\n"]}