{"version":3,"file":"uriIdentityService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/uriIdentity/common/uriIdentityService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IUriIdentityService } from 'vs/workbench/services/uriIdentity/common/uriIdentity';\nimport { URI } from 'vs/base/common/uri';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { IFileService, FileSystemProviderCapabilities, IFileSystemProviderCapabilitiesChangeEvent, IFileSystemProviderRegistrationEvent } from 'vs/platform/files/common/files';\nimport { ExtUri, IExtUri, normalizePath } from 'vs/base/common/resources';\nimport { SkipList } from 'vs/base/common/skipList';\nimport { Event } from 'vs/base/common/event';\nimport { DisposableStore } from 'vs/base/common/lifecycle';\n\nclass Entry {\n\tstatic _clock = 0;\n\ttime: number = Entry._clock++;\n\tconstructor(readonly uri: URI) { }\n\ttouch() {\n\t\tthis.time = Entry._clock++;\n\t\treturn this;\n\t}\n}\n\nexport class UriIdentityService implements IUriIdentityService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\treadonly extUri: IExtUri;\n\n\tprivate readonly _dispooables = new DisposableStore();\n\tprivate readonly _canonicalUris: SkipList<URI, Entry>;\n\tprivate readonly _limit = 2 ** 16;\n\n\tconstructor(@IFileService private readonly _fileService: IFileService) {\n\n\t\tconst schemeIgnoresPathCasingCache = new Map<string, boolean>();\n\n\t\t// assume path casing matters unless the file system provider spec'ed the opposite.\n\t\t// for all other cases path casing matters, e.g for\n\t\t// * virtual documents\n\t\t// * in-memory uris\n\t\t// * all kind of \"private\" schemes\n\t\tconst ignorePathCasing = (uri: URI): boolean => {\n\t\t\tlet ignorePathCasing = schemeIgnoresPathCasingCache.get(uri.scheme);\n\t\t\tif (ignorePathCasing === undefined) {\n\t\t\t\t// retrieve once and then case per scheme until a change happens\n\t\t\t\tignorePathCasing = _fileService.canHandleResource(uri) && !this._fileService.hasCapability(uri, FileSystemProviderCapabilities.PathCaseSensitive);\n\t\t\t\tschemeIgnoresPathCasingCache.set(uri.scheme, ignorePathCasing);\n\t\t\t}\n\t\t\treturn ignorePathCasing;\n\t\t};\n\t\tthis._dispooables.add(Event.any<IFileSystemProviderCapabilitiesChangeEvent | IFileSystemProviderRegistrationEvent>(\n\t\t\t_fileService.onDidChangeFileSystemProviderRegistrations,\n\t\t\t_fileService.onDidChangeFileSystemProviderCapabilities\n\t\t)(e => {\n\t\t\t// remove from cache\n\t\t\tschemeIgnoresPathCasingCache.delete(e.scheme);\n\t\t}));\n\n\t\tthis.extUri = new ExtUri(ignorePathCasing);\n\t\tthis._canonicalUris = new SkipList((a, b) => this.extUri.compare(a, b, true), this._limit);\n\t}\n\n\tdispose(): void {\n\t\tthis._dispooables.dispose();\n\t\tthis._canonicalUris.clear();\n\t}\n\n\tasCanonicalUri(uri: URI): URI {\n\n\t\t// (1) normalize URI\n\t\tif (this._fileService.canHandleResource(uri)) {\n\t\t\turi = normalizePath(uri);\n\t\t}\n\n\t\t// (2) find the uri in its canonical form or use this uri to define it\n\t\tlet item = this._canonicalUris.get(uri);\n\t\tif (item) {\n\t\t\treturn item.touch().uri.with({ fragment: uri.fragment });\n\t\t}\n\n\t\t// this uri is first and defines the canonical form\n\t\tthis._canonicalUris.set(uri, new Entry(uri));\n\t\tthis._checkTrim();\n\n\t\treturn uri;\n\t}\n\n\tprivate _checkTrim(): void {\n\t\tif (this._canonicalUris.size < this._limit) {\n\t\t\treturn;\n\t\t}\n\n\t\t// get all entries, sort by touch (MRU) and re-initalize\n\t\t// the uri cache and the entry clock. this is an expensive\n\t\t// operation and should happen rarely\n\t\tconst entries = [...this._canonicalUris.entries()].sort((a, b) => {\n\t\t\tif (a[1].touch < b[1].touch) {\n\t\t\t\treturn 1;\n\t\t\t} else if (a[1].touch > b[1].touch) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tEntry._clock = 0;\n\t\tthis._canonicalUris.clear();\n\t\tconst newSize = this._limit * 0.5;\n\t\tfor (let i = 0; i < newSize; i++) {\n\t\t\tthis._canonicalUris.set(entries[i][0], entries[i][1].touch());\n\t\t}\n\t}\n}\n\nregisterSingleton(IUriIdentityService, UriIdentityService, true);\n"]}