{"version":3,"file":"commandService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/services/commands/common/commandService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { ICommandService, ICommandEvent, CommandsRegistry } from 'vs/platform/commands/common/commands';\nimport { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { timeout } from 'vs/base/common/async';\n\nexport class CommandService extends Disposable implements ICommandService {\n\n\tdeclare readonly _serviceBrand: undefined;\n\n\tprivate _extensionHostIsReady: boolean = false;\n\tprivate _starActivation: Promise<void> | null;\n\n\tprivate readonly _onWillExecuteCommand: Emitter<ICommandEvent> = this._register(new Emitter<ICommandEvent>());\n\tpublic readonly onWillExecuteCommand: Event<ICommandEvent> = this._onWillExecuteCommand.event;\n\n\tprivate readonly _onDidExecuteCommand: Emitter<ICommandEvent> = new Emitter<ICommandEvent>();\n\tpublic readonly onDidExecuteCommand: Event<ICommandEvent> = this._onDidExecuteCommand.event;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._extensionService.whenInstalledExtensionsRegistered().then(value => this._extensionHostIsReady = value);\n\t\tthis._starActivation = null;\n\t}\n\n\tprivate _activateStar(): Promise<void> {\n\t\tif (!this._starActivation) {\n\t\t\t// wait for * activation, limited to at most 30s\n\t\t\tthis._starActivation = Promise.race<any>([\n\t\t\t\tthis._extensionService.activateByEvent(`*`),\n\t\t\t\ttimeout(30000)\n\t\t\t]);\n\t\t}\n\t\treturn this._starActivation;\n\t}\n\n\texecuteCommand<T>(id: string, ...args: any[]): Promise<T> {\n\t\tthis._logService.trace('CommandService#executeCommand', id);\n\n\t\t// we always send an activation event, but\n\t\t// we don't wait for it when the extension\n\t\t// host didn't yet start and the command is already registered\n\n\t\tconst activation: Promise<any> = this._extensionService.activateByEvent(`onCommand:${id}`);\n\t\tconst commandIsRegistered = !!CommandsRegistry.getCommand(id);\n\n\t\tif (!this._extensionHostIsReady && commandIsRegistered) {\n\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t} else {\n\t\t\tlet waitFor = activation;\n\t\t\tif (!commandIsRegistered) {\n\t\t\t\twaitFor = Promise.all([\n\t\t\t\t\tactivation,\n\t\t\t\t\tPromise.race<any>([\n\t\t\t\t\t\t// race * activation against command registration\n\t\t\t\t\t\tthis._activateStar(),\n\t\t\t\t\t\tEvent.toPromise(Event.filter(CommandsRegistry.onDidRegisterCommand, e => e === id))\n\t\t\t\t\t]),\n\t\t\t\t]);\n\t\t\t}\n\t\t\treturn waitFor.then(_ => this._tryExecuteCommand(id, args));\n\t\t}\n\t}\n\n\tprivate _tryExecuteCommand(id: string, args: any[]): Promise<any> {\n\t\tconst command = CommandsRegistry.getCommand(id);\n\t\tif (!command) {\n\t\t\treturn Promise.reject(new Error(`command '${id}' not found`));\n\t\t}\n\t\ttry {\n\t\t\tthis._onWillExecuteCommand.fire({ commandId: id, args });\n\t\t\tconst result = this._instantiationService.invokeFunction(command.handler, ...args);\n\t\t\tthis._onDidExecuteCommand.fire({ commandId: id, args });\n\t\t\treturn Promise.resolve(result);\n\t\t} catch (err) {\n\t\t\treturn Promise.reject(err);\n\t\t}\n\t}\n}\n\nregisterSingleton(ICommandService, CommandService, true);\n"]}