{"version":3,"sources":["vs/workbench/contrib/debug/common/abstractDebugAdapter.ts"],"names":[],"mappings":"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","file":"abstractDebugAdapter.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDebugAdapter } from 'vs/workbench/contrib/debug/common/debug';\nimport { timeout } from 'vs/base/common/async';\nimport { localize } from 'vs/nls';\n\n/**\n * Abstract implementation of the low level API for a debug adapter.\n * Missing is how this API communicates with the debug adapter.\n */\nexport abstract class AbstractDebugAdapter implements IDebugAdapter {\n\tprivate sequence: number;\n\tprivate pendingRequests = new Map<number, (e: DebugProtocol.Response) => void>();\n\tprivate requestCallback: ((request: DebugProtocol.Request) => void) | undefined;\n\tprivate eventCallback: ((request: DebugProtocol.Event) => void) | undefined;\n\tprivate messageCallback: ((message: DebugProtocol.ProtocolMessage) => void) | undefined;\n\tprivate queue: DebugProtocol.ProtocolMessage[] = [];\n\tprotected readonly _onError = new Emitter<Error>();\n\tprotected readonly _onExit = new Emitter<number | null>();\n\n\tconstructor() {\n\t\tthis.sequence = 1;\n\t}\n\n\tabstract startSession(): Promise<void>;\n\n\tabstract stopSession(): Promise<void>;\n\n\tabstract sendMessage(message: DebugProtocol.ProtocolMessage): void;\n\n\tget onError(): Event<Error> {\n\t\treturn this._onError.event;\n\t}\n\n\tget onExit(): Event<number | null> {\n\t\treturn this._onExit.event;\n\t}\n\n\tonMessage(callback: (message: DebugProtocol.ProtocolMessage) => void): void {\n\t\tif (this.messageCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Message' callback`));\n\t\t}\n\t\tthis.messageCallback = callback;\n\t}\n\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void {\n\t\tif (this.eventCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Event' callback`));\n\t\t}\n\t\tthis.eventCallback = callback;\n\t}\n\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void {\n\t\tif (this.requestCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Request' callback`));\n\t\t}\n\t\tthis.requestCallback = callback;\n\t}\n\n\tsendResponse(response: DebugProtocol.Response): void {\n\t\tif (response.seq > 0) {\n\t\t\tthis._onError.fire(new Error(`attempt to send more than one response for command ${response.command}`));\n\t\t} else {\n\t\t\tthis.internalSend('response', response);\n\t\t}\n\t}\n\n\tsendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timeout?: number): number {\n\t\tconst request: any = {\n\t\t\tcommand: command\n\t\t};\n\t\tif (args && Object.keys(args).length > 0) {\n\t\t\trequest.arguments = args;\n\t\t}\n\t\tthis.internalSend('request', request);\n\t\tif (typeof timeout === 'number') {\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\tconst clb = this.pendingRequests.get(request.seq);\n\t\t\t\tif (clb) {\n\t\t\t\t\tthis.pendingRequests.delete(request.seq);\n\t\t\t\t\tconst err: DebugProtocol.Response = {\n\t\t\t\t\t\ttype: 'response',\n\t\t\t\t\t\tseq: 0,\n\t\t\t\t\t\trequest_seq: request.seq,\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\tmessage: localize('timeout', \"Timeout after {0} ms for '{1}'\", timeout, command)\n\t\t\t\t\t};\n\t\t\t\t\tclb(err);\n\t\t\t\t}\n\t\t\t}, timeout);\n\t\t}\n\t\tif (clb) {\n\t\t\t// store callback for this request\n\t\t\tthis.pendingRequests.set(request.seq, clb);\n\t\t}\n\n\t\treturn request.seq;\n\t}\n\n\tacceptMessage(message: DebugProtocol.ProtocolMessage): void {\n\t\tif (this.messageCallback) {\n\t\t\tthis.messageCallback(message);\n\t\t} else {\n\t\t\tthis.queue.push(message);\n\t\t\tif (this.queue.length === 1) {\n\t\t\t\t// first item = need to start processing loop\n\t\t\t\tthis.processQueue();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether we should insert a timeout between processing messageA\n\t * and messageB. Artificially queueing protocol messages guarantees that any\n\t * microtasks for previous message finish before next message is processed.\n\t * This is essential ordering when using promises anywhere along the call path.\n\t *\n\t * For example, take the following, where `chooseAndSendGreeting` returns\n\t * a person name and then emits a greeting event:\n\t *\n\t * ```\n\t * let person: string;\n\t * adapter.onGreeting(() => console.log('hello', person));\n\t * person = await adapter.chooseAndSendGreeting();\n\t * ```\n\t *\n\t * Because the event is dispatched synchronously, it may fire before person\n\t * is assigned if they're processed in the same task. Inserting a task\n\t * boundary avoids this issue.\n\t */\n\tprotected needsTaskBoundaryBetween(messageA: DebugProtocol.ProtocolMessage, messageB: DebugProtocol.ProtocolMessage) {\n\t\treturn messageA.type !== 'event' || messageB.type !== 'event';\n\t}\n\n\t/**\n\t * Reads and dispatches items from the queue until it is empty.\n\t */\n\tprivate async processQueue() {\n\t\tlet message: DebugProtocol.ProtocolMessage | undefined;\n\t\twhile (this.queue.length) {\n\t\t\tif (!message || this.needsTaskBoundaryBetween(this.queue[0], message)) {\n\t\t\t\tawait timeout(0);\n\t\t\t}\n\n\t\t\tmessage = this.queue.shift();\n\t\t\tif (!message) {\n\t\t\t\treturn; // may have been disposed of\n\t\t\t}\n\n\t\t\tswitch (message.type) {\n\t\t\t\tcase 'event':\n\t\t\t\t\tif (this.eventCallback) {\n\t\t\t\t\t\tthis.eventCallback(<DebugProtocol.Event>message);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'request':\n\t\t\t\t\tif (this.requestCallback) {\n\t\t\t\t\t\tthis.requestCallback(<DebugProtocol.Request>message);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'response':\n\t\t\t\t\tconst response = <DebugProtocol.Response>message;\n\t\t\t\t\tconst clb = this.pendingRequests.get(response.request_seq);\n\t\t\t\t\tif (clb) {\n\t\t\t\t\t\tthis.pendingRequests.delete(response.request_seq);\n\t\t\t\t\t\tclb(response);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate internalSend(typ: 'request' | 'response' | 'event', message: DebugProtocol.ProtocolMessage): void {\n\t\tmessage.type = typ;\n\t\tmessage.seq = this.sequence++;\n\t\tthis.sendMessage(message);\n\t}\n\n\tprotected async cancelPendingRequests(): Promise<void> {\n\t\tif (this.pendingRequests.size === 0) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst pending = new Map<number, (e: DebugProtocol.Response) => void>();\n\t\tthis.pendingRequests.forEach((value, key) => pending.set(key, value));\n\t\tawait timeout(500);\n\t\tpending.forEach((callback, request_seq) => {\n\t\t\tconst err: DebugProtocol.Response = {\n\t\t\t\ttype: 'response',\n\t\t\t\tseq: 0,\n\t\t\t\trequest_seq,\n\t\t\t\tsuccess: false,\n\t\t\t\tcommand: 'canceled',\n\t\t\t\tmessage: 'canceled'\n\t\t\t};\n\t\t\tcallback(err);\n\t\t\tthis.pendingRequests.delete(request_seq);\n\t\t});\n\t}\n\n\tgetPendingRequestIds(): number[] {\n\t\treturn Array.from(this.pendingRequests.keys());\n\t}\n\n\tdispose(): void {\n\t\tthis.queue = [];\n\t}\n}\n"]}