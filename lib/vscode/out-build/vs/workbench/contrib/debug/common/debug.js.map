{"version":3,"sources":["vs/workbench/contrib/debug/common/debug.ts"],"names":[],"mappings":"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","file":"debug.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { URI as uri } from 'vs/base/common/uri';\nimport severity from 'vs/base/common/severity';\nimport { Event } from 'vs/base/common/event';\nimport { IJSONSchemaSnippet } from 'vs/base/common/jsonSchema';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { ITextModel as EditorIModel } from 'vs/editor/common/model';\nimport { IEditorPane, ITextEditorPane } from 'vs/workbench/common/editor';\nimport { Position, IPosition } from 'vs/editor/common/core/position';\nimport { Source } from 'vs/workbench/contrib/debug/common/debugSource';\nimport { Range, IRange } from 'vs/editor/common/core/range';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { TaskIdentifier } from 'vs/workbench/contrib/tasks/common/tasks';\nimport { ConfigurationTarget } from 'vs/platform/configuration/common/configuration';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { DebugConfigurationProviderTriggerKind } from 'vs/workbench/api/common/extHostTypes';\nimport { DebugCompoundRoot } from 'vs/workbench/contrib/debug/common/debugCompoundRoot';\nimport { IAction } from 'vs/base/common/actions';\nimport { ITelemetryEndpoint } from 'vs/platform/telemetry/common/telemetry';\n\nexport const VIEWLET_ID = 'workbench.view.debug';\n\nexport const VARIABLES_VIEW_ID = 'workbench.debug.variablesView';\nexport const WATCH_VIEW_ID = 'workbench.debug.watchExpressionsView';\nexport const CALLSTACK_VIEW_ID = 'workbench.debug.callStackView';\nexport const LOADED_SCRIPTS_VIEW_ID = 'workbench.debug.loadedScriptsView';\nexport const BREAKPOINTS_VIEW_ID = 'workbench.debug.breakPointsView';\nexport const DEBUG_PANEL_ID = 'workbench.panel.repl';\nexport const REPL_VIEW_ID = 'workbench.panel.repl.view';\nexport const DEBUG_SERVICE_ID = 'debugService';\nexport const CONTEXT_DEBUG_TYPE = new RawContextKey<string>('debugType', undefined, { type: 'string', description: nls.localize('debugType', \"Debug type of the active debug session. For example 'python'.\") });\nexport const CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey<string>('debugConfigurationType', undefined, { type: 'string', description: nls.localize('debugConfigurationType', \"Debug type of the selected launch configuration. For example 'python'.\") });\nexport const CONTEXT_DEBUG_STATE = new RawContextKey<string>('debugState', 'inactive', { type: 'string', description: nls.localize('debugState', \"State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'.\") });\nexport const CONTEXT_DEBUG_UX_KEY = 'debugUx';\nexport const CONTEXT_DEBUG_UX = new RawContextKey<string>(CONTEXT_DEBUG_UX_KEY, 'default', { type: 'string', description: nls.localize('debugUX', \"Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet.\") });\nexport const CONTEXT_IN_DEBUG_MODE = new RawContextKey<boolean>('inDebugMode', false, { type: 'boolean', description: nls.localize('inDebugMode', \"True when debugging, false otherwise.\") });\nexport const CONTEXT_IN_DEBUG_REPL = new RawContextKey<boolean>('inDebugRepl', false, { type: 'boolean', description: nls.localize('inDebugRepl', \"True when focus is in the debug console, false otherwise.\") });\nexport const CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey<boolean>('breakpointWidgetVisible', false, { type: 'boolean', description: nls.localize('breakpointWidgetVisibile', \"True when breakpoint editor zone widget is visible, false otherwise.\") });\nexport const CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey<boolean>('inBreakpointWidget', false, { type: 'boolean', description: nls.localize('inBreakpointWidget', \"True when focus is in the breakpoint editor zone widget, false otherwise.\") });\nexport const CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey<boolean>('breakpointsFocused', true, { type: 'boolean', description: nls.localize('breakpointsFocused', \"True when the BREAKPOINTS view is focused, false otherwise.\") });\nexport const CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey<boolean>('watchExpressionsFocused', true, { type: 'boolean', description: nls.localize('watchExpressionsFocused', \"True when the WATCH view is focused, false otherwsie.\") });\nexport const CONTEXT_WATCH_EXPRESSIONS_EXIST = new RawContextKey<boolean>('watchExpressionsExist', false, { type: 'boolean', description: nls.localize('watchExpressionsExist', \"True when at least one watch expression exists, false otherwise.\") });\nexport const CONTEXT_VARIABLES_FOCUSED = new RawContextKey<boolean>('variablesFocused', true, { type: 'boolean', description: nls.localize('variablesFocused', \"True when the VARIABLES views is focused, false otherwsie\") });\nexport const CONTEXT_EXPRESSION_SELECTED = new RawContextKey<boolean>('expressionSelected', false, { type: 'boolean', description: nls.localize('expressionSelected', \"True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise.\") });\nexport const CONTEXT_BREAKPOINT_INPUT_FOCUSED = new RawContextKey<boolean>('breakpointInputFocused', false, { type: 'boolean', description: nls.localize('breakpointInputFocused', \"True when the input box has focus in the BREAKPOINTS view.\") });\nexport const CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey<string>('callStackItemType', undefined, { type: 'string', description: nls.localize('callStackItemType', \"Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'\") });\nexport const CONTEXT_CALLSTACK_SESSION_IS_ATTACH = new RawContextKey<boolean>('callStackSessionIsAttach', false, { type: 'boolean', description: nls.localize('callStackSessionIsAttach', \"True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_ITEM_STOPPED = new RawContextKey<boolean>('callStackItemStopped', false, { type: 'boolean', description: nls.localize('callStackItemStopped', \"True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD = new RawContextKey<boolean>('callStackSessionHasOneThread', false, { type: 'boolean', description: nls.localize('callStackSessionHasOneThread', \"True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view.\") });\nexport const CONTEXT_WATCH_ITEM_TYPE = new RawContextKey<string>('watchItemType', undefined, { type: 'string', description: nls.localize('watchItemType', \"Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'\") });\nexport const CONTEXT_BREAKPOINT_ITEM_TYPE = new RawContextKey<string>('breakpointItemType', undefined, { type: 'string', description: nls.localize('breakpointItemType', \"Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'\") });\nexport const CONTEXT_BREAKPOINT_ACCESS_TYPE = new RawContextKey<string>('breakpointAccessType', undefined, { type: 'string', description: nls.localize('breakpointAccessType', \"Represents the access type of the focused data breakpoint in the BREAKPOINTS view. For example: 'read', 'readWrite', 'write'\") });\nexport const CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = new RawContextKey<boolean>('breakpointSupportsCondition', false, { type: 'boolean', description: nls.localize('breakpointSupportsCondition', \"True when the focused breakpoint supports conditions.\") });\nexport const CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey<boolean>('loadedScriptsSupported', false, { type: 'boolean', description: nls.localize('loadedScriptsSupported', \"True when the focused sessions supports the LOADED SCRIPTS view\") });\nexport const CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey<string>('loadedScriptsItemType', undefined, { type: 'string', description: nls.localize('loadedScriptsItemType', \"Represents the item type of the focused element in the LOADED SCRIPTS view.\") });\nexport const CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey<boolean>('focusedSessionIsAttach', false, { type: 'boolean', description: nls.localize('focusedSessionIsAttach', \"True when the focused session is 'attach'.\") });\nexport const CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey<boolean>('stepBackSupported', false, { type: 'boolean', description: nls.localize('stepBackSupported', \"True when the focused session supports 'stepBack' requests.\") });\nexport const CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey<boolean>('restartFrameSupported', false, { type: 'boolean', description: nls.localize('restartFrameSupported', \"True when the focused session supports 'restartFrame' requests.\") });\nexport const CONTEXT_STACK_FRAME_SUPPORTS_RESTART = new RawContextKey<boolean>('stackFrameSupportsRestart', false, { type: 'boolean', description: nls.localize('stackFrameSupportsRestart', \"True when the focused stack frame suppots 'restartFrame'.\") });\nexport const CONTEXT_JUMP_TO_CURSOR_SUPPORTED = new RawContextKey<boolean>('jumpToCursorSupported', false, { type: 'boolean', description: nls.localize('jumpToCursorSupported', \"True when the focused session supports 'jumpToCursor' request.\") });\nexport const CONTEXT_STEP_INTO_TARGETS_SUPPORTED = new RawContextKey<boolean>('stepIntoTargetsSupported', false, { type: 'boolean', description: nls.localize('stepIntoTargetsSupported', \"True when the focused session supports 'stepIntoTargets' request.\") });\nexport const CONTEXT_BREAKPOINTS_EXIST = new RawContextKey<boolean>('breakpointsExist', false, { type: 'boolean', description: nls.localize('breakpointsExist', \"True when at least one breakpoint exists.\") });\nexport const CONTEXT_DEBUGGERS_AVAILABLE = new RawContextKey<boolean>('debuggersAvailable', false, { type: 'boolean', description: nls.localize('debuggersAvailable', \"True when there is at least one debug extensions active.\") });\nexport const CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = new RawContextKey<string>('debugProtocolVariableMenuContext', undefined, { type: 'string', description: nls.localize('debugProtocolVariableMenuContext', \"Represents the context the debug adapter sets on the focused variable in the VARIABLES view.\") });\nexport const CONTEXT_SET_VARIABLE_SUPPORTED = new RawContextKey<boolean>('debugSetVariableSupported', false, { type: 'boolean', description: nls.localize('debugSetVariableSupported', \"True when the focused session supports 'setVariable' request.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED = new RawContextKey<boolean>('breakWhenValueChangesSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueChangesSupported', \"True when the focused session supports to break when value changes.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED = new RawContextKey<boolean>('breakWhenValueIsAccessedSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueIsAccessedSupported', \"True when the focused breakpoint supports to break when value is accessed.\") });\nexport const CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED = new RawContextKey<boolean>('breakWhenValueIsReadSupported', false, { type: 'boolean', description: nls.localize('breakWhenValueIsReadSupported', \"True when the focused breakpoint supports to break when value is read.\") });\nexport const CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = new RawContextKey<boolean>('terminateDebuggeeSupported', false, { type: 'boolean', description: nls.localize('terminateDebuggeeSupported', \"True when the focused session supports the terminate debuggee capability.\") });\nexport const CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = new RawContextKey<boolean>('variableEvaluateNamePresent', false, { type: 'boolean', description: nls.localize('variableEvaluateNamePresent', \"True when the focused variable has an 'evalauteName' field set\") });\nexport const CONTEXT_EXCEPTION_WIDGET_VISIBLE = new RawContextKey<boolean>('exceptionWidgetVisible', false, { type: 'boolean', description: nls.localize('exceptionWidgetVisible', \"True when the exception widget is visible.\") });\nexport const CONTEXT_MULTI_SESSION_REPL = new RawContextKey<boolean>('multiSessionRepl', false, { type: 'boolean', description: nls.localize('multiSessionRepl', \"True when there is more than 1 debug console.\") });\nexport const CONTEXT_MULTI_SESSION_DEBUG = new RawContextKey<boolean>('multiSessionDebug', false, { type: 'boolean', description: nls.localize('multiSessionDebug', \"True when there is more than 1 active debug session.\") });\n\nexport const EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';\nexport const BREAKPOINT_EDITOR_CONTRIBUTION_ID = 'editor.contrib.breakpoint';\nexport const DEBUG_SCHEME = 'debug';\nexport const INTERNAL_CONSOLE_OPTIONS_SCHEMA = {\n\tenum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],\n\tdefault: 'openOnFirstSessionStart',\n\tdescription: nls.localize('internalConsoleOptions', \"Controls when the internal debug console should open.\")\n};\n\n// raw\n\nexport interface IRawModelUpdate {\n\tsessionId: string;\n\tthreads: DebugProtocol.Thread[];\n\tstoppedDetails?: IRawStoppedDetails;\n}\n\nexport interface IRawStoppedDetails {\n\treason?: string;\n\tdescription?: string;\n\tthreadId?: number;\n\ttext?: string;\n\ttotalFrames?: number;\n\tallThreadsStopped?: boolean;\n\tframesErrorMessage?: string;\n}\n\n// model\n\nexport interface ITreeElement {\n\tgetId(): string;\n}\n\nexport interface IReplElement extends ITreeElement {\n\ttoString(includeSource?: boolean): string;\n\treadonly sourceData?: IReplElementSource;\n}\n\nexport interface IReplElementSource {\n\treadonly source: Source;\n\treadonly lineNumber: number;\n\treadonly column: number;\n}\n\nexport interface IExpressionContainer extends ITreeElement {\n\treadonly hasChildren: boolean;\n\tgetChildren(): Promise<IExpression[]>;\n\treadonly reference?: number;\n\treadonly value: string;\n\treadonly type?: string;\n\tvalueChanged?: boolean;\n}\n\nexport interface IExpression extends IExpressionContainer {\n\tname: string;\n}\n\nexport interface IDebugger {\n\tcreateDebugAdapter(session: IDebugSession): Promise<IDebugAdapter>;\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n\tgetCustomTelemetryEndpoint(): ITelemetryEndpoint | undefined;\n}\n\nexport const enum State {\n\tInactive,\n\tInitializing,\n\tStopped,\n\tRunning\n}\n\nexport function getStateLabel(state: State): string {\n\tswitch (state) {\n\t\tcase State.Initializing: return 'initializing';\n\t\tcase State.Stopped: return 'stopped';\n\t\tcase State.Running: return 'running';\n\t\tdefault: return 'inactive';\n\t}\n}\n\nexport interface AdapterEndEvent {\n\terror?: Error;\n\tsessionLengthInSeconds: number;\n\temittedStopped: boolean;\n}\n\nexport interface LoadedSourceEvent {\n\treason: 'new' | 'changed' | 'removed';\n\tsource: Source;\n}\n\nexport type IDebugSessionReplMode = 'separate' | 'mergeWithParent';\n\nexport interface IDebugSessionOptions {\n\tnoDebug?: boolean;\n\tparentSession?: IDebugSession;\n\trepl?: IDebugSessionReplMode;\n\tcompoundRoot?: DebugCompoundRoot;\n\tcompact?: boolean;\n}\n\nexport interface IDataBreakpointInfoResponse {\n\tdataId: string | null;\n\tdescription: string;\n\tcanPersist?: boolean,\n\taccessTypes?: DebugProtocol.DataBreakpointAccessType[];\n}\n\nexport interface IDebugSession extends ITreeElement {\n\n\treadonly configuration: IConfig;\n\treadonly unresolvedConfiguration: IConfig | undefined;\n\treadonly state: State;\n\treadonly root: IWorkspaceFolder | undefined;\n\treadonly parentSession: IDebugSession | undefined;\n\treadonly subId: string | undefined;\n\treadonly compact: boolean;\n\treadonly compoundRoot: DebugCompoundRoot | undefined;\n\treadonly name: string;\n\n\tsetSubId(subId: string | undefined): void;\n\n\tsetName(name: string): void;\n\treadonly onDidChangeName: Event<string>;\n\tgetLabel(): string;\n\n\tgetSourceForUri(modelUri: uri): Source | undefined;\n\tgetSource(raw?: DebugProtocol.Source): Source;\n\n\tsetConfiguration(configuration: { resolved: IConfig, unresolved: IConfig | undefined }): void;\n\trawUpdate(data: IRawModelUpdate): void;\n\n\tgetThread(threadId: number): IThread | undefined;\n\tgetAllThreads(): IThread[];\n\tclearThreads(removeThreads: boolean, reference?: number): void;\n\n\tgetReplElements(): IReplElement[];\n\thasSeparateRepl(): boolean;\n\tremoveReplExpressions(): void;\n\taddReplExpression(stackFrame: IStackFrame | undefined, name: string): Promise<void>;\n\tappendToRepl(data: string | IExpression, severity: severity, source?: IReplElementSource): void;\n\tlogToRepl(sev: severity, args: any[], frame?: { uri: uri, line: number, column: number }): void;\n\n\t// session events\n\treadonly onDidEndAdapter: Event<AdapterEndEvent | undefined>;\n\treadonly onDidChangeState: Event<void>;\n\treadonly onDidChangeReplElements: Event<void>;\n\n\t// DA capabilities\n\treadonly capabilities: DebugProtocol.Capabilities;\n\n\t// DAP events\n\n\treadonly onDidLoadedSource: Event<LoadedSourceEvent>;\n\treadonly onDidCustomEvent: Event<DebugProtocol.Event>;\n\treadonly onDidProgressStart: Event<DebugProtocol.ProgressStartEvent>;\n\treadonly onDidProgressUpdate: Event<DebugProtocol.ProgressUpdateEvent>;\n\treadonly onDidProgressEnd: Event<DebugProtocol.ProgressEndEvent>;\n\n\t// DAP request\n\n\tinitialize(dbgr: IDebugger): Promise<void>;\n\tlaunchOrAttach(config: IConfig): Promise<void>;\n\trestart(): Promise<void>;\n\tterminate(restart?: boolean /* false */): Promise<void>;\n\tdisconnect(restart?: boolean /* false */): Promise<void>;\n\n\tsendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;\n\tdataBreakpointInfo(name: string, variablesReference?: number): Promise<IDataBreakpointInfoResponse | undefined>;\n\tsendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;\n\tbreakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]>;\n\tgetDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined;\n\n\tstackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse | undefined>;\n\texceptionInfo(threadId: number): Promise<IExceptionInfo | undefined>;\n\tscopes(frameId: number, threadId: number): Promise<DebugProtocol.ScopesResponse | undefined>;\n\tvariables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named' | undefined, start: number | undefined, count: number | undefined): Promise<DebugProtocol.VariablesResponse | undefined>;\n\tevaluate(expression: string, frameId?: number, context?: string): Promise<DebugProtocol.EvaluateResponse | undefined>;\n\tcustomRequest(request: string, args: any): Promise<DebugProtocol.Response | undefined>;\n\tcancel(progressId: string): Promise<DebugProtocol.CancelResponse | undefined>;\n\n\trestartFrame(frameId: number, threadId: number): Promise<void>;\n\tnext(threadId: number): Promise<void>;\n\tstepIn(threadId: number, targetId?: number): Promise<void>;\n\tstepInTargets(frameId: number): Promise<{ id: number, label: string }[] | undefined>;\n\tstepOut(threadId: number): Promise<void>;\n\tstepBack(threadId: number): Promise<void>;\n\tcontinue(threadId: number): Promise<void>;\n\treverseContinue(threadId: number): Promise<void>;\n\tpause(threadId: number): Promise<void>;\n\tterminateThreads(threadIds: number[]): Promise<void>;\n\n\tcompletions(frameId: number | undefined, threadId: number, text: string, position: Position, overwriteBefore: number, token: CancellationToken): Promise<DebugProtocol.CompletionsResponse | undefined>;\n\tsetVariable(variablesReference: number | undefined, name: string, value: string): Promise<DebugProtocol.SetVariableResponse | undefined>;\n\tloadSource(resource: uri): Promise<DebugProtocol.SourceResponse | undefined>;\n\tgetLoadedSources(): Promise<Source[]>;\n\n\tgotoTargets(source: DebugProtocol.Source, line: number, column?: number): Promise<DebugProtocol.GotoTargetsResponse | undefined>;\n\tgoto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse | undefined>;\n}\n\nexport interface IThread extends ITreeElement {\n\n\t/**\n\t * Process the thread belongs to\n\t */\n\treadonly session: IDebugSession;\n\n\t/**\n\t * Id of the thread generated by the debug adapter backend.\n\t */\n\treadonly threadId: number;\n\n\t/**\n\t * Name of the thread.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Information about the current thread stop event. Undefined if thread is not stopped.\n\t */\n\treadonly stoppedDetails: IRawStoppedDetails | undefined;\n\n\t/**\n\t * Information about the exception if an 'exception' stopped event raised and DA supports the 'exceptionInfo' request, otherwise undefined.\n\t */\n\treadonly exceptionInfo: Promise<IExceptionInfo | undefined>;\n\n\treadonly stateLabel: string;\n\n\t/**\n\t * Gets the callstack if it has already been received from the debug\n\t * adapter.\n\t */\n\tgetCallStack(): ReadonlyArray<IStackFrame>;\n\n\n\t/**\n\t * Gets the top stack frame that is not hidden if the callstack has already been received from the debug adapter\n\t */\n\tgetTopStackFrame(): IStackFrame | undefined;\n\n\t/**\n\t * Invalidates the callstack cache\n\t */\n\tclearCallStack(): void;\n\n\t/**\n\t * Indicates whether this thread is stopped. The callstack for stopped\n\t * threads can be retrieved from the debug adapter.\n\t */\n\treadonly stopped: boolean;\n\n\tnext(): Promise<any>;\n\tstepIn(): Promise<any>;\n\tstepOut(): Promise<any>;\n\tstepBack(): Promise<any>;\n\tcontinue(): Promise<any>;\n\tpause(): Promise<any>;\n\tterminate(): Promise<any>;\n\treverseContinue(): Promise<any>;\n}\n\nexport interface IScope extends IExpressionContainer {\n\treadonly name: string;\n\treadonly expensive: boolean;\n\treadonly range?: IRange;\n\treadonly hasChildren: boolean;\n}\n\nexport interface IStackFrame extends ITreeElement {\n\treadonly thread: IThread;\n\treadonly name: string;\n\treadonly presentationHint: string | undefined;\n\treadonly frameId: number;\n\treadonly range: IRange;\n\treadonly source: Source;\n\treadonly canRestart: boolean;\n\tgetScopes(): Promise<IScope[]>;\n\tgetMostSpecificScopes(range: IRange): Promise<ReadonlyArray<IScope>>;\n\tforgetScopes(): void;\n\trestart(): Promise<any>;\n\ttoString(): string;\n\topenInEditor(editorService: IEditorService, preserveFocus?: boolean, sideBySide?: boolean): Promise<ITextEditorPane | undefined>;\n\tequals(other: IStackFrame): boolean;\n}\n\nexport interface IEnablement extends ITreeElement {\n\treadonly enabled: boolean;\n}\n\nexport interface IBreakpointData {\n\treadonly id?: string;\n\treadonly lineNumber: number;\n\treadonly column?: number;\n\treadonly enabled?: boolean;\n\treadonly condition?: string;\n\treadonly logMessage?: string;\n\treadonly hitCondition?: string;\n}\n\nexport interface IBreakpointUpdateData {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly lineNumber?: number;\n\treadonly column?: number;\n}\n\nexport interface IBaseBreakpoint extends IEnablement {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly verified: boolean;\n\treadonly supported: boolean;\n\treadonly message?: string;\n\treadonly sessionsThatVerified: string[];\n\tgetIdFromAdapter(sessionId: string): number | undefined;\n}\n\nexport interface IBreakpoint extends IBaseBreakpoint {\n\treadonly uri: uri;\n\treadonly lineNumber: number;\n\treadonly endLineNumber?: number;\n\treadonly column?: number;\n\treadonly endColumn?: number;\n\treadonly adapterData: any;\n\treadonly sessionAgnosticData: { lineNumber: number, column: number | undefined };\n}\n\nexport interface IFunctionBreakpoint extends IBaseBreakpoint {\n\treadonly name: string;\n}\n\nexport interface IExceptionBreakpoint extends IBaseBreakpoint {\n\treadonly filter: string;\n\treadonly label: string;\n\treadonly description: string | undefined;\n}\n\nexport interface IDataBreakpoint extends IBaseBreakpoint {\n\treadonly description: string;\n\treadonly dataId: string;\n\treadonly canPersist: boolean;\n\treadonly accessType: DebugProtocol.DataBreakpointAccessType;\n}\n\nexport interface IExceptionInfo {\n\treadonly id?: string;\n\treadonly description?: string;\n\treadonly breakMode: string | null;\n\treadonly details?: DebugProtocol.ExceptionDetails;\n}\n\n// model interfaces\n\nexport interface IViewModel extends ITreeElement {\n\t/**\n\t * Returns the focused debug session or undefined if no session is stopped.\n\t */\n\treadonly focusedSession: IDebugSession | undefined;\n\n\t/**\n\t * Returns the focused thread or undefined if no thread is stopped.\n\t */\n\treadonly focusedThread: IThread | undefined;\n\n\t/**\n\t * Returns the focused stack frame or undefined if there are no stack frames.\n\t */\n\treadonly focusedStackFrame: IStackFrame | undefined;\n\n\tgetSelectedExpression(): IExpression | undefined;\n\tsetSelectedExpression(expression: IExpression | undefined): void;\n\tupdateViews(): void;\n\n\tisMultiSessionView(): boolean;\n\n\tonDidFocusSession: Event<IDebugSession | undefined>;\n\tonDidFocusStackFrame: Event<{ stackFrame: IStackFrame | undefined, explicit: boolean }>;\n\tonDidSelectExpression: Event<IExpression | undefined>;\n\tonWillUpdateViews: Event<void>;\n}\n\nexport interface IEvaluate {\n\tevaluate(session: IDebugSession, stackFrame: IStackFrame, context: string): Promise<void>;\n}\n\nexport interface IDebugModel extends ITreeElement {\n\tgetSession(sessionId: string | undefined, includeInactive?: boolean): IDebugSession | undefined;\n\tgetSessions(includeInactive?: boolean): IDebugSession[];\n\tgetBreakpoints(filter?: { uri?: uri, lineNumber?: number, column?: number, enabledOnly?: boolean }): ReadonlyArray<IBreakpoint>;\n\tareBreakpointsActivated(): boolean;\n\tgetFunctionBreakpoints(): ReadonlyArray<IFunctionBreakpoint>;\n\tgetDataBreakpoints(): ReadonlyArray<IDataBreakpoint>;\n\tgetExceptionBreakpoints(): ReadonlyArray<IExceptionBreakpoint>;\n\tgetWatchExpressions(): ReadonlyArray<IExpression & IEvaluate>;\n\n\tonDidChangeBreakpoints: Event<IBreakpointsChangeEvent | undefined>;\n\tonDidChangeCallStack: Event<void>;\n\tonDidChangeWatchExpressions: Event<IExpression | undefined>;\n}\n\n/**\n * An event describing a change to the set of [breakpoints](#debug.Breakpoint).\n */\nexport interface IBreakpointsChangeEvent {\n\tadded?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint>;\n\tremoved?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint>;\n\tchanged?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint>;\n\tsessionOnly: boolean;\n}\n\n// Debug configuration interfaces\n\nexport interface IDebugConfiguration {\n\tallowBreakpointsEverywhere: boolean;\n\topenDebug: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart' | 'openOnDebugBreak';\n\topenExplorerOnEnd: boolean;\n\tinlineValues: boolean | 'auto';\n\ttoolBarLocation: 'floating' | 'docked' | 'hidden';\n\tshowInStatusBar: 'never' | 'always' | 'onFirstSessionStart';\n\tinternalConsoleOptions: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\textensionHostDebugAdapter: boolean;\n\tenableAllHovers: boolean;\n\tshowSubSessionsInToolBar: boolean;\n\tconsole: {\n\t\tfontSize: number;\n\t\tfontFamily: string;\n\t\tlineHeight: number;\n\t\twordWrap: boolean;\n\t\tcloseOnEnd: boolean;\n\t\tcollapseIdenticalLines: boolean;\n\t\thistorySuggestions: boolean;\n\t};\n\tfocusWindowOnBreak: boolean;\n\tonTaskErrors: 'debugAnyway' | 'showErrors' | 'prompt' | 'abort';\n\tshowBreakpointsInOverviewRuler: boolean;\n\tshowInlineBreakpointCandidates: boolean;\n}\n\nexport interface IGlobalConfig {\n\tversion: string;\n\tcompounds: ICompound[];\n\tconfigurations: IConfig[];\n}\n\nexport interface IEnvConfig {\n\tinternalConsoleOptions?: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\tpreRestartTask?: string | TaskIdentifier;\n\tpostRestartTask?: string | TaskIdentifier;\n\tpreLaunchTask?: string | TaskIdentifier;\n\tpostDebugTask?: string | TaskIdentifier;\n\tdebugServer?: number;\n\tnoDebug?: boolean;\n}\n\nexport interface IConfigPresentation {\n\thidden?: boolean;\n\tgroup?: string;\n\torder?: number;\n}\n\nexport interface IConfig extends IEnvConfig {\n\n\t// fundamental attributes\n\ttype: string;\n\trequest: string;\n\tname: string;\n\tpresentation?: IConfigPresentation;\n\t// platform specifics\n\twindows?: IEnvConfig;\n\tosx?: IEnvConfig;\n\tlinux?: IEnvConfig;\n\n\t// internals\n\t__configurationTarget?: ConfigurationTarget;\n\t__sessionId?: string;\n\t__restart?: any;\n\t__autoAttach?: boolean;\n\tport?: number; // TODO\n}\n\nexport interface ICompound {\n\tname: string;\n\tstopAll?: boolean;\n\tpreLaunchTask?: string | TaskIdentifier;\n\tconfigurations: (string | { name: string, folder: string })[];\n\tpresentation?: IConfigPresentation;\n}\n\nexport interface IDebugAdapter extends IDisposable {\n\treadonly onError: Event<Error>;\n\treadonly onExit: Event<number | null>;\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void;\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void;\n\tstartSession(): Promise<void>;\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void;\n\tsendResponse(response: DebugProtocol.Response): void;\n\tsendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timeout?: number): number;\n\tstopSession(): Promise<void>;\n}\n\nexport interface IDebugAdapterFactory extends ITerminalLauncher {\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter;\n\tsubstituteVariables(folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n}\n\nexport interface IDebugAdapterExecutableOptions {\n\tcwd?: string;\n\tenv?: { [key: string]: string };\n}\n\nexport interface IDebugAdapterExecutable {\n\treadonly type: 'executable';\n\treadonly command: string;\n\treadonly args: string[];\n\treadonly options?: IDebugAdapterExecutableOptions;\n}\n\nexport interface IDebugAdapterServer {\n\treadonly type: 'server';\n\treadonly port: number;\n\treadonly host?: string;\n}\n\nexport interface IDebugAdapterNamedPipeServer {\n\treadonly type: 'pipeServer';\n\treadonly path: string;\n}\n\nexport interface IDebugAdapterInlineImpl extends IDisposable {\n\treadonly onDidSendMessage: Event<DebugProtocol.Message>;\n\thandleMessage(message: DebugProtocol.Message): void;\n}\n\nexport interface IDebugAdapterImpl {\n\treadonly type: 'implementation';\n\treadonly implementation: IDebugAdapterInlineImpl;\n}\n\nexport type IAdapterDescriptor = IDebugAdapterExecutable | IDebugAdapterServer | IDebugAdapterNamedPipeServer | IDebugAdapterImpl;\n\nexport interface IPlatformSpecificAdapterContribution {\n\tprogram?: string;\n\targs?: string[];\n\truntime?: string;\n\truntimeArgs?: string[];\n}\n\nexport interface IDebuggerContribution extends IPlatformSpecificAdapterContribution {\n\ttype: string;\n\tlabel?: string;\n\twin?: IPlatformSpecificAdapterContribution;\n\twinx86?: IPlatformSpecificAdapterContribution;\n\twindows?: IPlatformSpecificAdapterContribution;\n\tosx?: IPlatformSpecificAdapterContribution;\n\tlinux?: IPlatformSpecificAdapterContribution;\n\n\t// internal\n\taiKey?: string;\n\n\t// supported languages\n\tlanguages?: string[];\n\n\t// debug configuration support\n\tconfigurationAttributes?: any;\n\tinitialConfigurations?: any[];\n\tconfigurationSnippets?: IJSONSchemaSnippet[];\n\tvariables?: { [key: string]: string };\n}\n\nexport interface IDebugConfigurationProvider {\n\treadonly type: string;\n\treadonly triggerKind: DebugConfigurationProviderTriggerKind;\n\tresolveDebugConfiguration?(folderUri: uri | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;\n\tresolveDebugConfigurationWithSubstitutedVariables?(folderUri: uri | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;\n\tprovideDebugConfigurations?(folderUri: uri | undefined, token: CancellationToken): Promise<IConfig[]>;\n}\n\nexport interface IDebugAdapterDescriptorFactory {\n\treadonly type: string;\n\tcreateDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor>;\n}\n\nexport interface IDebugAdapterTrackerFactory {\n\treadonly type: string;\n}\n\nexport interface ITerminalLauncher {\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n}\n\nexport interface IConfigurationManager {\n\n\t/**\n\t * Returns an object containing the selected launch configuration and the selected configuration name. Both these fields can be null (no folder workspace).\n\t */\n\treadonly selectedConfiguration: {\n\t\tlaunch: ILaunch | undefined;\n\t\t// Potentially activates extensions\n\t\tgetConfig: () => Promise<IConfig | undefined>;\n\t\tname: string | undefined;\n\t\t// Type is used when matching dynamic configurations to their corresponding provider\n\t\ttype: string | undefined;\n\t};\n\n\tselectConfiguration(launch: ILaunch | undefined, name?: string, config?: IConfig, dynamicConfigOptions?: { type?: string }): Promise<void>;\n\n\tgetLaunches(): ReadonlyArray<ILaunch>;\n\tgetLaunch(workspaceUri: uri | undefined): ILaunch | undefined;\n\tgetAllConfigurations(): { launch: ILaunch, name: string, presentation?: IConfigPresentation }[];\n\tgetRecentDynamicConfigurations(): { name: string, type: string }[];\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\tonDidSelectConfiguration: Event<void>;\n\n\thasDebugConfigurationProvider(debugType: string): boolean;\n\tgetDynamicProviders(): Promise<{ label: string, type: string, pick: () => Promise<{ launch: ILaunch, config: IConfig } | undefined> }[]>;\n\n\tregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): IDisposable;\n\tunregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): void;\n\n\tresolveConfigurationByProviders(folderUri: uri | undefined, type: string | undefined, debugConfiguration: any, token: CancellationToken): Promise<any>;\n}\n\nexport interface IAdapterManager {\n\n\tonDidRegisterDebugger: Event<void>;\n\n\thasDebuggers(): boolean;\n\tgetDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor | undefined>;\n\tgetDebuggerLabel(type: string): string | undefined;\n\tisDebuggerInterestedInLanguage(language: string): boolean;\n\n\tactivateDebuggers(activationEvent: string, debugType?: string): Promise<void>;\n\tregisterDebugAdapterFactory(debugTypes: string[], debugAdapterFactory: IDebugAdapterFactory): IDisposable;\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter | undefined;\n\tregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): IDisposable;\n\tunregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): void;\n\n\tsubstituteVariables(debugType: string, folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n\trunInTerminal(debugType: string, args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;\n}\n\nexport interface ILaunch {\n\n\t/**\n\t * Resource pointing to the launch.json this object is wrapping.\n\t */\n\treadonly uri: uri;\n\n\t/**\n\t * Name of the launch.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Workspace of the launch. Can be undefined.\n\t */\n\treadonly workspace: IWorkspaceFolder | undefined;\n\n\t/**\n\t * Should this launch be shown in the debug dropdown.\n\t */\n\treadonly hidden: boolean;\n\n\t/**\n\t * Returns a configuration with the specified name.\n\t * Returns undefined if there is no configuration with the specified name.\n\t */\n\tgetConfiguration(name: string): IConfig | undefined;\n\n\t/**\n\t * Returns a compound with the specified name.\n\t * Returns undefined if there is no compound with the specified name.\n\t */\n\tgetCompound(name: string): ICompound | undefined;\n\n\t/**\n\t * Returns the names of all configurations and compounds.\n\t * Ignores configurations which are invalid.\n\t */\n\tgetConfigurationNames(ignoreCompoundsAndPresentation?: boolean): string[];\n\n\t/**\n\t * Opens the launch.json file. Creates if it does not exist.\n\t */\n\topenConfigFile(preserveFocus: boolean, type?: string, token?: CancellationToken): Promise<{ editor: IEditorPane | null, created: boolean }>;\n}\n\n// Debug service interfaces\n\nexport const IDebugService = createDecorator<IDebugService>(DEBUG_SERVICE_ID);\n\nexport interface IDebugService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Gets the current debug state.\n\t */\n\treadonly state: State;\n\n\t/**\n\t * Allows to register on debug state changes.\n\t */\n\tonDidChangeState: Event<State>;\n\n\t/**\n\t * Allows to register on new session events.\n\t */\n\tonDidNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on sessions about to be created (not yet fully initialised)\n\t */\n\tonWillNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on end session events.\n\t */\n\tonDidEndSession: Event<IDebugSession>;\n\n\t/**\n\t * Gets the configuration manager.\n\t */\n\tgetConfigurationManager(): IConfigurationManager;\n\n\t/**\n\t * Gets the adapter manager.\n\t */\n\tgetAdapterManager(): IAdapterManager;\n\n\t/**\n\t * Sets the focused stack frame and evaluates all expressions against the newly focused stack frame,\n\t */\n\tfocusStackFrame(focusedStackFrame: IStackFrame | undefined, thread?: IThread, session?: IDebugSession, explicit?: boolean): Promise<void>;\n\n\t/**\n\t * Returns true if breakpoints can be set for a given editor model. Depends on mode.\n\t */\n\tcanSetBreakpointsIn(model: EditorIModel): boolean;\n\n\t/**\n\t * Adds new breakpoints to the model for the file specified with the uri. Notifies debug adapter of breakpoint changes.\n\t */\n\taddBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[], ariaAnnounce?: boolean): Promise<IBreakpoint[]>;\n\n\t/**\n\t * Updates the breakpoints.\n\t */\n\tupdateBreakpoints(uri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;\n\n\t/**\n\t * Enables or disables all breakpoints. If breakpoint is passed only enables or disables the passed breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tenableOrDisableBreakpoints(enable: boolean, breakpoint?: IEnablement): Promise<void>;\n\n\t/**\n\t * Sets the global activated property for all breakpoints.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tsetBreakpointsActivated(activated: boolean): Promise<void>;\n\n\t/**\n\t * Removes all breakpoints. If id is passed only removes the breakpoint associated with that id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveBreakpoints(id?: string): Promise<any>;\n\n\t/**\n\t * Adds a new function breakpoint for the given name.\n\t */\n\taddFunctionBreakpoint(name?: string, id?: string): void;\n\n\t/**\n\t * Updates an already existing function breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tupdateFunctionBreakpoint(id: string, update: { name?: string, hitCondition?: string, condition?: string }): Promise<void>;\n\n\t/**\n\t * Removes all function breakpoints. If id is passed only removes the function breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveFunctionBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Adds a new data breakpoint.\n\t */\n\taddDataBreakpoint(label: string, dataId: string, canPersist: boolean, accessTypes: DebugProtocol.DataBreakpointAccessType[] | undefined, accessType: DebugProtocol.DataBreakpointAccessType): Promise<void>;\n\n\t/**\n\t * Removes all data breakpoints. If id is passed only removes the data breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveDataBreakpoints(id?: string): Promise<void>;\n\n\tsetExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string | undefined): Promise<void>;\n\n\tsetExceptionBreakpoints(data: DebugProtocol.ExceptionBreakpointsFilter[]): void;\n\n\t/**\n\t * Sends all breakpoints to the passed session.\n\t * If session is not passed, sends all breakpoints to each session.\n\t */\n\tsendAllBreakpoints(session?: IDebugSession): Promise<any>;\n\n\t/**\n\t * Adds a new watch expression and evaluates it against the debug adapter.\n\t */\n\taddWatchExpression(name?: string): void;\n\n\t/**\n\t * Renames a watch expression and evaluates it against the debug adapter.\n\t */\n\trenameWatchExpression(id: string, newName: string): void;\n\n\t/**\n\t * Moves a watch expression to a new possition. Used for reordering watch expressions.\n\t */\n\tmoveWatchExpression(id: string, position: number): void;\n\n\t/**\n\t * Removes all watch expressions. If id is passed only removes the watch expression with the passed id.\n\t */\n\tremoveWatchExpressions(id?: string): void;\n\n\t/**\n\t * Starts debugging. If the configOrName is not passed uses the selected configuration in the debug dropdown.\n\t * Also saves all files, manages if compounds are present in the configuration\n\t * and resolveds configurations via DebugConfigurationProviders.\n\t *\n\t * Returns true if the start debugging was successfull. For compound launches, all configurations have to start successfuly for it to return success.\n\t * On errors the startDebugging will throw an error, however some error and cancelations are handled and in that case will simply return false.\n\t */\n\tstartDebugging(launch: ILaunch | undefined, configOrName?: IConfig | string, options?: IDebugSessionOptions): Promise<boolean>;\n\n\t/**\n\t * Restarts a session or creates a new one if there is no active session.\n\t */\n\trestartSession(session: IDebugSession, restartData?: any): Promise<any>;\n\n\t/**\n\t * Stops the session. If no session is specified then all sessions are stopped.\n\t */\n\tstopSession(session: IDebugSession | undefined, disconnect?: boolean): Promise<any>;\n\n\t/**\n\t * Makes unavailable all sources with the passed uri. Source will appear as grayed out in callstack view.\n\t */\n\tsourceIsNotAvailable(uri: uri): void;\n\n\t/**\n\t * Gets the current debug model.\n\t */\n\tgetModel(): IDebugModel;\n\n\t/**\n\t * Gets the current view model.\n\t */\n\tgetViewModel(): IViewModel;\n}\n\n// Editor interfaces\nexport const enum BreakpointWidgetContext {\n\tCONDITION = 0,\n\tHIT_COUNT = 1,\n\tLOG_MESSAGE = 2\n}\n\nexport interface IDebugEditorContribution extends editorCommon.IEditorContribution {\n\tshowHover(range: Range, focus: boolean): Promise<void>;\n\taddLaunchConfiguration(): Promise<any>;\n\tcloseExceptionWidget(): void;\n}\n\nexport interface IBreakpointEditorContribution extends editorCommon.IEditorContribution {\n\tshowBreakpointWidget(lineNumber: number, column: number | undefined, context?: BreakpointWidgetContext): void;\n\tcloseBreakpointWidget(): void;\n\tgetContextMenuActionsAtPosition(lineNumber: number, model: EditorIModel): IAction[];\n}\n"]}