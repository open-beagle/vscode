{"version":3,"file":"explorerModel.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/contrib/files/common/explorerModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { isEqual } from 'vs/base/common/extpath';\nimport { posix } from 'vs/base/common/path';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { IFileStat, IFileService, FileSystemProviderCapabilities } from 'vs/platform/files/common/files';\nimport { rtrim, startsWithIgnoreCase, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { memoize } from 'vs/base/common/decorators';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { joinPath, isEqualOrParent, basenameOrAuthority } from 'vs/base/common/resources';\nimport { SortOrder } from 'vs/workbench/contrib/files/common/files';\nimport { IUriIdentityService } from 'vs/workbench/services/uriIdentity/common/uriIdentity';\n\nexport class ExplorerModel implements IDisposable {\n\n\tprivate _roots!: ExplorerItem[];\n\tprivate _listener: IDisposable;\n\tprivate readonly _onDidChangeRoots = new Emitter<void>();\n\n\tconstructor(\n\t\tprivate readonly contextService: IWorkspaceContextService,\n\t\tprivate readonly uriIdentityService: IUriIdentityService,\n\t\tfileService: IFileService\n\t) {\n\t\tconst setRoots = () => this._roots = this.contextService.getWorkspace().folders\n\t\t\t.map(folder => new ExplorerItem(folder.uri, fileService, undefined, true, false, folder.name));\n\t\tsetRoots();\n\n\t\tthis._listener = this.contextService.onDidChangeWorkspaceFolders(() => {\n\t\t\tsetRoots();\n\t\t\tthis._onDidChangeRoots.fire();\n\t\t});\n\t}\n\n\tget roots(): ExplorerItem[] {\n\t\treturn this._roots;\n\t}\n\n\tget onDidChangeRoots(): Event<void> {\n\t\treturn this._onDidChangeRoots.event;\n\t}\n\n\t/**\n\t * Returns an array of child stat from this stat that matches with the provided path.\n\t * Starts matching from the first root.\n\t * Will return empty array in case the FileStat does not exist.\n\t */\n\tfindAll(resource: URI): ExplorerItem[] {\n\t\treturn coalesce(this.roots.map(root => root.find(resource)));\n\t}\n\n\t/**\n\t * Returns a FileStat that matches the passed resource.\n\t * In case multiple FileStat are matching the resource (same folder opened multiple times) returns the FileStat that has the closest root.\n\t * Will return undefined in case the FileStat does not exist.\n\t */\n\tfindClosest(resource: URI): ExplorerItem | null {\n\t\tconst folder = this.contextService.getWorkspaceFolder(resource);\n\t\tif (folder) {\n\t\t\tconst root = this.roots.find(r => this.uriIdentityService.extUri.isEqual(r.resource, folder.uri));\n\t\t\tif (root) {\n\t\t\t\treturn root.find(resource);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdispose(): void {\n\t\tdispose(this._listener);\n\t}\n}\n\nexport class ExplorerItem {\n\tprotected _isDirectoryResolved: boolean;\n\tpublic isError = false;\n\tprivate _isExcluded = false;\n\n\tconstructor(\n\t\tpublic resource: URI,\n\t\tprivate readonly fileService: IFileService,\n\t\tprivate _parent: ExplorerItem | undefined,\n\t\tprivate _isDirectory?: boolean,\n\t\tprivate _isSymbolicLink?: boolean,\n\t\tprivate _name: string = basenameOrAuthority(resource),\n\t\tprivate _mtime?: number,\n\t\tprivate _unknown = false\n\t) {\n\t\tthis._isDirectoryResolved = false;\n\t}\n\n\tget isExcluded(): boolean {\n\t\tif (this._isExcluded) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!this._parent) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._parent.isExcluded;\n\t}\n\n\tset isExcluded(value: boolean) {\n\t\tthis._isExcluded = value;\n\t}\n\n\tget isDirectoryResolved(): boolean {\n\t\treturn this._isDirectoryResolved;\n\t}\n\n\tget isSymbolicLink(): boolean {\n\t\treturn !!this._isSymbolicLink;\n\t}\n\n\tget isDirectory(): boolean {\n\t\treturn !!this._isDirectory;\n\t}\n\n\tget isReadonly(): boolean {\n\t\treturn this.fileService.hasCapability(this.resource, FileSystemProviderCapabilities.Readonly);\n\t}\n\n\tget mtime(): number | undefined {\n\t\treturn this._mtime;\n\t}\n\n\tget name(): string {\n\t\treturn this._name;\n\t}\n\n\tget isUnknown(): boolean {\n\t\treturn this._unknown;\n\t}\n\n\tget parent(): ExplorerItem | undefined {\n\t\treturn this._parent;\n\t}\n\n\tget root(): ExplorerItem {\n\t\tif (!this._parent) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this._parent.root;\n\t}\n\n\t@memoize get children(): Map<string, ExplorerItem> {\n\t\treturn new Map<string, ExplorerItem>();\n\t}\n\n\tprivate updateName(value: string): void {\n\t\t// Re-add to parent since the parent has a name map to children and the name might have changed\n\t\tif (this._parent) {\n\t\t\tthis._parent.removeChild(this);\n\t\t}\n\t\tthis._name = value;\n\t\tif (this._parent) {\n\t\t\tthis._parent.addChild(this);\n\t\t}\n\t}\n\n\tgetId(): string {\n\t\treturn this.resource.toString();\n\t}\n\n\ttoString(): string {\n\t\treturn `ExplorerItem: ${this.name}`;\n\t}\n\n\tget isRoot(): boolean {\n\t\treturn this === this.root;\n\t}\n\n\tstatic create(fileService: IFileService, raw: IFileStat, parent: ExplorerItem | undefined, resolveTo?: readonly URI[]): ExplorerItem {\n\t\tconst stat = new ExplorerItem(raw.resource, fileService, parent, raw.isDirectory, raw.isSymbolicLink, raw.name, raw.mtime, !raw.isFile && !raw.isDirectory);\n\n\t\t// Recursively add children if present\n\t\tif (stat.isDirectory) {\n\n\t\t\t// isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved\n\t\t\t// the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo\n\t\t\t// array of resource path to resolve.\n\t\t\tstat._isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some((r) => {\n\t\t\t\treturn isEqualOrParent(r, stat.resource);\n\t\t\t}));\n\n\t\t\t// Recurse into children\n\t\t\tif (raw.children) {\n\t\t\t\tfor (let i = 0, len = raw.children.length; i < len; i++) {\n\t\t\t\t\tconst child = ExplorerItem.create(fileService, raw.children[i], stat, resolveTo);\n\t\t\t\t\tstat.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\t/**\n\t * Merges the stat which was resolved from the disk with the local stat by copying over properties\n\t * and children. The merge will only consider resolved stat elements to avoid overwriting data which\n\t * exists locally.\n\t */\n\tstatic mergeLocalWithDisk(disk: ExplorerItem, local: ExplorerItem): void {\n\t\tif (disk.resource.toString() !== local.resource.toString()) {\n\t\t\treturn; // Merging only supported for stats with the same resource\n\t\t}\n\n\t\t// Stop merging when a folder is not resolved to avoid loosing local data\n\t\tconst mergingDirectories = disk.isDirectory || local.isDirectory;\n\t\tif (mergingDirectories && local._isDirectoryResolved && !disk._isDirectoryResolved) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Properties\n\t\tlocal.resource = disk.resource;\n\t\tif (!local.isRoot) {\n\t\t\tlocal.updateName(disk.name);\n\t\t}\n\t\tlocal._isDirectory = disk.isDirectory;\n\t\tlocal._mtime = disk.mtime;\n\t\tlocal._isDirectoryResolved = disk._isDirectoryResolved;\n\t\tlocal._isSymbolicLink = disk.isSymbolicLink;\n\t\tlocal.isError = disk.isError;\n\n\t\t// Merge Children if resolved\n\t\tif (mergingDirectories && disk._isDirectoryResolved) {\n\n\t\t\t// Map resource => stat\n\t\t\tconst oldLocalChildren = new ResourceMap<ExplorerItem>();\n\t\t\tlocal.children.forEach(child => {\n\t\t\t\toldLocalChildren.set(child.resource, child);\n\t\t\t});\n\n\t\t\t// Clear current children\n\t\t\tlocal.children.clear();\n\n\t\t\t// Merge received children\n\t\t\tdisk.children.forEach(diskChild => {\n\t\t\t\tconst formerLocalChild = oldLocalChildren.get(diskChild.resource);\n\t\t\t\t// Existing child: merge\n\t\t\t\tif (formerLocalChild) {\n\t\t\t\t\tExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);\n\t\t\t\t\tlocal.addChild(formerLocalChild);\n\t\t\t\t\toldLocalChildren.delete(diskChild.resource);\n\t\t\t\t}\n\n\t\t\t\t// New child: add\n\t\t\t\telse {\n\t\t\t\t\tlocal.addChild(diskChild);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toldLocalChildren.forEach(oldChild => {\n\t\t\t\tif (oldChild instanceof NewExplorerItem) {\n\t\t\t\t\tlocal.addChild(oldChild);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Adds a child element to this folder.\n\t */\n\taddChild(child: ExplorerItem): void {\n\t\t// Inherit some parent properties to child\n\t\tchild._parent = this;\n\t\tchild.updateResource(false);\n\t\tthis.children.set(this.getPlatformAwareName(child.name), child);\n\t}\n\n\tgetChild(name: string): ExplorerItem | undefined {\n\t\treturn this.children.get(this.getPlatformAwareName(name));\n\t}\n\n\tasync fetchChildren(sortOrder: SortOrder): Promise<ExplorerItem[]> {\n\t\tif (!this._isDirectoryResolved) {\n\t\t\t// Resolve metadata only when the mtime is needed since this can be expensive\n\t\t\t// Mtime is only used when the sort order is 'modified'\n\t\t\tconst resolveMetadata = sortOrder === SortOrder.Modified;\n\t\t\ttry {\n\t\t\t\tconst stat = await this.fileService.resolve(this.resource, { resolveSingleChildDescendants: true, resolveMetadata });\n\t\t\t\tconst resolved = ExplorerItem.create(this.fileService, stat, this);\n\t\t\t\tExplorerItem.mergeLocalWithDisk(resolved, this);\n\t\t\t} catch (e) {\n\t\t\t\tthis.isError = true;\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tthis._isDirectoryResolved = true;\n\t\t}\n\n\t\tconst items: ExplorerItem[] = [];\n\t\tthis.children.forEach(child => {\n\t\t\titems.push(child);\n\t\t});\n\n\t\treturn items;\n\t}\n\n\t/**\n\t * Removes a child element from this folder.\n\t */\n\tremoveChild(child: ExplorerItem): void {\n\t\tthis.children.delete(this.getPlatformAwareName(child.name));\n\t}\n\n\tforgetChildren(): void {\n\t\tthis.children.clear();\n\t\tthis._isDirectoryResolved = false;\n\t}\n\n\tprivate getPlatformAwareName(name: string): string {\n\t\treturn this.fileService.hasCapability(this.resource, FileSystemProviderCapabilities.PathCaseSensitive) ? name : name.toLowerCase();\n\t}\n\n\t/**\n\t * Moves this element under a new parent element.\n\t */\n\tmove(newParent: ExplorerItem): void {\n\t\tif (this._parent) {\n\t\t\tthis._parent.removeChild(this);\n\t\t}\n\t\tnewParent.removeChild(this); // make sure to remove any previous version of the file if any\n\t\tnewParent.addChild(this);\n\t\tthis.updateResource(true);\n\t}\n\n\tprivate updateResource(recursive: boolean): void {\n\t\tif (this._parent) {\n\t\t\tthis.resource = joinPath(this._parent.resource, this.name);\n\t\t}\n\n\t\tif (recursive) {\n\t\t\tif (this.isDirectory) {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\tchild.updateResource(true);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)\n\t * so that the path property can be updated properly.\n\t */\n\trename(renamedStat: { name: string, mtime?: number }): void {\n\n\t\t// Merge a subset of Properties that can change on rename\n\t\tthis.updateName(renamedStat.name);\n\t\tthis._mtime = renamedStat.mtime;\n\n\t\t// Update Paths including children\n\t\tthis.updateResource(true);\n\t}\n\n\t/**\n\t * Returns a child stat from this stat that matches with the provided path.\n\t * Will return \"null\" in case the child does not exist.\n\t */\n\tfind(resource: URI): ExplorerItem | null {\n\t\t// Return if path found\n\t\t// For performance reasons try to do the comparison as fast as possible\n\t\tconst ignoreCase = !this.fileService.hasCapability(resource, FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tif (resource && this.resource.scheme === resource.scheme && equalsIgnoreCase(this.resource.authority, resource.authority) &&\n\t\t\t(ignoreCase ? startsWithIgnoreCase(resource.path, this.resource.path) : resource.path.startsWith(this.resource.path))) {\n\t\t\treturn this.findByPath(rtrim(resource.path, posix.sep), this.resource.path.length, ignoreCase);\n\t\t}\n\n\t\treturn null; //Unable to find\n\t}\n\n\tprivate findByPath(path: string, index: number, ignoreCase: boolean): ExplorerItem | null {\n\t\tif (isEqual(rtrim(this.resource.path, posix.sep), path, ignoreCase)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.isDirectory) {\n\t\t\t// Ignore separtor to more easily deduct the next name to search\n\t\t\twhile (index < path.length && path[index] === posix.sep) {\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tlet indexOfNextSep = path.indexOf(posix.sep, index);\n\t\t\tif (indexOfNextSep === -1) {\n\t\t\t\t// If there is no separator take the remainder of the path\n\t\t\t\tindexOfNextSep = path.length;\n\t\t\t}\n\t\t\t// The name to search is between two separators\n\t\t\tconst name = path.substring(index, indexOfNextSep);\n\n\t\t\tconst child = this.children.get(this.getPlatformAwareName(name));\n\n\t\t\tif (child) {\n\t\t\t\t// We found a child with the given name, search inside it\n\t\t\t\treturn child.findByPath(path, indexOfNextSep, ignoreCase);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\nexport class NewExplorerItem extends ExplorerItem {\n\tconstructor(fileService: IFileService, parent: ExplorerItem, isDirectory: boolean) {\n\t\tsuper(URI.file(''), fileService, parent, isDirectory);\n\t\tthis._isDirectoryResolved = true;\n\t}\n}\n"]}