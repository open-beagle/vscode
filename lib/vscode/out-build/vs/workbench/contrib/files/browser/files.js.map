{"version":3,"file":"files.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/contrib/files/browser/files.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { IListService } from 'vs/platform/list/browser/listService';\nimport { OpenEditor, SortOrder } from 'vs/workbench/contrib/files/common/files';\nimport { EditorResourceAccessor, SideBySideEditor, IEditorIdentifier, EditorInput, IEditorInputSerializer } from 'vs/workbench/common/editor';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { ExplorerItem } from 'vs/workbench/contrib/files/common/explorerModel';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { AsyncDataTree } from 'vs/base/browser/ui/tree/asyncDataTree';\nimport { IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { IEditableData } from 'vs/workbench/common/views';\nimport { createDecorator, IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { ResourceFileEdit } from 'vs/editor/browser/services/bulkEditService';\nimport { ProgressLocation } from 'vs/platform/progress/common/progress';\nimport { FileEditorInput } from 'vs/workbench/contrib/files/common/editors/fileEditorInput';\nimport { isEqual } from 'vs/base/common/resources';\n\ninterface ISerializedFileEditorInput {\n\tresourceJSON: UriComponents;\n\tpreferredResourceJSON?: UriComponents;\n\tname?: string;\n\tdescription?: string;\n\tencoding?: string;\n\tmodeId?: string;\n}\n\nexport class FileEditorInputSerializer implements IEditorInputSerializer {\n\n\tcanSerialize(editorInput: EditorInput): boolean {\n\t\treturn true;\n\t}\n\n\tserialize(editorInput: EditorInput): string {\n\t\tconst fileEditorInput = editorInput as FileEditorInput;\n\t\tconst resource = fileEditorInput.resource;\n\t\tconst preferredResource = fileEditorInput.preferredResource;\n\t\tconst serializedFileEditorInput: ISerializedFileEditorInput = {\n\t\t\tresourceJSON: resource.toJSON(),\n\t\t\tpreferredResourceJSON: isEqual(resource, preferredResource) ? undefined : preferredResource, // only storing preferredResource if it differs from the resource\n\t\t\tname: fileEditorInput.getPreferredName(),\n\t\t\tdescription: fileEditorInput.getPreferredDescription(),\n\t\t\tencoding: fileEditorInput.getEncoding(),\n\t\t\tmodeId: fileEditorInput.getPreferredMode() // only using the preferred user associated mode here if available to not store redundant data\n\t\t};\n\n\t\treturn JSON.stringify(serializedFileEditorInput);\n\t}\n\n\tdeserialize(instantiationService: IInstantiationService, serializedEditorInput: string): FileEditorInput {\n\t\treturn instantiationService.invokeFunction(accessor => {\n\t\t\tconst serializedFileEditorInput: ISerializedFileEditorInput = JSON.parse(serializedEditorInput);\n\t\t\tconst resource = URI.revive(serializedFileEditorInput.resourceJSON);\n\t\t\tconst preferredResource = URI.revive(serializedFileEditorInput.preferredResourceJSON);\n\t\t\tconst name = serializedFileEditorInput.name;\n\t\t\tconst description = serializedFileEditorInput.description;\n\t\t\tconst encoding = serializedFileEditorInput.encoding;\n\t\t\tconst mode = serializedFileEditorInput.modeId;\n\n\t\t\tconst fileEditorInput = accessor.get(IEditorService).createEditorInput({ resource, label: name, description, encoding, mode, forceFile: true }) as FileEditorInput;\n\t\t\tif (preferredResource) {\n\t\t\t\tfileEditorInput.setPreferredResource(preferredResource);\n\t\t\t}\n\n\t\t\treturn fileEditorInput;\n\t\t});\n\t}\n}\n\nexport interface IExplorerService {\n\treadonly _serviceBrand: undefined;\n\treadonly roots: ExplorerItem[];\n\treadonly sortOrder: SortOrder;\n\n\tgetContext(respectMultiSelection: boolean): ExplorerItem[];\n\thasViewFocus(): boolean;\n\tsetEditable(stat: ExplorerItem, data: IEditableData | null): Promise<void>;\n\tgetEditable(): { stat: ExplorerItem, data: IEditableData } | undefined;\n\tgetEditableData(stat: ExplorerItem): IEditableData | undefined;\n\t// If undefined is passed checks if any element is currently being edited.\n\tisEditable(stat: ExplorerItem | undefined): boolean;\n\tfindClosest(resource: URI): ExplorerItem | null;\n\tfindClosestRoot(resource: URI): ExplorerItem | null;\n\trefresh(): Promise<void>;\n\tsetToCopy(stats: ExplorerItem[], cut: boolean): Promise<void>;\n\tisCut(stat: ExplorerItem): boolean;\n\tapplyBulkEdit(edit: ResourceFileEdit[], options: { undoLabel: string, progressLabel: string, confirmBeforeUndo?: boolean, progressLocation?: ProgressLocation.Explorer | ProgressLocation.Window }): Promise<void>;\n\n\t/**\n\t * Selects and reveal the file element provided by the given resource if its found in the explorer.\n\t * Will try to resolve the path in case the explorer is not yet expanded to the file yet.\n\t */\n\tselect(resource: URI, reveal?: boolean | string): Promise<void>;\n\n\tregisterView(contextAndRefreshProvider: IExplorerView): void;\n}\n\nexport const IExplorerService = createDecorator<IExplorerService>('explorerService');\n\nexport interface IExplorerView {\n\tgetContext(respectMultiSelection: boolean): ExplorerItem[];\n\trefresh(recursive: boolean, item?: ExplorerItem): Promise<void>;\n\tselectResource(resource: URI | undefined, reveal?: boolean | string): Promise<void>;\n\tsetTreeInput(): Promise<void>;\n\titemsCopied(tats: ExplorerItem[], cut: boolean, previousCut: ExplorerItem[] | undefined): void;\n\tsetEditable(stat: ExplorerItem, isEditing: boolean): Promise<void>;\n\tfocusNeighbourIfItemFocused(item: ExplorerItem): void;\n\tisItemVisible(item: ExplorerItem): boolean;\n\thasFocus(): boolean;\n}\n\nfunction getFocus(listService: IListService): unknown | undefined {\n\tlet list = listService.lastFocusedList;\n\tif (list?.getHTMLElement() === document.activeElement) {\n\t\tlet focus: unknown;\n\t\tif (list instanceof List) {\n\t\t\tconst focused = list.getFocusedElements();\n\t\t\tif (focused.length) {\n\t\t\t\tfocus = focused[0];\n\t\t\t}\n\t\t} else if (list instanceof AsyncDataTree) {\n\t\t\tconst focused = list.getFocus();\n\t\t\tif (focused.length) {\n\t\t\t\tfocus = focused[0];\n\t\t\t}\n\t\t}\n\n\t\treturn focus;\n\t}\n\n\treturn undefined;\n}\n\n// Commands can get executed from a command palette, from a context menu or from some list using a keybinding\n// To cover all these cases we need to properly compute the resource on which the command is being executed\nexport function getResourceForCommand(resource: URI | object | undefined, listService: IListService, editorService: IEditorService): URI | undefined {\n\tif (URI.isUri(resource)) {\n\t\treturn resource;\n\t}\n\n\tconst focus = getFocus(listService);\n\tif (focus instanceof ExplorerItem) {\n\t\treturn focus.resource;\n\t} else if (focus instanceof OpenEditor) {\n\t\treturn focus.getResource();\n\t}\n\n\treturn EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });\n}\n\nexport function getMultiSelectedResources(resource: URI | object | undefined, listService: IListService, editorService: IEditorService, explorerService: IExplorerService): Array<URI> {\n\tconst list = listService.lastFocusedList;\n\tif (list?.getHTMLElement() === document.activeElement) {\n\t\t// Explorer\n\t\tif (list instanceof AsyncDataTree && list.getFocus().every(item => item instanceof ExplorerItem)) {\n\t\t\t// Explorer\n\t\t\tconst context = explorerService.getContext(true);\n\t\t\tif (context.length) {\n\t\t\t\treturn context.map(c => c.resource);\n\t\t\t}\n\t\t}\n\n\t\t// Open editors view\n\t\tif (list instanceof List) {\n\t\t\tconst selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor).map((oe: OpenEditor) => oe.getResource()));\n\t\t\tconst focusedElements = list.getFocusedElements();\n\t\t\tconst focus = focusedElements.length ? focusedElements[0] : undefined;\n\t\t\tlet mainUriStr: string | undefined = undefined;\n\t\t\tif (URI.isUri(resource)) {\n\t\t\t\tmainUriStr = resource.toString();\n\t\t\t} else if (focus instanceof OpenEditor) {\n\t\t\t\tconst focusedResource = focus.getResource();\n\t\t\t\tmainUriStr = focusedResource ? focusedResource.toString() : undefined;\n\t\t\t}\n\t\t\t// We only respect the selection if it contains the main element.\n\t\t\tif (selection.some(s => s.toString() === mainUriStr)) {\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst result = getResourceForCommand(resource, listService, editorService);\n\treturn !!result ? [result] : [];\n}\n\nexport function getOpenEditorsViewMultiSelection(listService: IListService, editorGroupService: IEditorGroupsService): Array<IEditorIdentifier> | undefined {\n\tconst list = listService.lastFocusedList;\n\tif (list?.getHTMLElement() === document.activeElement) {\n\t\t// Open editors view\n\t\tif (list instanceof List) {\n\t\t\tconst selection = coalesce(list.getSelectedElements().filter(s => s instanceof OpenEditor));\n\t\t\tconst focusedElements = list.getFocusedElements();\n\t\t\tconst focus = focusedElements.length ? focusedElements[0] : undefined;\n\t\t\tlet mainEditor: IEditorIdentifier | undefined = undefined;\n\t\t\tif (focus instanceof OpenEditor) {\n\t\t\t\tmainEditor = focus;\n\t\t\t}\n\t\t\t// We only respect the selection if it contains the main element.\n\t\t\tif (selection.some(s => s === mainEditor)) {\n\t\t\t\treturn selection;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n"]}