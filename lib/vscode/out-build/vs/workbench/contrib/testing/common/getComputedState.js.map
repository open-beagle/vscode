{"version":3,"file":"getComputedState.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/contrib/testing/common/getComputedState.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAgBhG;;;;OAIG;IAEI,MAAM,gBAAgB,GAAG,CAAI,QAAmC,EAAE,IAAO,EAAE,KAAK,GAAG,KAAK,EAAE,EAAE;;QAClG,IAAI,QAAQ,GAAG,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;QACtD,IAAI,QAAQ,KAAK,SAAS,IAAI,KAAK,EAAE;YACpC,QAAQ,GAAG,MAAA,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,mCAAI,8BAAe,CAAC,KAAK,CAAC;YAC/D,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;gBAC/C,QAAQ,GAAG,CAAA,GAAA,2BAAW,CAAA,CAAC,QAAQ,EAAE,CAAA,GAAA,wBAAgB,CAAA,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;aACpE;YAED,QAAQ,CAAC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;SAC1C;QAED,OAAO,QAAQ,CAAC;IACjB,CAAC,CAAC;IAZW,QAAA,gBAAgB,oBAY3B;IACF;;;OAGG;IAEI,MAAM,oBAAoB,GAAG,CACnC,QAAmC,EACnC,IAAO,EACP,UAA6B,EAC7B,wBAA0C,EACzC,EAAE;QACH,MAAM,QAAQ,GAAG,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;QACxD,MAAM,WAAW,GAAG,6BAAa,CAAC,QAAQ,CAAC,CAAC;QAC5C,MAAM,QAAQ,GAAG,wBAAwB,aAAxB,wBAAwB,cAAxB,wBAAwB,GAAI,CAAA,GAAA,wBAAgB,CAAA,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QACpF,MAAM,WAAW,GAAG,6BAAa,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,WAAW,KAAK,WAAW,EAAE;YAChC,OAAO;SACP;QAED,QAAQ,CAAC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAC1C,UAAU,CAAC,IAAI,CAAC,CAAC;QAEjB,IAAI,WAAW,GAAG,WAAW,EAAE;YAC9B,+DAA+D;YAC/D,KAAK,MAAM,MAAM,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;gBAC/C,MAAM,IAAI,GAAG,QAAQ,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;gBACtD,IAAI,IAAI,KAAK,SAAS,IAAI,6BAAa,CAAC,IAAI,CAAC,IAAI,WAAW,EAAE;oBAC7D,MAAM;iBACN;gBAED,QAAQ,CAAC,gBAAgB,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gBAC5C,UAAU,CAAC,MAAM,CAAC,CAAC;aACnB;SACD;aAAM,IAAI,WAAW,GAAG,WAAW,EAAE;YACrC,4FAA4F;YAC5F,KAAK,MAAM,MAAM,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;gBAC/C,MAAM,IAAI,GAAG,QAAQ,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;gBACtD,IAAI,IAAI,KAAK,SAAS,IAAI,6BAAa,CAAC,IAAI,CAAC,GAAG,WAAW,EAAE;oBAC5D,MAAM;iBACN;gBAED,QAAQ,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAA,GAAA,wBAAgB,CAAA,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;gBAC5E,UAAU,CAAC,MAAM,CAAC,CAAC;aACnB;SACD;IACF,CAAC,CAAC;IAxCW,QAAA,oBAAoB,wBAwC/B","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { TestResultState } from 'vs/workbench/api/common/extHostTypes';\nimport { maxPriority, statePriority } from 'vs/workbench/contrib/testing/common/testingStates';\n\n/**\n * Accessor for nodes in get and refresh computed state.\n */\nexport interface IComputedStateAccessor<T> {\n\tgetOwnState(item: T): TestResultState | undefined;\n\tgetCurrentComputedState(item: T): TestResultState;\n\tsetComputedState(item: T, state: TestResultState): void;\n\tgetChildren(item: T): Iterable<T>;\n\tgetParents(item: T): Iterable<T>;\n}\n\n/**\n * Gets the computed state for the node.\n * @param force whether to refresh the computed state for this node, even\n * if it was previously set.\n */\n\nexport const getComputedState = <T>(accessor: IComputedStateAccessor<T>, node: T, force = false) => {\n\tlet computed = accessor.getCurrentComputedState(node);\n\tif (computed === undefined || force) {\n\t\tcomputed = accessor.getOwnState(node) ?? TestResultState.Unset;\n\t\tfor (const child of accessor.getChildren(node)) {\n\t\t\tcomputed = maxPriority(computed, getComputedState(accessor, child));\n\t\t}\n\n\t\taccessor.setComputedState(node, computed);\n\t}\n\n\treturn computed;\n};\n/**\n * Refreshes the computed state for the node and its parents. Any changes\n * elements cause `addUpdated` to be called.\n */\n\nexport const refreshComputedState = <T>(\n\taccessor: IComputedStateAccessor<T>,\n\tnode: T,\n\taddUpdated: (node: T) => void,\n\texplicitNewComputedState?: TestResultState,\n) => {\n\tconst oldState = accessor.getCurrentComputedState(node);\n\tconst oldPriority = statePriority[oldState];\n\tconst newState = explicitNewComputedState ?? getComputedState(accessor, node, true);\n\tconst newPriority = statePriority[newState];\n\tif (newPriority === oldPriority) {\n\t\treturn;\n\t}\n\n\taccessor.setComputedState(node, newState);\n\taddUpdated(node);\n\n\tif (newPriority > oldPriority) {\n\t\t// Update all parents to ensure they're at least this priority.\n\t\tfor (const parent of accessor.getParents(node)) {\n\t\t\tconst prev = accessor.getCurrentComputedState(parent);\n\t\t\tif (prev !== undefined && statePriority[prev] >= newPriority) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taccessor.setComputedState(parent, newState);\n\t\t\taddUpdated(parent);\n\t\t}\n\t} else if (newPriority < oldPriority) {\n\t\t// Re-render all parents of this node whose computed priority might have come from this node\n\t\tfor (const parent of accessor.getParents(node)) {\n\t\t\tconst prev = accessor.getCurrentComputedState(parent);\n\t\t\tif (prev === undefined || statePriority[prev] > oldPriority) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taccessor.setComputedState(parent, getComputedState(accessor, parent, true));\n\t\t\taddUpdated(parent);\n\t\t}\n\t}\n};\n"]}