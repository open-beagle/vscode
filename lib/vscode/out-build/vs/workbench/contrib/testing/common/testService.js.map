{"version":3,"file":"testService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/contrib/testing/common/testService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Event } from 'vs/base/common/event';\nimport { DisposableStore, IDisposable, IReference } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ExtHostTestingResource } from 'vs/workbench/api/common/extHost.protocol';\nimport { MutableObservableValue } from 'vs/workbench/contrib/testing/common/observableValue';\nimport { AbstractIncrementalTestCollection, IncrementalTestCollectionItem, InternalTestItem, RunTestForProviderRequest, RunTestsRequest, TestIdPath, TestIdWithSrc, TestsDiff } from 'vs/workbench/contrib/testing/common/testCollection';\nimport { ITestResult } from 'vs/workbench/contrib/testing/common/testResult';\n\nexport const ITestService = createDecorator<ITestService>('testService');\n\nexport interface MainTestController {\n\texpandTest(src: TestIdWithSrc, levels: number): Promise<void>;\n\tlookupTest(test: TestIdWithSrc): Promise<InternalTestItem | undefined>;\n\trunTests(request: RunTestForProviderRequest, token: CancellationToken): Promise<void>;\n}\n\nexport type TestDiffListener = (diff: TestsDiff) => void;\n\nexport interface IMainThreadTestCollection extends AbstractIncrementalTestCollection<IncrementalTestCollectionItem> {\n\tonPendingRootProvidersChange: Event<number>;\n\tonBusyProvidersChange: Event<number>;\n\n\t/**\n\t * Number of test root sources who are yet to report.\n\t */\n\tpendingRootProviders: number;\n\n\t/**\n\t * Number of providers working to discover tests.\n\t */\n\tbusyProviders: number;\n\n\t/**\n\t * Root node IDs.\n\t */\n\trootIds: ReadonlySet<string>;\n\n\t/**\n\t * Iterates over every test in the collection.\n\t */\n\tall: Iterable<IncrementalTestCollectionItem>;\n\n\t/**\n\t * Gets a node in the collection by ID.\n\t */\n\tgetNodeById(id: string): IncrementalTestCollectionItem | undefined;\n\n\t/**\n\t * Requests that children be revealed for the given test. \"Levels\" may\n\t * be infinite.\n\t */\n\texpand(testId: string, levels: number): Promise<void>;\n\n\t/**\n\t * Gets a diff that adds all items currently in the tree to a new collection,\n\t * allowing it to fully hydrate.\n\t */\n\tgetReviverDiff(): TestsDiff;\n}\n\nexport const waitForAllRoots = (collection: IMainThreadTestCollection, ct = CancellationToken.None) => {\n\tif (collection.pendingRootProviders === 0 || ct.isCancellationRequested) {\n\t\treturn Promise.resolve();\n\t}\n\n\tconst disposable = new DisposableStore();\n\treturn new Promise<void>(resolve => {\n\t\tdisposable.add(collection.onPendingRootProvidersChange(count => {\n\t\t\tif (count === 0) {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t}));\n\n\t\tdisposable.add(ct.onCancellationRequested(() => resolve()));\n\t}).finally(() => disposable.dispose());\n};\n\n/**\n * Ensures the test with the given path exists in the collection, if possible.\n * If cancellation is requested, or the test cannot be found, it will return\n * undefined.\n */\nexport const getTestByPath = async (collection: IMainThreadTestCollection, idPath: TestIdPath, ct = CancellationToken.None) => {\n\tawait waitForAllRoots(collection, ct);\n\n\t// Expand all direct children since roots might well have different IDs, but\n\t// children should start matching.\n\tawait Promise.all([...collection.rootIds].map(r => collection.expand(r, 0)));\n\n\tif (ct.isCancellationRequested) {\n\t\treturn undefined;\n\t}\n\n\tlet expandToLevel = 0;\n\tfor (let i = idPath.length - 1; !ct.isCancellationRequested && i >= expandToLevel;) {\n\t\tconst id = idPath[i];\n\t\tconst existing = collection.getNodeById(id);\n\t\tif (!existing) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i === idPath.length - 1) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tawait collection.expand(id, 0);\n\t\texpandToLevel = i + 1; // avoid an infinite loop if the test does not exist\n\t\ti = idPath.length - 1;\n\t}\n\treturn undefined;\n};\n\n/**\n * Waits for all test in the hierarchy to be fulfilled before returning.\n * If cancellation is requested, it will return early.\n */\nexport const getAllTestsInHierarchy = async (collection: IMainThreadTestCollection, ct = CancellationToken.None) => {\n\tawait waitForAllRoots(collection, ct);\n\n\tif (ct.isCancellationRequested) {\n\t\treturn;\n\t}\n\n\tlet l: IDisposable;\n\n\tawait Promise.race([\n\t\tPromise.all([...collection.rootIds].map(r => collection.expand(r, Infinity))),\n\t\tnew Promise(r => { l = ct.onCancellationRequested(r); }),\n\t]).finally(() => l?.dispose());\n};\n\n/**\n * An instance of the RootProvider should be registered for each extension\n * host.\n */\nexport interface ITestRootProvider {\n\t// todo: nothing, yet\n}\n\nexport interface ITestService {\n\treadonly _serviceBrand: undefined;\n\treadonly onShouldSubscribe: Event<{ resource: ExtHostTestingResource, uri: URI; }>;\n\treadonly onShouldUnsubscribe: Event<{ resource: ExtHostTestingResource, uri: URI; }>;\n\treadonly onDidChangeProviders: Event<{ delta: number; }>;\n\treadonly providers: number;\n\treadonly subscriptions: ReadonlyArray<{ resource: ExtHostTestingResource, uri: URI; }>;\n\treadonly testRuns: Iterable<RunTestsRequest>;\n\n\t/**\n\t * Set of test IDs the user asked to exclude.\n\t */\n\treadonly excludeTests: MutableObservableValue<ReadonlySet<string>>;\n\n\t/**\n\t * Sets whether a test is excluded.\n\t */\n\tsetTestExcluded(testId: string, exclude?: boolean): void;\n\n\t/**\n\t * Removes all test exclusions.\n\t */\n\tclearExcludedTests(): void;\n\n\t/**\n\t * Updates the number of sources who provide test roots when subscription\n\t * is requested. This is equal to the number of extension hosts, and used\n\t * with `TestDiffOpType.DeltaRootsComplete` to signal when all roots\n\t * are available.\n\t */\n\tregisterRootProvider(provider: ITestRootProvider): IDisposable;\n\n\t/**\n\t * Registers an interface that runs tests for the given provider ID.\n\t */\n\tregisterTestController(providerId: string, controller: MainTestController): IDisposable;\n\n\t/**\n\t * Requests that tests be executed.\n\t */\n\trunTests(req: RunTestsRequest, token?: CancellationToken): Promise<ITestResult>;\n\n\t/**\n\t * Cancels an ongoign test run request.\n\t */\n\tcancelTestRun(req: RunTestsRequest): void;\n\n\tpublishDiff(resource: ExtHostTestingResource, uri: URI, diff: TestsDiff): void;\n\tsubscribeToDiffs(resource: ExtHostTestingResource, uri: URI, acceptDiff?: TestDiffListener): IReference<IMainThreadTestCollection>;\n\n\n\t/**\n\t * Looks up a test, by a request to extension hosts.\n\t */\n\tlookupTest(test: TestIdWithSrc): Promise<InternalTestItem | undefined>;\n\n\t/**\n\t * Requests to resubscribe to all active subscriptions, discarding old tests.\n\t */\n\tresubscribeToAllTests(): void;\n}\n"]}