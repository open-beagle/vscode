{"version":3,"file":"hierarchalByName.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/contrib/testing/browser/explorerProjections/hierarchalByName.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;IAYhG;;OAEG;IACH,IAAkB,eASjB;IATD,WAAkB,eAAe;QAChC,kEAAkE;QAClE,6DAAQ,CAAA;QACR,0EAA0E;QAC1E,yEAAc,CAAA;QACd,wCAAwC;QACxC,+EAAiB,CAAA;QACjB,6BAA6B;QAC7B,uDAAK,CAAA;IACN,CAAC,EATiB,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAShC;IAED;;OAEG;IACH,MAAa,qBAAsB,SAAQ,2CAAyB;QAcnE;;WAEG;QACH,YACC,QAA0B,EAC1B,UAA+D,EAC/D,cAAoD,EACnC,YAAoC;YAErD,KAAK,CAAC,QAAQ,EAAE,UAAU,EAAE,cAAc,CAAC,CAAC;YAF3B,iBAAY,GAAZ,YAAY,CAAwB;YApB/C,gBAAW,iBAA0C;YAC5C,eAAU,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC;YAChC,mBAAc,GAAG,IAAI,GAAG,EAAyB,CAAC;YAqBjE,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;YAC7B,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC5B,CAAC;QArBD,IAAoB,WAAW;YAC9B,IAAI,WAAW,GAAkB,IAAI,CAAC;YACtC,KAAK,IAAI,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE,MAAM,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,MAAM,GAAG,MAAM,CAAC,YAAY,EAAE;gBAChG,WAAW,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,MAAM,WAAW,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;aAC9E;YAED,OAAO,WAAW,CAAC;QACpB,CAAC;QAgBD;;WAEG;QACa,MAAM,CAAC,KAAsB;;YAC5C,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAEpB,IAAI,CAAA,MAAA,KAAK,CAAC,IAAI,0CAAE,QAAQ,MAAK,SAAS,EAAE;gBACvC,IAAI,CAAC,mBAAmB,EAAE,CAAC;aAC3B;QACF,CAAC;QAED;;WAEG;QACI,MAAM;;YACZ,MAAA,IAAI,CAAC,YAAY,0CAAE,WAAW,CAAC,IAAI,CAAC,CAAC;QACtC,CAAC;QAEO,WAAW,CAAC,OAA8B;YACjD,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YACpC,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC5B,CAAC;QAEO,QAAQ,CAAC,OAA8B;YAC9C,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACjC,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC5B,CAAC;QAED;;;;WAIG;QACK,mBAAmB;;YAC1B,MAAM,OAAO,GAAG,mBAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,8BAAsC,CAAC;gBAC3G,CAAC;gBACD,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ;oBACxB,CAAC;oBACD,CAAC,0BAAkC,CAAC;YAEtC,IAAI,OAAO,KAAK,IAAI,CAAC,WAAW,EAAE;gBACjC,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC;gBAC3B,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;aAC1B;YAED,MAAA,IAAI,CAAC,YAAY,0CAAE,mBAAmB,EAAE,CAAC;QAC1C,CAAC;KACD;IA3ED,sDA2EC;IAED;;;;OAIG;IACH,IAAa,4BAA4B,GAAzC,MAAa,4BAA6B,SAAQ,uDAAgC;QACjF,YAAY,QAAkC,EAAsB,OAA2B;YAC9F,KAAK,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YAEzB,MAAM,kBAAkB,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACtD,IAAI,CAAC,UAAU,GAAG,CAAC,IAAI,EAAE,OAAO,EAAE,EAAE;gBACnC,IAAI,IAAI,YAAY,qBAAqB,IAAI,IAAI,CAAC,WAAW,qBAA6B,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;oBAC/G,sBAAkC;iBAClC;gBAED,MAAM,QAAQ,GAAG,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;gBACnD,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;oBAChC,QAAgB,CAAC,WAAW,GAAG,KAAK,CAAC;iBACtC;gBAED,OAAO,QAAQ,CAAC;YACjB,CAAC,CAAC;QACH,CAAC;QAED;;WAEG;QACgB,UAAU,CAAC,IAAsB,EAAE,MAAwB;YAC7E,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,CAAC;YAC9D,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAA0B,CAAC,CAAC,CAAC,SAAS,CAAC;YAC/F,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACrC,IAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,KAAK,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE;oBACzD,OAAO,IAAI,qBAAqB,CAAC,IAAI,EAAE,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;iBACpG;aACD;YAED,OAAO,IAAI,qBAAqB,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;QACnF,CAAC;QAED;;WAEG;QACgB,WAAW,CAAC,KAA6C,EAAE,IAA+B;YAC5G,MAAM,YAAY,GAAG,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YACpD,IAAI,IAAI,YAAY,qBAAqB,EAAE;gBAC1C,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,OAAO,IAAI,CAAC,cAAc,CAAC;aAC3B;YAED,OAAO,YAAY,CAAC;QACrB,CAAC;QAED;;WAEG;QACgB,cAAc,CAAC,OAAkC;YACnE,OAAO,OAAO,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;QACnD,CAAC;KACD,CAAA;IArDY,4BAA4B;QACS,WAAA,sCAAkB,CAAA;OADvD,4BAA4B,CAqDxC;IArDY,oEAA4B","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from 'vs/base/common/iterator';\nimport { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport { TestExplorerTreeElement } from 'vs/workbench/contrib/testing/browser/explorerProjections';\nimport { HierarchicalByLocationProjection as HierarchicalByLocationProjection } from 'vs/workbench/contrib/testing/browser/explorerProjections/hierarchalByLocation';\nimport { ByLocationTestItemElement, ByLocationFolderElement } from 'vs/workbench/contrib/testing/browser/explorerProjections/hierarchalNodes';\nimport { NodeRenderDirective } from 'vs/workbench/contrib/testing/browser/explorerProjections/nodeHelper';\nimport { InternalTestItem, ITestItemUpdate } from 'vs/workbench/contrib/testing/common/testCollection';\nimport { ITestResultService } from 'vs/workbench/contrib/testing/common/testResultService';\nimport { TestSubscriptionListener } from 'vs/workbench/contrib/testing/common/workspaceTestCollectionService';\n\n/**\n * Type of test element in the list.\n */\nexport const enum ListElementType {\n\t/** The element is a leaf test that should be shown in the list */\n\tTestLeaf,\n\t/** The element is not runnable, but doesn't have any nested leaf tests */\n\tBranchWithLeaf,\n\t/** The element has nested leaf tests */\n\tBranchWithoutLeaf,\n\t/** State not yet computed */\n\tUnset,\n}\n\n/**\n * Version of the HierarchicalElement that is displayed as a list.\n */\nexport class ByNameTestItemElement extends ByLocationTestItemElement {\n\tpublic elementType: ListElementType = ListElementType.Unset;\n\tpublic readonly isTestRoot = !this.actualParent;\n\tpublic readonly actualChildren = new Set<ByNameTestItemElement>();\n\n\tpublic override get description() {\n\t\tlet description: string | null = null;\n\t\tfor (let parent = this.actualParent; parent && !parent.isTestRoot; parent = parent.actualParent) {\n\t\t\tdescription = description ? `${parent.label} â€º ${description}` : parent.label;\n\t\t}\n\n\t\treturn description;\n\t}\n\n\t/**\n\t * @param actualParent Parent of the item in the test heirarchy\n\t */\n\tconstructor(\n\t\tinternal: InternalTestItem,\n\t\tparentItem: ByLocationFolderElement | ByLocationTestItemElement,\n\t\taddedOrRemoved: (n: TestExplorerTreeElement) => void,\n\t\tprivate readonly actualParent?: ByNameTestItemElement,\n\t) {\n\t\tsuper(internal, parentItem, addedOrRemoved);\n\t\tactualParent?.addChild(this);\n\t\tthis.updateLeafTestState();\n\t}\n\n\t/**\n\t * @override\n\t */\n\tpublic override update(patch: ITestItemUpdate) {\n\t\tsuper.update(patch);\n\n\t\tif (patch.item?.runnable !== undefined) {\n\t\t\tthis.updateLeafTestState();\n\t\t}\n\t}\n\n\t/**\n\t * Should be called when the list element is removed.\n\t */\n\tpublic remove() {\n\t\tthis.actualParent?.removeChild(this);\n\t}\n\n\tprivate removeChild(element: ByNameTestItemElement) {\n\t\tthis.actualChildren.delete(element);\n\t\tthis.updateLeafTestState();\n\t}\n\n\tprivate addChild(element: ByNameTestItemElement) {\n\t\tthis.actualChildren.add(element);\n\t\tthis.updateLeafTestState();\n\t}\n\n\t/**\n\t * Updates the test leaf state for this node. Should be called when a child\n\t * or this node is modified. Note that we never need to look at the children\n\t * here, the children will already be leaves, or not.\n\t */\n\tprivate updateLeafTestState() {\n\t\tconst newType = Iterable.some(this.actualChildren, c => c.elementType !== ListElementType.BranchWithoutLeaf)\n\t\t\t? ListElementType.BranchWithLeaf\n\t\t\t: this.test.item.runnable\n\t\t\t\t? ListElementType.TestLeaf\n\t\t\t\t: ListElementType.BranchWithoutLeaf;\n\n\t\tif (newType !== this.elementType) {\n\t\t\tthis.elementType = newType;\n\t\t\tthis.addedOrRemoved(this);\n\t\t}\n\n\t\tthis.actualParent?.updateLeafTestState();\n\t}\n}\n\n/**\n * Projection that shows tests in a flat list (grouped by provider). The only\n * change is that, while creating the item, the item parent is set to the\n * test root rather than the heirarchal parent.\n */\nexport class HierarchicalByNameProjection extends HierarchicalByLocationProjection {\n\tconstructor(listener: TestSubscriptionListener, @ITestResultService results: ITestResultService) {\n\t\tsuper(listener, results);\n\n\t\tconst originalRenderNode = this.renderNode.bind(this);\n\t\tthis.renderNode = (node, recurse) => {\n\t\t\tif (node instanceof ByNameTestItemElement && node.elementType !== ListElementType.TestLeaf && !node.isTestRoot) {\n\t\t\t\treturn NodeRenderDirective.Concat;\n\t\t\t}\n\n\t\t\tconst rendered = originalRenderNode(node, recurse);\n\t\t\tif (typeof rendered !== 'number') {\n\t\t\t\t(rendered as any).collapsible = false;\n\t\t\t}\n\n\t\t\treturn rendered;\n\t\t};\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected override createItem(item: InternalTestItem, folder: IWorkspaceFolder): ByLocationTestItemElement {\n\t\tconst { root, items } = this.getOrCreateFolderElement(folder);\n\t\tconst actualParent = item.parent ? items.get(item.parent) as ByNameTestItemElement : undefined;\n\t\tfor (const testRoot of root.children) {\n\t\t\tif (testRoot.test.src.controller === item.src.controller) {\n\t\t\t\treturn new ByNameTestItemElement(item, testRoot, r => this.changes.addedOrRemoved(r), actualParent);\n\t\t\t}\n\t\t}\n\n\t\treturn new ByNameTestItemElement(item, root, r => this.changes.addedOrRemoved(r));\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected override unstoreItem(items: Map<string, ByLocationTestItemElement>, item: ByLocationTestItemElement) {\n\t\tconst treeChildren = super.unstoreItem(items, item);\n\t\tif (item instanceof ByNameTestItemElement) {\n\t\t\titem.remove();\n\t\t\treturn item.actualChildren;\n\t\t}\n\n\t\treturn treeChildren;\n\t}\n\n\t/**\n\t * @override\n\t */\n\tprotected override getRevealDepth(element: ByLocationTestItemElement) {\n\t\treturn element.depth === 1 ? Infinity : undefined;\n\t}\n}\n"]}