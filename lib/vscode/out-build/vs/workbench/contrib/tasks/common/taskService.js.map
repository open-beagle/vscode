{"version":3,"sources":["vs/workbench/contrib/tasks/common/taskService.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAgBnF,QAAA,+BAA+B,GAAG,IAAI,0BAAa,CAAU,0BAA0B,EAAE,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAgC,EAAE,IAAsH,CAAC,CAAC,CAAC;IACvQ,QAAA,8BAA8B,GAAG,IAAI,0BAAa,CAAU,yBAAyB,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAA+B,EAAE,IAAqH,CAAC,CAAC,CAAC;IACpQ,QAAA,gCAAgC,GAAG,IAAI,0BAAa,CAAU,2BAA2B,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAiC,EAAE,IAAuH,CAAC,CAAC,CAAC;IAE5Q,QAAA,YAAY,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAe,aAAa,CAAC,CAAC;IAkC5D,QAAA,oBAAoB,GAAG,UAAU,CAAC","file":"taskService.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { Action } from 'vs/base/common/actions';\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nimport { IWorkspaceFolder, IWorkspace } from 'vs/platform/workspace/common/workspace';\nimport { Task, ContributedTask, CustomTask, TaskSet, TaskSorter, TaskEvent, TaskIdentifier, ConfiguringTask, TaskRunSource } from 'vs/workbench/contrib/tasks/common/tasks';\nimport { ITaskSummary, TaskTerminateResponse, TaskSystemInfo } from 'vs/workbench/contrib/tasks/common/taskSystem';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\n\nexport { ITaskSummary, Task, TaskTerminateResponse };\n\nexport const CustomExecutionSupportedContext = new RawContextKey<boolean>('customExecutionSupported', true, nls.localize('tasks.customExecutionSupported', \"Whether CustomExecution tasks are supported. Consider using in the when clause of a \\'taskDefinition\\' contribution.\"));\nexport const ShellExecutionSupportedContext = new RawContextKey<boolean>('shellExecutionSupported', false, nls.localize('tasks.shellExecutionSupported', \"Whether ShellExecution tasks are supported. Consider using in the when clause of a \\'taskDefinition\\' contribution.\"));\nexport const ProcessExecutionSupportedContext = new RawContextKey<boolean>('processExecutionSupported', false, nls.localize('tasks.processExecutionSupported', \"Whether ProcessExecution tasks are supported. Consider using in the when clause of a \\'taskDefinition\\' contribution.\"));\n\nexport const ITaskService = createDecorator<ITaskService>('taskService');\n\nexport interface ITaskProvider {\n\tprovideTasks(validTypes: IStringDictionary<boolean>): Promise<TaskSet>;\n\tresolveTask(task: ConfiguringTask): Promise<ContributedTask | undefined>;\n}\n\nexport interface ProblemMatcherRunOptions {\n\tattachProblemMatcher?: boolean;\n}\n\nexport interface CustomizationProperties {\n\tgroup?: string | { kind?: string; isDefault?: boolean; };\n\tproblemMatcher?: string | string[];\n\tisBackground?: boolean;\n}\n\nexport interface TaskFilter {\n\tversion?: string;\n\ttype?: string;\n}\n\ninterface WorkspaceTaskResult {\n\tset: TaskSet | undefined;\n\tconfigurations: {\n\t\tbyIdentifier: IStringDictionary<ConfiguringTask>;\n\t} | undefined;\n\thasErrors: boolean;\n}\n\nexport interface WorkspaceFolderTaskResult extends WorkspaceTaskResult {\n\tworkspaceFolder: IWorkspaceFolder;\n}\n\nexport const USER_TASKS_GROUP_KEY = 'settings';\n\nexport interface ITaskService {\n\treadonly _serviceBrand: undefined;\n\tonDidStateChange: Event<TaskEvent>;\n\tsupportsMultipleTaskExecutions: boolean;\n\n\tconfigureAction(): Action;\n\trun(task: Task | undefined, options?: ProblemMatcherRunOptions): Promise<ITaskSummary | undefined>;\n\tinTerminal(): boolean;\n\tgetActiveTasks(): Promise<Task[]>;\n\tgetBusyTasks(): Promise<Task[]>;\n\tterminate(task: Task): Promise<TaskTerminateResponse>;\n\ttasks(filter?: TaskFilter): Promise<Task[]>;\n\ttaskTypes(): string[];\n\tgetWorkspaceTasks(runSource?: TaskRunSource): Promise<Map<string, WorkspaceFolderTaskResult>>;\n\treadRecentTasks(): Promise<(Task | ConfiguringTask)[]>;\n\tremoveRecentlyUsedTask(taskRecentlyUsedKey: string): void;\n\t/**\n\t * @param alias The task's name, label or defined identifier.\n\t */\n\tgetTask(workspaceFolder: IWorkspace | IWorkspaceFolder | string, alias: string | TaskIdentifier, compareId?: boolean): Promise<Task | undefined>;\n\ttryResolveTask(configuringTask: ConfiguringTask): Promise<Task | undefined>;\n\tcreateSorter(): TaskSorter;\n\n\tgetTaskDescription(task: Task | ConfiguringTask): string | undefined;\n\tcustomize(task: ContributedTask | CustomTask | ConfiguringTask, properties?: {}, openConfig?: boolean): Promise<void>;\n\topenConfig(task: CustomTask | ConfiguringTask | undefined): Promise<boolean>;\n\n\tregisterTaskProvider(taskProvider: ITaskProvider, type: string): IDisposable;\n\n\tregisterTaskSystem(scheme: string, taskSystemInfo: TaskSystemInfo): void;\n\tregisterSupportedExecutions(custom?: boolean, shell?: boolean, process?: boolean): void;\n\n\textensionCallbackTaskComplete(task: Task, result: number | undefined): Promise<void>;\n}\n"]}