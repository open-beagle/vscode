{"version":3,"file":"terminalLinkHelpers.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/contrib/terminal/browser/links/terminalLinkHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IViewportRange, IBufferRange, IBufferLine, IBuffer, IBufferCellPosition } from 'xterm';\nimport { IRange } from 'vs/editor/common/core/range';\n\nexport function convertLinkRangeToBuffer(lines: IBufferLine[], bufferWidth: number, range: IRange, startLine: number) {\n\tconst bufferRange: IBufferRange = {\n\t\tstart: {\n\t\t\tx: range.startColumn,\n\t\t\ty: range.startLineNumber + startLine\n\t\t},\n\t\tend: {\n\t\t\tx: range.endColumn - 1,\n\t\t\ty: range.endLineNumber + startLine\n\t\t}\n\t};\n\n\t// Shift start range right for each wide character before the link\n\tlet startOffset = 0;\n\tconst startWrappedLineCount = Math.ceil(range.startColumn / bufferWidth);\n\tfor (let y = 0; y < Math.min(startWrappedLineCount); y++) {\n\t\tconst lineLength = Math.min(bufferWidth, range.startColumn - y * bufferWidth);\n\t\tlet lineOffset = 0;\n\t\tconst line = lines[y];\n\t\t// Sanity check for line, apparently this can happen but it's not clear under what\n\t\t// circumstances this happens. Continue on, skipping the remainder of start offset if this\n\t\t// happens to minimize impact.\n\t\tif (!line) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (let x = 0; x < Math.min(bufferWidth, lineLength + lineOffset); x++) {\n\t\t\tconst cell = line.getCell(x)!;\n\t\t\tconst width = cell.getWidth();\n\t\t\tif (width === 2) {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\tconst char = cell.getChars();\n\t\t\tif (char.length > 1) {\n\t\t\t\tlineOffset -= char.length - 1;\n\t\t\t}\n\t\t}\n\t\tstartOffset += lineOffset;\n\t}\n\n\t// Shift end range right for each wide character inside the link\n\tlet endOffset = 0;\n\tconst endWrappedLineCount = Math.ceil(range.endColumn / bufferWidth);\n\tfor (let y = Math.max(0, startWrappedLineCount - 1); y < endWrappedLineCount; y++) {\n\t\tconst start = (y === startWrappedLineCount - 1 ? (range.startColumn + startOffset) % bufferWidth : 0);\n\t\tconst lineLength = Math.min(bufferWidth, range.endColumn + startOffset - y * bufferWidth);\n\t\tconst startLineOffset = (y === startWrappedLineCount - 1 ? startOffset : 0);\n\t\tlet lineOffset = 0;\n\t\tconst line = lines[y];\n\t\t// Sanity check for line, apparently this can happen but it's not clear under what\n\t\t// circumstances this happens. Continue on, skipping the remainder of start offset if this\n\t\t// happens to minimize impact.\n\t\tif (!line) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (let x = start; x < Math.min(bufferWidth, lineLength + lineOffset + startLineOffset); x++) {\n\t\t\tconst cell = line.getCell(x)!;\n\t\t\tconst width = cell.getWidth();\n\t\t\t// Offset for 0 cells following wide characters\n\t\t\tif (width === 2) {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t\t// Offset for early wrapping when the last cell in row is a wide character\n\t\t\tif (x === bufferWidth - 1 && cell.getChars() === '') {\n\t\t\t\tlineOffset++;\n\t\t\t}\n\t\t}\n\t\tendOffset += lineOffset;\n\t}\n\n\t// Apply the width character offsets to the result\n\tbufferRange.start.x += startOffset;\n\tbufferRange.end.x += startOffset + endOffset;\n\n\t// Convert back to wrapped lines\n\twhile (bufferRange.start.x > bufferWidth) {\n\t\tbufferRange.start.x -= bufferWidth;\n\t\tbufferRange.start.y++;\n\t}\n\twhile (bufferRange.end.x > bufferWidth) {\n\t\tbufferRange.end.x -= bufferWidth;\n\t\tbufferRange.end.y++;\n\t}\n\n\treturn bufferRange;\n}\n\nexport function convertBufferRangeToViewport(bufferRange: IBufferRange, viewportY: number): IViewportRange {\n\treturn {\n\t\tstart: {\n\t\t\tx: bufferRange.start.x - 1,\n\t\t\ty: bufferRange.start.y - viewportY - 1\n\t\t},\n\t\tend: {\n\t\t\tx: bufferRange.end.x - 1,\n\t\t\ty: bufferRange.end.y - viewportY - 1\n\t\t}\n\t};\n}\n\nexport function getXtermLineContent(buffer: IBuffer, lineStart: number, lineEnd: number, cols: number): string {\n\tlet content = '';\n\tfor (let i = lineStart; i <= lineEnd; i++) {\n\t\t// Make sure only 0 to cols are considered as resizing when windows mode is enabled will\n\t\t// retain buffer data outside of the terminal width as reflow is disabled.\n\t\tconst line = buffer.getLine(i);\n\t\tif (line) {\n\t\t\tcontent += line.translateToString(true, 0, cols);\n\t\t}\n\t}\n\treturn content;\n}\n\nexport function positionIsInRange(position: IBufferCellPosition, range: IBufferRange): boolean {\n\tif (position.y < range.start.y || position.y > range.end.y) {\n\t\treturn false;\n\t}\n\tif (position.y === range.start.y && position.x < range.start.x) {\n\t\treturn false;\n\t}\n\tif (position.y === range.end.y && position.x > range.end.x) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n"]}