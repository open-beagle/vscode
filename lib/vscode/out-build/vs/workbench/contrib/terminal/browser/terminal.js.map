{"version":3,"file":"terminal.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/contrib/terminal/browser/terminal.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAkBnF,QAAA,gBAAgB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAmB,iBAAiB,CAAC,CAAC;IACxE,QAAA,wBAAwB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAA2B,yBAAyB,CAAC,CAAC;IAChG,QAAA,sBAAsB,GAAG,CAAA,GAAA,+BAAe,CAAA,CAAyB,uBAAuB,CAAC,CAAC;IAwBvG,IAAkB,SAKjB;IALD,WAAkB,SAAS;QAC1B,yCAAQ,CAAA;QACR,2CAAS,CAAA;QACT,qCAAM,CAAA;QACN,yCAAQ,CAAA;IACT,CAAC,EALiB,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAK1B;IAqBD,IAAkB,uBAGjB;IAHD,WAAkB,uBAAuB;QACxC,iFAAU,CAAA;QACV,+EAAS,CAAA;IACV,CAAC,EAHiB,uBAAuB,GAAvB,+BAAuB,KAAvB,+BAAuB,QAGxC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Codicon } from 'vs/base/common/codicons';\nimport { Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { IProcessEnvironment } from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\nimport { FindReplaceState } from 'vs/editor/contrib/find/findState';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IOffProcessTerminalService, IShellLaunchConfig, ITerminalChildProcess, ITerminalDimensions, ITerminalLaunchError, ITerminalTabLayoutInfoById, TerminalShellType } from 'vs/platform/terminal/common/terminal';\nimport { IAvailableProfilesRequest, ICommandTracker, IDefaultShellAndArgsRequest, INavigationMode, IRemoteTerminalAttachTarget, ITerminalProfile, IStartExtensionTerminalRequest, ITerminalConfigHelper, ITerminalNativeWindowsDelegate, ITerminalProcessExtHostProxy, LinuxDistro, TitleEventSource } from 'vs/workbench/contrib/terminal/common/terminal';\nimport type { Terminal as XTermTerminal } from 'xterm';\nimport type { SearchAddon as XTermSearchAddon } from 'xterm-addon-search';\nimport type { Unicode11Addon as XTermUnicode11Addon } from 'xterm-addon-unicode11';\nimport type { WebglAddon as XTermWebglAddon } from 'xterm-addon-webgl';\nimport { ITerminalStatusList } from 'vs/workbench/contrib/terminal/browser/terminalStatusList';\nimport { ICompleteTerminalConfiguration } from 'vs/workbench/contrib/terminal/common/remoteTerminalChannel';\n\nexport const ITerminalService = createDecorator<ITerminalService>('terminalService');\nexport const ITerminalInstanceService = createDecorator<ITerminalInstanceService>('terminalInstanceService');\nexport const IRemoteTerminalService = createDecorator<IRemoteTerminalService>('remoteTerminalService');\n\n/**\n * A service used by TerminalInstance (and components owned by it) that allows it to break its\n * dependency on electron-browser and node layers, while at the same time avoiding a cyclic\n * dependency on ITerminalService.\n */\nexport interface ITerminalInstanceService {\n\treadonly _serviceBrand: undefined;\n\n\t// These events are optional as the requests they make are only needed on the browser side\n\tonRequestDefaultShellAndArgs?: Event<IDefaultShellAndArgsRequest>;\n\n\tgetXtermConstructor(): Promise<typeof XTermTerminal>;\n\tgetXtermSearchConstructor(): Promise<typeof XTermSearchAddon>;\n\tgetXtermUnicode11Constructor(): Promise<typeof XTermUnicode11Addon>;\n\tgetXtermWebglConstructor(): Promise<typeof XTermWebglAddon>;\n\tgetMainProcessParentEnv(): Promise<IProcessEnvironment>;\n}\n\nexport interface IBrowserTerminalConfigHelper extends ITerminalConfigHelper {\n\tpanelContainer: HTMLElement | undefined;\n}\n\nexport const enum Direction {\n\tLeft = 0,\n\tRight = 1,\n\tUp = 2,\n\tDown = 3\n}\n\nexport interface ITerminalTab {\n\tactiveInstance: ITerminalInstance | null;\n\tterminalInstances: ITerminalInstance[];\n\ttitle: string;\n\tonDisposed: Event<ITerminalTab>;\n\tonInstancesChanged: Event<void>;\n\tfocusPreviousPane(): void;\n\tfocusNextPane(): void;\n\tresizePane(direction: Direction): void;\n\tresizePanes(relativeSizes: number[]): void;\n\tsetActiveInstanceByIndex(index: number): void;\n\tattachToElement(element: HTMLElement): void;\n\tsetVisible(visible: boolean): void;\n\tlayout(width: number, height: number): void;\n\taddDisposable(disposable: IDisposable): void;\n\tsplit(shellLaunchConfig: IShellLaunchConfig): ITerminalInstance;\n\tgetLayoutInfo(isActive: boolean): ITerminalTabLayoutInfoById;\n}\n\nexport const enum TerminalConnectionState {\n\tConnecting,\n\tConnected\n}\n\nexport interface ITerminalService {\n\treadonly _serviceBrand: undefined;\n\n\tactiveTabIndex: number;\n\tconfigHelper: ITerminalConfigHelper;\n\tterminalInstances: ITerminalInstance[];\n\tterminalTabs: ITerminalTab[];\n\tisProcessSupportRegistered: boolean;\n\treadonly connectionState: TerminalConnectionState;\n\treadonly availableProfiles: ITerminalProfile[];\n\n\tinitializeTerminals(): Promise<void>;\n\tonActiveTabChanged: Event<void>;\n\tonTabDisposed: Event<ITerminalTab>;\n\tonInstanceCreated: Event<ITerminalInstance>;\n\tonInstanceDisposed: Event<ITerminalInstance>;\n\tonInstanceProcessIdReady: Event<ITerminalInstance>;\n\tonInstanceDimensionsChanged: Event<ITerminalInstance>;\n\tonInstanceMaximumDimensionsChanged: Event<ITerminalInstance>;\n\tonInstanceRequestStartExtensionTerminal: Event<IStartExtensionTerminalRequest>;\n\tonInstancesChanged: Event<void>;\n\tonInstanceTitleChanged: Event<ITerminalInstance | undefined>;\n\tonInstancePrimaryStatusChanged: Event<ITerminalInstance>;\n\tonActiveInstanceChanged: Event<ITerminalInstance | undefined>;\n\tonRequestAvailableProfiles: Event<IAvailableProfilesRequest>;\n\tonDidRegisterProcessSupport: Event<void>;\n\tonDidChangeConnectionState: Event<void>;\n\tonDidChangeAvailableProfiles: Event<ITerminalProfile[]>;\n\tonPanelMovedToSide: Event<void>;\n\n\t/**\n\t * Creates a terminal.\n\t * @param shell The shell launch configuration to use.\n\t */\n\tcreateTerminal(shell?: IShellLaunchConfig, cwd?: string | URI): ITerminalInstance;\n\n\t/**\n\t * Creates a terminal.\n\t * @param profile The profile to launch the terminal with.\n\t */\n\tcreateTerminal(profile: ITerminalProfile): ITerminalInstance;\n\n\t/**\n\t * Creates a raw terminal instance, this should not be used outside of the terminal part.\n\t */\n\tcreateInstance(container: HTMLElement | undefined, shellLaunchConfig: IShellLaunchConfig): ITerminalInstance;\n\tgetInstanceFromId(terminalId: number): ITerminalInstance | undefined;\n\tgetInstanceFromIndex(terminalIndex: number): ITerminalInstance;\n\tgetTabLabels(): string[];\n\tgetActiveInstance(): ITerminalInstance | null;\n\tsetActiveInstance(terminalInstance: ITerminalInstance): void;\n\tsetActiveInstanceByIndex(terminalIndex: number): void;\n\tgetActiveOrCreateInstance(): ITerminalInstance;\n\tsplitInstance(instance: ITerminalInstance, shell?: IShellLaunchConfig, cwd?: string | URI): ITerminalInstance | null;\n\tsplitInstance(instance: ITerminalInstance, profile: ITerminalProfile): ITerminalInstance | null;\n\n\t/**\n\t * Perform an action with the active terminal instance, if the terminal does\n\t * not exist the callback will not be called.\n\t * @param callback The callback that fires with the active terminal\n\t */\n\tdoWithActiveInstance<T>(callback: (terminal: ITerminalInstance) => T): T | void;\n\n\tgetActiveTab(): ITerminalTab | null;\n\tsetActiveTabToNext(): void;\n\tsetActiveTabToPrevious(): void;\n\tsetActiveTabByIndex(tabIndex: number): void;\n\n\t/**\n\t * Fire the onActiveTabChanged event, this will trigger the terminal dropdown to be updated,\n\t * among other things.\n\t */\n\trefreshActiveTab(): void;\n\n\tshowPanel(focus?: boolean): Promise<void>;\n\thidePanel(): void;\n\tfocusFindWidget(): Promise<void>;\n\thideFindWidget(): void;\n\tgetFindState(): FindReplaceState;\n\tfindNext(): void;\n\tfindPrevious(): void;\n\tfocusTabs(): void;\n\tshowTabs(): void;\n\n\tregisterProcessSupport(isSupported: boolean): void;\n\t/**\n\t * Registers a link provider that enables integrators to add links to the terminal.\n\t * @param linkProvider When registered, the link provider is asked whenever a cell is hovered\n\t * for links at that position. This lets the terminal know all links at a given area and also\n\t * labels for what these links are going to do.\n\t */\n\tregisterLinkProvider(linkProvider: ITerminalExternalLinkProvider): IDisposable;\n\n\tshowProfileQuickPick(type: 'setDefault' | 'createInstance', cwd?: string | URI): Promise<ITerminalInstance | undefined>;\n\n\tgetTabForInstance(instance: ITerminalInstance): ITerminalTab | undefined;\n\n\tsetContainers(panelContainer: HTMLElement, terminalContainer: HTMLElement): void;\n\n\t/**\n\t * Injects native Windows functionality into the service.\n\t */\n\tsetNativeWindowsDelegate(delegate: ITerminalNativeWindowsDelegate): void;\n\tsetLinuxDistro(linuxDistro: LinuxDistro): void;\n\n\t/**\n\t * Takes a path and returns the properly escaped path to send to the terminal.\n\t * On Windows, this included trying to prepare the path for WSL if needed.\n\t *\n\t * @param executable The executable off the shellLaunchConfig\n\t * @param title The terminal's title\n\t * @param path The path to be escaped and formatted.\n\t * @returns An escaped version of the path to be execuded in the terminal.\n\t */\n\tpreparePathForTerminalAsync(path: string, executable: string | undefined, title: string, shellType: TerminalShellType): Promise<string>;\n\n\textHostReady(remoteAuthority: string): void;\n\trequestStartExtensionTerminal(proxy: ITerminalProcessExtHostProxy, cols: number, rows: number): Promise<ITerminalLaunchError | undefined>;\n\tisAttachedToTerminal(remoteTerm: IRemoteTerminalAttachTarget): boolean;\n}\n\nexport interface IRemoteTerminalService extends IOffProcessTerminalService {\n\tcreateProcess(shellLaunchConfig: IShellLaunchConfig, configuration: ICompleteTerminalConfiguration, activeWorkspaceRootUri: URI | undefined, cols: number, rows: number, shouldPersist: boolean, configHelper: ITerminalConfigHelper): Promise<ITerminalChildProcess>;\n}\n\n/**\n * Similar to xterm.js' ILinkProvider but using promises and hides xterm.js internals (like buffer\n * positions, decorations, etc.) from the rest of vscode. This is the interface to use for\n * workbench integrations.\n */\nexport interface ITerminalExternalLinkProvider {\n\tprovideLinks(instance: ITerminalInstance, line: string): Promise<ITerminalLink[] | undefined>;\n}\n\nexport interface ITerminalLink {\n\t/** The startIndex of the link in the line. */\n\tstartIndex: number;\n\t/** The length of the link in the line. */\n\tlength: number;\n\t/** The descriptive label for what the link does when activated. */\n\tlabel?: string;\n\t/**\n\t * Activates the link.\n\t * @param text The text of the link.\n\t */\n\tactivate(text: string): void;\n}\n\nexport interface ISearchOptions {\n\t/** Whether the find should be done as a regex. */\n\tregex?: boolean;\n\t/** Whether only whole words should match. */\n\twholeWord?: boolean;\n\t/** Whether find should pay attention to case. */\n\tcaseSensitive?: boolean;\n\t/** Whether the search should start at the current search position (not the next row). */\n\tincremental?: boolean;\n}\n\nexport interface ITerminalBeforeHandleLinkEvent {\n\tterminal?: ITerminalInstance;\n\t/** The text of the link */\n\tlink: string;\n\t/** Call with whether the link was handled by the interceptor */\n\tresolve(wasHandled: boolean): void;\n}\n\nexport interface ITerminalInstance {\n\t/**\n\t * The ID of the terminal instance, this is an arbitrary number only used to uniquely identify\n\t * terminal instances within a window.\n\t */\n\treadonly instanceId: number;\n\t/**\n\t * A unique URI for this terminal instance with the following encoding:\n\t * path: Title\n\t * fragment: Instance ID\n\t */\n\treadonly resource: URI;\n\n\treadonly cols: number;\n\treadonly rows: number;\n\treadonly maxCols: number;\n\treadonly maxRows: number;\n\treadonly icon?: Codicon;\n\n\treadonly statusList: ITerminalStatusList;\n\n\t/**\n\t * The process ID of the shell process, this is undefined when there is no process associated\n\t * with this terminal.\n\t */\n\tprocessId: number | undefined;\n\n\t/**\n\t * The id of a persistent process. This is defined if this is a terminal created by a pty host\n\t * that supports reconnection.\n\t */\n\treadonly persistentProcessId: number | undefined;\n\n\t/**\n\t * Whether the process should be persisted across reloads.\n\t */\n\treadonly shouldPersist: boolean;\n\n\t/**\n\t * Whether the process communication channel has been disconnected.\n\t */\n\treadonly isDisconnected: boolean;\n\n\t/**\n\t * An event that fires when the terminal instance's title changes.\n\t */\n\tonTitleChanged: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that fires when the terminal instance is disposed.\n\t */\n\tonDisposed: Event<ITerminalInstance>;\n\n\tonFocused: Event<ITerminalInstance>;\n\tonProcessIdReady: Event<ITerminalInstance>;\n\tonLinksReady: Event<ITerminalInstance>;\n\tonRequestExtHostProcess: Event<ITerminalInstance>;\n\tonDimensionsChanged: Event<void>;\n\tonMaximumDimensionsChanged: Event<void>;\n\n\tonFocus: Event<ITerminalInstance>;\n\n\t/**\n\t * Attach a listener to the raw data stream coming from the pty, including ANSI escape\n\t * sequences.\n\t */\n\tonData: Event<string>;\n\n\t/**\n\t * Attach a listener to the binary data stream coming from xterm and going to pty\n\t */\n\tonBinary: Event<string>;\n\n\t/**\n\t * Attach a listener to listen for new lines added to this terminal instance.\n\t *\n\t * @param listener The listener function which takes new line strings added to the terminal,\n\t * excluding ANSI escape sequences. The line event will fire when an LF character is added to\n\t * the terminal (ie. the line is not wrapped). Note that this means that the line data will\n\t * not fire for the last line, until either the line is ended with a LF character of the process\n\t * is exited. The lineData string will contain the fully wrapped line, not containing any LF/CR\n\t * characters.\n\t */\n\tonLineData: Event<string>;\n\n\t/**\n\t * Attach a listener that fires when the terminal's pty process exits. The number in the event\n\t * is the processes' exit code, an exit code of null means the process was killed as a result of\n\t * the ITerminalInstance being disposed.\n\t */\n\tonExit: Event<number | undefined>;\n\n\treadonly exitCode: number | undefined;\n\n\treadonly areLinksReady: boolean;\n\n\t/**\n\t * Returns an array of data events that have fired within the first 10 seconds. If this is\n\t * called 10 seconds after the terminal has existed the result will be undefined. This is useful\n\t * when objects that depend on the data events have delayed initialization, like extension\n\t * hosts.\n\t */\n\treadonly initialDataEvents: string[] | undefined;\n\n\t/** A promise that resolves when the terminal's pty/process have been created. */\n\tprocessReady: Promise<void>;\n\n\t/**\n\t * The title of the terminal. This is either title or the process currently running or an\n\t * explicit name given to the terminal instance through the extension API.\n\t */\n\treadonly title: string;\n\n\t/**\n\t * The shell type of the terminal.\n\t */\n\treadonly shellType: TerminalShellType;\n\n\t/**\n\t * The focus state of the terminal before exiting.\n\t */\n\treadonly hadFocusOnExit: boolean;\n\n\t/**\n\t * False when the title is set by an API or the user. We check this to make sure we\n\t * do not override the title when the process title changes in the terminal.\n\t */\n\tisTitleSetByProcess: boolean;\n\n\t/**\n\t * The shell launch config used to launch the shell.\n\t */\n\treadonly shellLaunchConfig: IShellLaunchConfig;\n\n\t/**\n\t * Whether to disable layout for the terminal. This is useful when the size of the terminal is\n\t * being manipulating (e.g. adding a split pane) and we want the terminal to ignore particular\n\t * resize events.\n\t */\n\tdisableLayout: boolean;\n\n\t/**\n\t * An object that tracks when commands are run and enables navigating and selecting between\n\t * them.\n\t */\n\treadonly commandTracker: ICommandTracker | undefined;\n\n\treadonly navigationMode: INavigationMode | undefined;\n\n\t/**\n\t * Shows the environment information hover if the widget exists.\n\t */\n\tshowEnvironmentInfoHover(): void;\n\n\t/**\n\t * Dispose the terminal instance, removing it from the panel/service and freeing up resources.\n\t *\n\t * @param immediate Whether the kill should be immediate or not. Immediate should only be used\n\t * when VS Code is shutting down or in cases where the terminal dispose was user initiated.\n\t * The immediate===false exists to cover an edge case where the final output of the terminal can\n\t * get cut off. If immediate kill any terminal processes immediately.\n\t */\n\tdispose(immediate?: boolean): void;\n\n\t/**\n\t * Inform the process that the terminal is now detached.\n\t */\n\tdetachFromProcess(): void;\n\n\t/**\n\t * Forces the terminal to redraw its viewport.\n\t */\n\tforceRedraw(): void;\n\n\t/**\n\t * Check if anything is selected in terminal.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Copies the terminal selection to the clipboard.\n\t */\n\tcopySelection(): Promise<void>;\n\n\t/**\n\t * Current selection in the terminal.\n\t */\n\treadonly selection: string | undefined;\n\n\t/**\n\t * Clear current selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Select all text in the terminal.\n\t */\n\tselectAll(): void;\n\n\t/**\n\t * Find the next instance of the term\n\t*/\n\tfindNext(term: string, searchOptions: ISearchOptions): boolean;\n\n\t/**\n\t * Find the previous instance of the term\n\t */\n\tfindPrevious(term: string, searchOptions: ISearchOptions): boolean;\n\n\t/**\n\t * Notifies the terminal that the find widget's focus state has been changed.\n\t */\n\tnotifyFindWidgetFocusChanged(isFocused: boolean): void;\n\n\t/**\n\t * Focuses the terminal instance if it's able to (xterm.js instance exists).\n\t *\n\t * @param focus Force focus even if there is a selection.\n\t */\n\tfocus(force?: boolean): void;\n\n\t/**\n\t * Focuses the terminal instance when it's ready (the xterm.js instance is created). Use this\n\t * when the terminal is being shown.\n\t *\n\t * @param focus Force focus even if there is a selection.\n\t */\n\tfocusWhenReady(force?: boolean): Promise<void>;\n\n\t/**\n\t * Focuses and pastes the contents of the clipboard into the terminal instance.\n\t */\n\tpaste(): Promise<void>;\n\n\t/**\n\t * Focuses and pastes the contents of the selection clipboard into the terminal instance.\n\t */\n\tpasteSelection(): Promise<void>;\n\n\t/**\n\t * Send text to the terminal instance. The text is written to the stdin of the underlying pty\n\t * process (shell) of the terminal instance.\n\t *\n\t * @param text The text to send.\n\t * @param addNewLine Whether to add a new line to the text being sent, this is normally\n\t * required to run a command in the terminal. The character(s) added are \\n or \\r\\n\n\t * depending on the platform. This defaults to `true`.\n\t */\n\tsendText(text: string, addNewLine: boolean): void;\n\n\t/** Scroll the terminal buffer down 1 line. */\n\tscrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page. */\n\tscrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */\n\tscrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line. */\n\tscrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page. */\n\tscrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top. */\n\tscrollToTop(): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line.\n\t */\n\tclear(): void;\n\n\t/**\n\t * Attaches the terminal instance to an element on the DOM, before this is called the terminal\n\t * instance process may run in the background but cannot be displayed on the UI.\n\t *\n\t * @param container The element to attach the terminal instance to.\n\t */\n\tattachToElement(container: HTMLElement): void;\n\n\t/**\n\t * Configure the dimensions of the terminal instance.\n\t *\n\t * @param dimension The dimensions of the container.\n\t */\n\tlayout(dimension: { width: number, height: number }): void;\n\n\t/**\n\t * Sets whether the terminal instance's element is visible in the DOM.\n\t *\n\t * @param visible Whether the element is visible.\n\t */\n\tsetVisible(visible: boolean): void;\n\n\t/**\n\t * Immediately kills the terminal's current pty process and launches a new one to replace it.\n\t *\n\t * @param shell The new launch configuration.\n\t */\n\treuseTerminal(shell: IShellLaunchConfig): void;\n\n\t/**\n\t * Relaunches the terminal, killing it and reusing the launch config used initially. Any\n\t * environment variable changes will be recalculated when this happens.\n\t */\n\trelaunch(): void;\n\n\t/**\n\t * Sets the title of the terminal instance.\n\t */\n\tsetTitle(title: string, eventSource: TitleEventSource): void;\n\n\twaitForTitle(): Promise<string>;\n\n\tsetDimensions(dimensions: ITerminalDimensions): void;\n\n\taddDisposable(disposable: IDisposable): void;\n\n\ttoggleEscapeSequenceLogging(): void;\n\n\tgetInitialCwd(): Promise<string>;\n\tgetCwd(): Promise<string>;\n\n\t/**\n\t * @throws when called before xterm.js is ready.\n\t */\n\tregisterLinkProvider(provider: ITerminalExternalLinkProvider): IDisposable;\n\n\t/**\n\t * Triggers a quick pick to rename this terminal.\n\t */\n\trename(): Promise<void>;\n\n\t/**\n\t * Triggers a quick pick to rename this terminal.\n\t */\n\tchangeIcon(): Promise<void>;\n}\n"]}