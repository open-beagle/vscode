{"version":3,"file":"environmentVariableCollection.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/workbench/contrib/terminal/common/environmentVariableCollection.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IProcessEnvironment, isWindows } from 'vs/base/common/platform';\nimport { EnvironmentVariableMutatorType, IEnvironmentVariableCollection, IExtensionOwnedEnvironmentVariableMutator, IMergedEnvironmentVariableCollection, IMergedEnvironmentVariableCollectionDiff } from 'vs/workbench/contrib/terminal/common/environmentVariable';\n\nexport class MergedEnvironmentVariableCollection implements IMergedEnvironmentVariableCollection {\n\treadonly map: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\n\tconstructor(collections: Map<string, IEnvironmentVariableCollection>) {\n\t\tcollections.forEach((collection, extensionIdentifier) => {\n\t\t\tconst it = collection.map.entries();\n\t\t\tlet next = it.next();\n\t\t\twhile (!next.done) {\n\t\t\t\tconst variable = next.value[0];\n\t\t\t\tlet entry = this.map.get(variable);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tentry = [];\n\t\t\t\t\tthis.map.set(variable, entry);\n\t\t\t\t}\n\n\t\t\t\t// If the first item in the entry is replace ignore any other entries as they would\n\t\t\t\t// just get replaced by this one.\n\t\t\t\tif (entry.length > 0 && entry[0].type === EnvironmentVariableMutatorType.Replace) {\n\t\t\t\t\tnext = it.next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Mutators get applied in the reverse order than they are created\n\t\t\t\tconst mutator = next.value[1];\n\t\t\t\tentry.unshift({\n\t\t\t\t\textensionIdentifier,\n\t\t\t\t\tvalue: mutator.value,\n\t\t\t\t\ttype: mutator.type\n\t\t\t\t});\n\n\t\t\t\tnext = it.next();\n\t\t\t}\n\t\t});\n\t}\n\n\tapplyToProcessEnvironment(env: IProcessEnvironment, variableResolver?: (str: string) => string): void {\n\t\tlet lowerToActualVariableNames: { [lowerKey: string]: string | undefined } | undefined;\n\t\tif (isWindows) {\n\t\t\tlowerToActualVariableNames = {};\n\t\t\tObject.keys(env).forEach(e => lowerToActualVariableNames![e.toLowerCase()] = e);\n\t\t}\n\t\tthis.map.forEach((mutators, variable) => {\n\t\t\tconst actualVariable = isWindows ? lowerToActualVariableNames![variable.toLowerCase()] || variable : variable;\n\t\t\tmutators.forEach(mutator => {\n\t\t\t\tconst value = variableResolver ? variableResolver(mutator.value) : mutator.value;\n\t\t\t\tswitch (mutator.type) {\n\t\t\t\t\tcase EnvironmentVariableMutatorType.Append:\n\t\t\t\t\t\tenv[actualVariable] = (env[actualVariable] || '') + value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EnvironmentVariableMutatorType.Prepend:\n\t\t\t\t\t\tenv[actualVariable] = value + (env[actualVariable] || '');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EnvironmentVariableMutatorType.Replace:\n\t\t\t\t\t\tenv[actualVariable] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tdiff(other: IMergedEnvironmentVariableCollection): IMergedEnvironmentVariableCollectionDiff | undefined {\n\t\tconst added: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst changed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\t\tconst removed: Map<string, IExtensionOwnedEnvironmentVariableMutator[]> = new Map();\n\n\t\t// Find added\n\t\tother.map.forEach((otherMutators, variable) => {\n\t\t\tconst currentMutators = this.map.get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(otherMutators, currentMutators);\n\t\t\tif (result) {\n\t\t\t\tadded.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find removed\n\t\tthis.map.forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.map.get(variable);\n\t\t\tconst result = getMissingMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tremoved.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\t// Find changed\n\t\tthis.map.forEach((currentMutators, variable) => {\n\t\t\tconst otherMutators = other.map.get(variable);\n\t\t\tconst result = getChangedMutatorsFromArray(currentMutators, otherMutators);\n\t\t\tif (result) {\n\t\t\t\tchanged.set(variable, result);\n\t\t\t}\n\t\t});\n\n\t\tif (added.size === 0 && changed.size === 0 && removed.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { added, changed, removed };\n\t}\n}\n\nfunction getMissingMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, all are removed\n\tif (!other) {\n\t\treturn current;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Set<string>();\n\tother.forEach(m => otherMutatorExtensions.add(m.extensionIdentifier));\n\n\t// Find entries removed from other\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tif (!otherMutatorExtensions.has(mutator.extensionIdentifier)) {\n\t\t\tresult.push(mutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n\nfunction getChangedMutatorsFromArray(\n\tcurrent: IExtensionOwnedEnvironmentVariableMutator[],\n\tother: IExtensionOwnedEnvironmentVariableMutator[] | undefined\n): IExtensionOwnedEnvironmentVariableMutator[] | undefined {\n\t// If it doesn't exist, none are changed (they are removed)\n\tif (!other) {\n\t\treturn undefined;\n\t}\n\n\t// Create a map to help\n\tconst otherMutatorExtensions = new Map<string, IExtensionOwnedEnvironmentVariableMutator>();\n\tother.forEach(m => otherMutatorExtensions.set(m.extensionIdentifier, m));\n\n\t// Find entries that exist in both but are not equal\n\tconst result: IExtensionOwnedEnvironmentVariableMutator[] = [];\n\tcurrent.forEach(mutator => {\n\t\tconst otherMutator = otherMutatorExtensions.get(mutator.extensionIdentifier);\n\t\tif (otherMutator && (mutator.type !== otherMutator.type || mutator.value !== otherMutator.value)) {\n\t\t\t// Return the new result, not the old one\n\t\t\tresult.push(otherMutator);\n\t\t}\n\t});\n\n\treturn result.length === 0 ? undefined : result;\n}\n"]}