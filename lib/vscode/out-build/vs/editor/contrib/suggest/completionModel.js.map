{"version":3,"file":"completionModel.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/contrib/suggest/completionModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { fuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScorer, FuzzyScore, anyScore } from 'vs/base/common/filters';\nimport { CompletionItemProvider, CompletionItemKind } from 'vs/editor/common/modes';\nimport { CompletionItem } from './suggest';\nimport { InternalSuggestOptions } from 'vs/editor/common/config/editorOptions';\nimport { WordDistance } from 'vs/editor/contrib/suggest/wordDistance';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { compareIgnoreCase } from 'vs/base/common/strings';\nimport { quickSelect } from 'vs/base/common/arrays';\n\ntype StrictCompletionItem = Required<CompletionItem>;\n\nexport interface ICompletionStats {\n\tpLabelLen: number;\n}\n\nexport class LineContext {\n\tconstructor(\n\t\treadonly leadingLineContent: string,\n\t\treadonly characterCountDelta: number,\n\t) { }\n}\n\nconst enum Refilter {\n\tNothing = 0,\n\tAll = 1,\n\tIncr = 2\n}\n\n/**\n * Sorted, filtered completion view model\n * */\nexport class CompletionModel {\n\n\tprivate readonly _items: CompletionItem[];\n\tprivate readonly _column: number;\n\tprivate readonly _wordDistance: WordDistance;\n\tprivate readonly _options: InternalSuggestOptions;\n\tprivate readonly _snippetCompareFn = CompletionModel._compareCompletionItems;\n\n\tprivate _lineContext: LineContext;\n\tprivate _refilterKind: Refilter;\n\tprivate _filteredItems?: StrictCompletionItem[];\n\tprivate _providerInfo?: Map<CompletionItemProvider, boolean>;\n\tprivate _stats?: ICompletionStats;\n\n\tconstructor(\n\t\titems: CompletionItem[],\n\t\tcolumn: number,\n\t\tlineContext: LineContext,\n\t\twordDistance: WordDistance,\n\t\toptions: InternalSuggestOptions,\n\t\tsnippetSuggestions: 'top' | 'bottom' | 'inline' | 'none',\n\t\treadonly clipboardText: string | undefined\n\t) {\n\t\tthis._items = items;\n\t\tthis._column = column;\n\t\tthis._wordDistance = wordDistance;\n\t\tthis._options = options;\n\t\tthis._refilterKind = Refilter.All;\n\t\tthis._lineContext = lineContext;\n\n\t\tif (snippetSuggestions === 'top') {\n\t\t\tthis._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n\t\t} else if (snippetSuggestions === 'bottom') {\n\t\t\tthis._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n\t\t}\n\t}\n\n\tget lineContext(): LineContext {\n\t\treturn this._lineContext;\n\t}\n\n\tset lineContext(value: LineContext) {\n\t\tif (this._lineContext.leadingLineContent !== value.leadingLineContent\n\t\t\t|| this._lineContext.characterCountDelta !== value.characterCountDelta\n\t\t) {\n\t\t\tthis._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? Refilter.Incr : Refilter.All;\n\t\t\tthis._lineContext = value;\n\t\t}\n\t}\n\n\tget items(): CompletionItem[] {\n\t\tthis._ensureCachedState();\n\t\treturn this._filteredItems!;\n\t}\n\n\tget allProvider(): IterableIterator<CompletionItemProvider> {\n\t\tthis._ensureCachedState();\n\t\treturn this._providerInfo!.keys();\n\t}\n\n\tget incomplete(): Set<CompletionItemProvider> {\n\t\tthis._ensureCachedState();\n\t\tconst result = new Set<CompletionItemProvider>();\n\t\tfor (let [provider, incomplete] of this._providerInfo!) {\n\t\t\tif (incomplete) {\n\t\t\t\tresult.add(provider);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tadopt(except: Set<CompletionItemProvider>): CompletionItem[] {\n\t\tlet res: CompletionItem[] = [];\n\t\tfor (let i = 0; i < this._items.length;) {\n\t\t\tif (!except.has(this._items[i].provider)) {\n\t\t\t\tres.push(this._items[i]);\n\n\t\t\t\t// unordered removed\n\t\t\t\tthis._items[i] = this._items[this._items.length - 1];\n\t\t\t\tthis._items.pop();\n\t\t\t} else {\n\t\t\t\t// continue with next item\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tthis._refilterKind = Refilter.All;\n\t\treturn res;\n\t}\n\n\tget stats(): ICompletionStats {\n\t\tthis._ensureCachedState();\n\t\treturn this._stats!;\n\t}\n\n\tprivate _ensureCachedState(): void {\n\t\tif (this._refilterKind !== Refilter.Nothing) {\n\t\t\tthis._createCachedState();\n\t\t}\n\t}\n\n\tprivate _createCachedState(): void {\n\n\t\tthis._providerInfo = new Map();\n\n\t\tconst labelLengths: number[] = [];\n\n\t\tconst { leadingLineContent, characterCountDelta } = this._lineContext;\n\t\tlet word = '';\n\t\tlet wordLow = '';\n\n\t\t// incrementally filter less\n\t\tconst source = this._refilterKind === Refilter.All ? this._items : this._filteredItems!;\n\t\tconst target: StrictCompletionItem[] = [];\n\n\t\t// picks a score function based on the number of\n\t\t// items that we have to score/filter and based on the\n\t\t// user-configuration\n\t\tconst scoreFn: FuzzyScorer = (!this._options.filterGraceful || source.length > 2000) ? fuzzyScore : fuzzyScoreGracefulAggressive;\n\n\t\tfor (let i = 0; i < source.length; i++) {\n\n\t\t\tconst item = source[i];\n\n\t\t\tif (item.isInvalid) {\n\t\t\t\tcontinue; // SKIP invalid items\n\t\t\t}\n\n\t\t\t// collect all support, know if their result is incomplete\n\t\t\tthis._providerInfo.set(item.provider, Boolean(item.container.incomplete));\n\n\t\t\t// 'word' is that remainder of the current line that we\n\t\t\t// filter and score against. In theory each suggestion uses a\n\t\t\t// different word, but in practice not - that's why we cache\n\t\t\tconst overwriteBefore = item.position.column - item.editStart.column;\n\t\t\tconst wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n\t\t\tif (word.length !== wordLen) {\n\t\t\t\tword = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n\t\t\t\twordLow = word.toLowerCase();\n\t\t\t}\n\n\t\t\t// remember the word against which this item was\n\t\t\t// scored\n\t\t\titem.word = word;\n\n\t\t\tif (wordLen === 0) {\n\t\t\t\t// when there is nothing to score against, don't\n\t\t\t\t// event try to do. Use a const rank and rely on\n\t\t\t\t// the fallback-sort using the initial sort order.\n\t\t\t\t// use a score of `-100` because that is out of the\n\t\t\t\t// bound of values `fuzzyScore` will return\n\t\t\t\titem.score = FuzzyScore.Default;\n\n\t\t\t} else {\n\t\t\t\t// skip word characters that are whitespace until\n\t\t\t\t// we have hit the replace range (overwriteBefore)\n\t\t\t\tlet wordPos = 0;\n\t\t\t\twhile (wordPos < overwriteBefore) {\n\t\t\t\t\tconst ch = word.charCodeAt(wordPos);\n\t\t\t\t\tif (ch === CharCode.Space || ch === CharCode.Tab) {\n\t\t\t\t\t\twordPos += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (wordPos >= wordLen) {\n\t\t\t\t\t// the wordPos at which scoring starts is the whole word\n\t\t\t\t\t// and therefore the same rules as not having a word apply\n\t\t\t\t\titem.score = FuzzyScore.Default;\n\n\t\t\t\t} else if (typeof item.completion.filterText === 'string') {\n\t\t\t\t\t// when there is a `filterText` it must match the `word`.\n\t\t\t\t\t// if it matches we check with the label to compute highlights\n\t\t\t\t\t// and if that doesn't yield a result we have no highlights,\n\t\t\t\t\t// despite having the match\n\t\t\t\t\tlet match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow!, 0, false);\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue; // NO match\n\t\t\t\t\t}\n\t\t\t\t\tif (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {\n\t\t\t\t\t\t// filterText and label are actually the same -> use good highlights\n\t\t\t\t\t\titem.score = match;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// re-run the scorer on the label in the hope of a result BUT use the rank\n\t\t\t\t\t\t// of the filterText-match\n\t\t\t\t\t\titem.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\n\t\t\t\t\t\titem.score[0] = match[0]; // use score from filterText\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// by default match `word` against the `label`\n\t\t\t\t\tlet match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, false);\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue; // NO match\n\t\t\t\t\t}\n\t\t\t\t\titem.score = match;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titem.idx = i;\n\t\t\titem.distance = this._wordDistance.distance(item.position, item.completion);\n\t\t\ttarget.push(item as StrictCompletionItem);\n\n\t\t\t// update stats\n\t\t\tlabelLengths.push(item.textLabel.length);\n\t\t}\n\n\t\tthis._filteredItems = target.sort(this._snippetCompareFn);\n\t\tthis._refilterKind = Refilter.Nothing;\n\t\tthis._stats = {\n\t\t\tpLabelLen: labelLengths.length ?\n\t\t\t\tquickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b)\n\t\t\t\t: 0\n\t\t};\n\t}\n\n\tprivate static _compareCompletionItems(a: StrictCompletionItem, b: StrictCompletionItem): number {\n\t\tif (a.score[0] > b.score[0]) {\n\t\t\treturn -1;\n\t\t} else if (a.score[0] < b.score[0]) {\n\t\t\treturn 1;\n\t\t} else if (a.distance < b.distance) {\n\t\t\treturn -1;\n\t\t} else if (a.distance > b.distance) {\n\t\t\treturn 1;\n\t\t} else if (a.idx < b.idx) {\n\t\t\treturn -1;\n\t\t} else if (a.idx > b.idx) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate static _compareCompletionItemsSnippetsDown(a: StrictCompletionItem, b: StrictCompletionItem): number {\n\t\tif (a.completion.kind !== b.completion.kind) {\n\t\t\tif (a.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn 1;\n\t\t\t} else if (b.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn CompletionModel._compareCompletionItems(a, b);\n\t}\n\n\tprivate static _compareCompletionItemsSnippetsUp(a: StrictCompletionItem, b: StrictCompletionItem): number {\n\t\tif (a.completion.kind !== b.completion.kind) {\n\t\t\tif (a.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn -1;\n\t\t\t} else if (b.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn CompletionModel._compareCompletionItems(a, b);\n\t}\n}\n"]}