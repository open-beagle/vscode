{"version":3,"file":"minimapCharRendererFactory.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/browser/viewParts/minimap/minimapCharRendererFactory.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAQhG;;;;;;OAMG;IACH,MAAa,0BAA0B;QAItC;;WAEG;QACI,MAAM,CAAC,MAAM,CAAC,KAAa,EAAE,UAAkB;YACrD,mEAAmE;YACnE,2EAA2E;YAC3E,IAAI,IAAI,CAAC,WAAW,IAAI,KAAK,KAAK,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI,UAAU,KAAK,IAAI,CAAC,cAAc,EAAE;gBAC/F,OAAO,IAAI,CAAC,WAAW,CAAC;aACxB;YAED,IAAI,OAA4B,CAAC;YACjC,IAAI,kCAAgB,CAAC,KAAK,CAAC,EAAE;gBAC5B,OAAO,GAAG,IAAI,yCAAmB,CAAC,kCAAgB,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;aACpE;iBAAM;gBACN,OAAO,GAAG,0BAA0B,CAAC,oBAAoB,CACxD,0BAA0B,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC,IAAI,EAC5D,KAAK,CACL,CAAC;aACF;YAED,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC;YACjC,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC;YAC3B,OAAO,OAAO,CAAC;QAChB,CAAC;QAED;;WAEG;QACI,MAAM,CAAC,gBAAgB,CAAC,UAAkB;YAChD,MAAM,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YAChD,MAAM,GAAG,GAAG,MAAM,CAAC,UAAU,CAAC,IAAI,CAAE,CAAC;YAErC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,GAAG,4BAA6B,IAAI,CAAC;YAC3D,MAAM,CAAC,MAAM,+BAAgC,CAAC;YAC9C,MAAM,CAAC,KAAK,GAAG,iDAAmD,CAAC;YACnE,MAAM,CAAC,KAAK,CAAC,KAAK,GAAG,iDAAmD,GAAG,IAAI,CAAC;YAEhF,GAAG,CAAC,SAAS,GAAG,SAAS,CAAC;YAC1B,GAAG,CAAC,IAAI,GAAG,QAAQ,4BAA6B,MAAM,UAAU,EAAE,CAAC;YACnE,GAAG,CAAC,YAAY,GAAG,QAAQ,CAAC;YAE5B,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,KAAK,MAAM,IAAI,IAAI,+BAAY,EAAE;gBAChC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,+BAAgC,CAAC,CAAC,CAAC;gBAC9E,CAAC,+BAAgC,CAAC;aAClC;YAED,OAAO,GAAG,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,iDAAmD,+BAAgC,CAAC;QACnH,CAAC;QAED;;WAEG;QACI,MAAM,CAAC,oBAAoB,CAAC,MAAyB,EAAE,KAAa;YAC1E,MAAM,cAAc,GACnB,0DAA4D,4BAA8B,sBAAuB,CAAC;YACnH,IAAI,MAAM,CAAC,MAAM,KAAK,cAAc,EAAE;gBACrC,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;aAC5D;YAED,IAAI,QAAQ,GAAG,0BAA0B,CAAC,WAAW,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YACrE,OAAO,IAAI,yCAAmB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QACjD,CAAC;QAEO,MAAM,CAAC,eAAe,CAC7B,MAAyB,EACzB,YAAoB,EACpB,IAAuB,EACvB,UAAkB,EAClB,KAAa;YAEb,MAAM,KAAK,GAAG,0BAA4B,KAAK,CAAC;YAChD,MAAM,MAAM,GAAG,2BAA6B,KAAK,CAAC;YAElD,IAAI,WAAW,GAAG,UAAU,CAAC;YAC7B,IAAI,SAAS,GAAG,CAAC,CAAC;YAElB,yEAAyE;YACzE,0EAA0E;YAC1E,yEAAyE;YACzE,oCAAoC;YACpC,EAAE;YACF,4EAA4E;YAC5E,0EAA0E;YAC1E,0EAA0E;YAC1E,0EAA0E;YAC1E,oDAAoD;YACpD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;gBAChC,sEAAsE;gBACtE,2CAA2C;gBAC3C,MAAM,QAAQ,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,+BAAgC,CAAC;gBAC9D,MAAM,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,+BAAgC,CAAC;gBAEpE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;oBAC/B,MAAM,QAAQ,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,8BAA+B,CAAC;oBAC5D,MAAM,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,8BAA+B,CAAC;oBAElE,qEAAqE;oBACrE,6BAA6B;oBAC7B,IAAI,KAAK,GAAG,CAAC,CAAC;oBACd,IAAI,OAAO,GAAG,CAAC,CAAC;oBAChB,KAAK,IAAI,EAAE,GAAG,QAAQ,EAAE,EAAE,GAAG,QAAQ,EAAE,EAAE,EAAE,EAAE;wBAC5C,MAAM,SAAS,GAAG,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,oCAAmC,CAAC;wBACnF,MAAM,QAAQ,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;wBAC3C,KAAK,IAAI,EAAE,GAAG,QAAQ,EAAE,EAAE,GAAG,QAAQ,EAAE,EAAE,EAAE,EAAE;4BAC5C,MAAM,QAAQ,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;4BAC3C,MAAM,WAAW,GAAG,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,4BAA8B,CAAC;4BAE7E,MAAM,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;4BACnC,OAAO,IAAI,MAAM,CAAC;4BAClB,KAAK,IAAI,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,MAAM,CAAC;yBAC1E;qBACD;oBAED,MAAM,KAAK,GAAG,KAAK,GAAG,OAAO,CAAC;oBAC9B,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;oBACvC,IAAI,CAAC,WAAW,EAAE,CAAC,GAAG,CAAA,GAAA,cAAO,CAAA,CAAC,KAAK,CAAC,CAAC;iBACrC;aACD;YAED,OAAO,SAAS,CAAC;QAClB,CAAC;QAEO,MAAM,CAAC,WAAW,CAAC,IAAuB,EAAE,KAAa;YAChE,MAAM,kBAAkB,GAAG,2BAA6B,KAAK,0BAA4B,GAAG,KAAK,CAAC;YAClG,MAAM,SAAS,GAAG,kBAAkB,sBAAuB,CAAC;YAC5D,MAAM,MAAM,GAAG,IAAI,iBAAiB,CAAC,SAAS,CAAC,CAAC;YAEhD,IAAI,YAAY,GAAG,CAAC,CAAC;YACrB,IAAI,YAAY,GAAG,CAAC,CAAC;YACrB,IAAI,SAAS,GAAG,CAAC,CAAC;YAClB,KAAK,IAAI,SAAS,GAAG,CAAC,EAAE,SAAS,sBAAuB,EAAE,SAAS,EAAE,EAAE;gBACtE,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC,CAAC;gBACvG,YAAY,IAAI,kBAAkB,CAAC;gBACnC,YAAY,IAAI,uDAA0D,CAAC;aAC3E;YAED,IAAI,SAAS,GAAG,CAAC,EAAE;gBAClB,MAAM,MAAM,GAAG,GAAG,GAAG,SAAS,CAAC;gBAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;oBACnC,MAAM,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC;iBACpB;aACD;YAED,OAAO,MAAM,CAAC;QACf,CAAC;KACD;IAtJD,gEAsJC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { MinimapCharRenderer } from 'vs/editor/browser/viewParts/minimap/minimapCharRenderer';\nimport { allCharCodes } from 'vs/editor/browser/viewParts/minimap/minimapCharSheet';\nimport { prebakedMiniMaps } from 'vs/editor/browser/viewParts/minimap/minimapPreBaked';\nimport { Constants } from './minimapCharSheet';\nimport { toUint8 } from 'vs/base/common/uint';\n\n/**\n * Creates character renderers. It takes a 'scale' that determines how large\n * characters should be drawn. Using this, it draws data into a canvas and\n * then downsamples the characters as necessary for the current display.\n * This makes rendering more efficient, rather than drawing a full (tiny)\n * font, or downsampling in real-time.\n */\nexport class MinimapCharRendererFactory {\n\tprivate static lastCreated?: MinimapCharRenderer;\n\tprivate static lastFontFamily?: string;\n\n\t/**\n\t * Creates a new character renderer factory with the given scale.\n\t */\n\tpublic static create(scale: number, fontFamily: string) {\n\t\t// renderers are immutable. By default we'll 'create' a new minimap\n\t\t// character renderer whenever we switch editors, no need to do extra work.\n\t\tif (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\n\t\t\treturn this.lastCreated;\n\t\t}\n\n\t\tlet factory: MinimapCharRenderer;\n\t\tif (prebakedMiniMaps[scale]) {\n\t\t\tfactory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\n\t\t} else {\n\t\t\tfactory = MinimapCharRendererFactory.createFromSampleData(\n\t\t\t\tMinimapCharRendererFactory.createSampleData(fontFamily).data,\n\t\t\t\tscale\n\t\t\t);\n\t\t}\n\n\t\tthis.lastFontFamily = fontFamily;\n\t\tthis.lastCreated = factory;\n\t\treturn factory;\n\t}\n\n\t/**\n\t * Creates the font sample data, writing to a canvas.\n\t */\n\tpublic static createSampleData(fontFamily: string): ImageData {\n\t\tconst canvas = document.createElement('canvas');\n\t\tconst ctx = canvas.getContext('2d')!;\n\n\t\tcanvas.style.height = `${Constants.SAMPLED_CHAR_HEIGHT}px`;\n\t\tcanvas.height = Constants.SAMPLED_CHAR_HEIGHT;\n\t\tcanvas.width = Constants.CHAR_COUNT * Constants.SAMPLED_CHAR_WIDTH;\n\t\tcanvas.style.width = Constants.CHAR_COUNT * Constants.SAMPLED_CHAR_WIDTH + 'px';\n\n\t\tctx.fillStyle = '#ffffff';\n\t\tctx.font = `bold ${Constants.SAMPLED_CHAR_HEIGHT}px ${fontFamily}`;\n\t\tctx.textBaseline = 'middle';\n\n\t\tlet x = 0;\n\t\tfor (const code of allCharCodes) {\n\t\t\tctx.fillText(String.fromCharCode(code), x, Constants.SAMPLED_CHAR_HEIGHT / 2);\n\t\t\tx += Constants.SAMPLED_CHAR_WIDTH;\n\t\t}\n\n\t\treturn ctx.getImageData(0, 0, Constants.CHAR_COUNT * Constants.SAMPLED_CHAR_WIDTH, Constants.SAMPLED_CHAR_HEIGHT);\n\t}\n\n\t/**\n\t * Creates a character renderer from the canvas sample data.\n\t */\n\tpublic static createFromSampleData(source: Uint8ClampedArray, scale: number): MinimapCharRenderer {\n\t\tconst expectedLength =\n\t\t\tConstants.SAMPLED_CHAR_HEIGHT * Constants.SAMPLED_CHAR_WIDTH * Constants.RGBA_CHANNELS_CNT * Constants.CHAR_COUNT;\n\t\tif (source.length !== expectedLength) {\n\t\t\tthrow new Error('Unexpected source in MinimapCharRenderer');\n\t\t}\n\n\t\tlet charData = MinimapCharRendererFactory._downsample(source, scale);\n\t\treturn new MinimapCharRenderer(charData, scale);\n\t}\n\n\tprivate static _downsampleChar(\n\t\tsource: Uint8ClampedArray,\n\t\tsourceOffset: number,\n\t\tdest: Uint8ClampedArray,\n\t\tdestOffset: number,\n\t\tscale: number\n\t): number {\n\t\tconst width = Constants.BASE_CHAR_WIDTH * scale;\n\t\tconst height = Constants.BASE_CHAR_HEIGHT * scale;\n\n\t\tlet targetIndex = destOffset;\n\t\tlet brightest = 0;\n\n\t\t// This is essentially an ad-hoc rescaling algorithm. Standard approaches\n\t\t// like bicubic interpolation are awesome for scaling between image sizes,\n\t\t// but don't work so well when scaling to very small pixel values, we end\n\t\t// up with blurry, indistinct forms.\n\t\t//\n\t\t// The approach taken here is simply mapping each source pixel to the target\n\t\t// pixels, and taking the weighted values for all pixels in each, and then\n\t\t// averaging them out. Finally we apply an intensity boost in _downsample,\n\t\t// since when scaling to the smallest pixel sizes there's more black space\n\t\t// which causes characters to be much less distinct.\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\t// 1. For this destination pixel, get the source pixels we're sampling\n\t\t\t// from (x1, y1) to the next pixel (x2, y2)\n\t\t\tconst sourceY1 = (y / height) * Constants.SAMPLED_CHAR_HEIGHT;\n\t\t\tconst sourceY2 = ((y + 1) / height) * Constants.SAMPLED_CHAR_HEIGHT;\n\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst sourceX1 = (x / width) * Constants.SAMPLED_CHAR_WIDTH;\n\t\t\t\tconst sourceX2 = ((x + 1) / width) * Constants.SAMPLED_CHAR_WIDTH;\n\n\t\t\t\t// 2. Sample all of them, summing them up and weighting them. Similar\n\t\t\t\t// to bilinear interpolation.\n\t\t\t\tlet value = 0;\n\t\t\t\tlet samples = 0;\n\t\t\t\tfor (let sy = sourceY1; sy < sourceY2; sy++) {\n\t\t\t\t\tconst sourceRow = sourceOffset + Math.floor(sy) * Constants.RGBA_SAMPLED_ROW_WIDTH;\n\t\t\t\t\tconst yBalance = 1 - (sy - Math.floor(sy));\n\t\t\t\t\tfor (let sx = sourceX1; sx < sourceX2; sx++) {\n\t\t\t\t\t\tconst xBalance = 1 - (sx - Math.floor(sx));\n\t\t\t\t\t\tconst sourceIndex = sourceRow + Math.floor(sx) * Constants.RGBA_CHANNELS_CNT;\n\n\t\t\t\t\t\tconst weight = xBalance * yBalance;\n\t\t\t\t\t\tsamples += weight;\n\t\t\t\t\t\tvalue += ((source[sourceIndex] * source[sourceIndex + 3]) / 255) * weight;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst final = value / samples;\n\t\t\t\tbrightest = Math.max(brightest, final);\n\t\t\t\tdest[targetIndex++] = toUint8(final);\n\t\t\t}\n\t\t}\n\n\t\treturn brightest;\n\t}\n\n\tprivate static _downsample(data: Uint8ClampedArray, scale: number): Uint8ClampedArray {\n\t\tconst pixelsPerCharacter = Constants.BASE_CHAR_HEIGHT * scale * Constants.BASE_CHAR_WIDTH * scale;\n\t\tconst resultLen = pixelsPerCharacter * Constants.CHAR_COUNT;\n\t\tconst result = new Uint8ClampedArray(resultLen);\n\n\t\tlet resultOffset = 0;\n\t\tlet sourceOffset = 0;\n\t\tlet brightest = 0;\n\t\tfor (let charIndex = 0; charIndex < Constants.CHAR_COUNT; charIndex++) {\n\t\t\tbrightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\n\t\t\tresultOffset += pixelsPerCharacter;\n\t\t\tsourceOffset += Constants.SAMPLED_CHAR_WIDTH * Constants.RGBA_CHANNELS_CNT;\n\t\t}\n\n\t\tif (brightest > 0) {\n\t\t\tconst adjust = 255 / brightest;\n\t\t\tfor (let i = 0; i < resultLen; i++) {\n\t\t\t\tresult[i] *= adjust;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"]}