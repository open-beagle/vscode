{"version":3,"file":"editorBrowser.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/browser/editorBrowser.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport { IMouseEvent, IMouseWheelEvent } from 'vs/base/browser/mouseEvent';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { OverviewRulerPosition, ConfigurationChangedEvent, EditorLayoutInfo, IComputedEditorOptions, EditorOption, FindComputedEditorOptionValueById, IEditorOptions, IDiffEditorOptions } from 'vs/editor/common/config/editorOptions';\nimport { ICursorPositionChangedEvent, ICursorSelectionChangedEvent } from 'vs/editor/common/controller/cursorEvents';\nimport { IPosition, Position } from 'vs/editor/common/core/position';\nimport { IRange, Range } from 'vs/editor/common/core/range';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { IIdentifiedSingleEditOperation, IModelDecoration, IModelDeltaDecoration, ITextModel, ICursorStateComputer, IWordAtPosition } from 'vs/editor/common/model';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent } from 'vs/editor/common/model/textModelEvents';\nimport { OverviewRulerZone } from 'vs/editor/common/view/overviewZoneManager';\nimport { IEditorWhitespace } from 'vs/editor/common/viewLayout/linesLayout';\nimport { ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { IDiffComputationResult } from 'vs/editor/common/services/editorWorkerService';\nimport { IViewModel } from 'vs/editor/common/viewModel/viewModel';\n\n/**\n * A view zone is a full horizontal rectangle that 'pushes' text down.\n * The editor reserves space for view zones when rendering.\n */\nexport interface IViewZone {\n\t/**\n\t * The line number after which this zone should appear.\n\t * Use 0 to place a view zone before the first line number.\n\t */\n\tafterLineNumber: number;\n\t/**\n\t * The column after which this zone should appear.\n\t * If not set, the maxLineColumn of `afterLineNumber` will be used.\n\t */\n\tafterColumn?: number;\n\t/**\n\t * Suppress mouse down events.\n\t * If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.\n\t * Defaults to false\n\t */\n\tsuppressMouseDown?: boolean;\n\t/**\n\t * The height in lines of the view zone.\n\t * If specified, `heightInPx` will be used instead of this.\n\t * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.\n\t */\n\theightInLines?: number;\n\t/**\n\t * The height in px of the view zone.\n\t * If this is set, the editor will give preference to it rather than `heightInLines` above.\n\t * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.\n\t */\n\theightInPx?: number;\n\t/**\n\t * The minimum width in px of the view zone.\n\t * If this is set, the editor will ensure that the scroll width is >= than this value.\n\t */\n\tminWidthInPx?: number;\n\t/**\n\t * The dom node of the view zone\n\t */\n\tdomNode: HTMLElement;\n\t/**\n\t * An optional dom node for the view zone that will be placed in the margin area.\n\t */\n\tmarginDomNode?: HTMLElement | null;\n\t/**\n\t * Callback which gives the relative top of the view zone as it appears (taking scrolling into account).\n\t */\n\tonDomNodeTop?: (top: number) => void;\n\t/**\n\t * Callback which gives the height in pixels of the view zone.\n\t */\n\tonComputedHeight?: (height: number) => void;\n}\n/**\n * An accessor that allows for zones to be added or removed.\n */\nexport interface IViewZoneChangeAccessor {\n\t/**\n\t * Create a new view zone.\n\t * @param zone Zone to create\n\t * @return A unique identifier to the view zone.\n\t */\n\taddZone(zone: IViewZone): string;\n\t/**\n\t * Remove a zone\n\t * @param id A unique identifier to the view zone, as returned by the `addZone` call.\n\t */\n\tremoveZone(id: string): void;\n\t/**\n\t * Change a zone's position.\n\t * The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.\n\t */\n\tlayoutZone(id: string): void;\n}\n\n/**\n * A positioning preference for rendering content widgets.\n */\nexport const enum ContentWidgetPositionPreference {\n\t/**\n\t * Place the content widget exactly at a position\n\t */\n\tEXACT,\n\t/**\n\t * Place the content widget above a position\n\t */\n\tABOVE,\n\t/**\n\t * Place the content widget below a position\n\t */\n\tBELOW\n}\n/**\n * A position for rendering content widgets.\n */\nexport interface IContentWidgetPosition {\n\t/**\n\t * Desired position for the content widget.\n\t * `preference` will also affect the placement.\n\t */\n\tposition: IPosition | null;\n\t/**\n\t * Optionally, a range can be provided to further\n\t * define the position of the content widget.\n\t */\n\trange?: IRange | null;\n\t/**\n\t * Placement preference for position, in order of preference.\n\t */\n\tpreference: ContentWidgetPositionPreference[];\n}\n/**\n * A content widget renders inline with the text and can be easily placed 'near' an editor position.\n */\nexport interface IContentWidget {\n\t/**\n\t * Render this content widget in a location where it could overflow the editor's view dom node.\n\t */\n\tallowEditorOverflow?: boolean;\n\n\tsuppressMouseDown?: boolean;\n\t/**\n\t * Get a unique identifier of the content widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the content widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the content widget.\n\t * If null is returned, the content widget will be placed off screen.\n\t */\n\tgetPosition(): IContentWidgetPosition | null;\n\t/**\n\t * Optional function that is invoked before rendering\n\t * the content widget. If a dimension is returned the editor will\n\t * attempt to use it.\n\t */\n\tbeforeRender?(): editorCommon.IDimension | null;\n\t/**\n\t * Optional function that is invoked after rendering the content\n\t * widget. Is being invoked with the selected position preference\n\t * or `null` if not rendered.\n\t */\n\tafterRender?(position: ContentWidgetPositionPreference | null): void;\n}\n\n/**\n * A positioning preference for rendering overlay widgets.\n */\nexport const enum OverlayWidgetPositionPreference {\n\t/**\n\t * Position the overlay widget in the top right corner\n\t */\n\tTOP_RIGHT_CORNER,\n\n\t/**\n\t * Position the overlay widget in the bottom right corner\n\t */\n\tBOTTOM_RIGHT_CORNER,\n\n\t/**\n\t * Position the overlay widget in the top center\n\t */\n\tTOP_CENTER\n}\n/**\n * A position for rendering overlay widgets.\n */\nexport interface IOverlayWidgetPosition {\n\t/**\n\t * The position preference for the overlay widget.\n\t */\n\tpreference: OverlayWidgetPositionPreference | null;\n}\n/**\n * An overlay widgets renders on top of the text.\n */\nexport interface IOverlayWidget {\n\t/**\n\t * Get a unique identifier of the overlay widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the overlay widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the overlay widget.\n\t * If null is returned, the overlay widget is responsible to place itself.\n\t */\n\tgetPosition(): IOverlayWidgetPosition | null;\n}\n\n/**\n * Type of hit element with the mouse in the editor.\n */\nexport const enum MouseTargetType {\n\t/**\n\t * Mouse is on top of an unknown element.\n\t */\n\tUNKNOWN,\n\t/**\n\t * Mouse is on top of the textarea used for input.\n\t */\n\tTEXTAREA,\n\t/**\n\t * Mouse is on top of the glyph margin\n\t */\n\tGUTTER_GLYPH_MARGIN,\n\t/**\n\t * Mouse is on top of the line numbers\n\t */\n\tGUTTER_LINE_NUMBERS,\n\t/**\n\t * Mouse is on top of the line decorations\n\t */\n\tGUTTER_LINE_DECORATIONS,\n\t/**\n\t * Mouse is on top of the whitespace left in the gutter by a view zone.\n\t */\n\tGUTTER_VIEW_ZONE,\n\t/**\n\t * Mouse is on top of text in the content.\n\t */\n\tCONTENT_TEXT,\n\t/**\n\t * Mouse is on top of empty space in the content (e.g. after line text or below last line)\n\t */\n\tCONTENT_EMPTY,\n\t/**\n\t * Mouse is on top of a view zone in the content.\n\t */\n\tCONTENT_VIEW_ZONE,\n\t/**\n\t * Mouse is on top of a content widget.\n\t */\n\tCONTENT_WIDGET,\n\t/**\n\t * Mouse is on top of the decorations overview ruler.\n\t */\n\tOVERVIEW_RULER,\n\t/**\n\t * Mouse is on top of a scrollbar.\n\t */\n\tSCROLLBAR,\n\t/**\n\t * Mouse is on top of an overlay widget.\n\t */\n\tOVERLAY_WIDGET,\n\t/**\n\t * Mouse is outside of the editor.\n\t */\n\tOUTSIDE_EDITOR,\n}\n\n/**\n * Target hit with the mouse in the editor.\n */\nexport interface IMouseTarget {\n\t/**\n\t * The target element\n\t */\n\treadonly element: Element | null;\n\t/**\n\t * The target type\n\t */\n\treadonly type: MouseTargetType;\n\t/**\n\t * The 'approximate' editor position\n\t */\n\treadonly position: Position | null;\n\t/**\n\t * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).\n\t */\n\treadonly mouseColumn: number;\n\t/**\n\t * The 'approximate' editor range\n\t */\n\treadonly range: Range | null;\n\t/**\n\t * Some extra detail.\n\t */\n\treadonly detail: any;\n}\n/**\n * A mouse event originating from the editor.\n */\nexport interface IEditorMouseEvent {\n\treadonly event: IMouseEvent;\n\treadonly target: IMouseTarget;\n}\nexport interface IPartialEditorMouseEvent {\n\treadonly event: IMouseEvent;\n\treadonly target: IMouseTarget | null;\n}\n\n/**\n * A paste event originating from the editor.\n */\nexport interface IPasteEvent {\n\treadonly range: Range;\n\treadonly mode: string | null;\n}\n\n/**\n * An overview ruler\n * @internal\n */\nexport interface IOverviewRuler {\n\tgetDomNode(): HTMLElement;\n\tdispose(): void;\n\tsetZones(zones: OverviewRulerZone[]): void;\n\tsetLayout(position: OverviewRulerPosition): void;\n}\n\n/**\n * Editor aria options.\n * @internal\n */\nexport interface IEditorAriaOptions {\n\tactiveDescendant: string | undefined;\n\trole?: string;\n}\n\nexport interface IEditorConstructionOptions extends IEditorOptions {\n\t/**\n\t * The initial editor dimension (to avoid measuring the container).\n\t */\n\tdimension?: editorCommon.IDimension;\n\t/**\n\t * Place overflow widgets inside an external DOM node.\n\t * Defaults to an internal DOM node.\n\t */\n\toverflowWidgetsDomNode?: HTMLElement;\n}\n\nexport interface IDiffEditorConstructionOptions extends IDiffEditorOptions {\n\t/**\n\t * The initial editor dimension (to avoid measuring the container).\n\t */\n\tdimension?: editorCommon.IDimension;\n\n\t/**\n\t * Place overflow widgets inside an external DOM node.\n\t * Defaults to an internal DOM node.\n\t */\n\toverflowWidgetsDomNode?: HTMLElement;\n}\n\n/**\n * A rich code editor.\n */\nexport interface ICodeEditor extends editorCommon.IEditor {\n\t/**\n\t * This editor is used as an alternative to an <input> box, i.e. as a simple widget.\n\t * @internal\n\t */\n\treadonly isSimpleWidget: boolean;\n\t/**\n\t * An event emitted when the content of the current model has changed.\n\t * @event\n\t */\n\tonDidChangeModelContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the language of the current model has changed.\n\t * @event\n\t */\n\tonDidChangeModelLanguage(listener: (e: IModelLanguageChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the language configuration of the current model has changed.\n\t * @event\n\t */\n\tonDidChangeModelLanguageConfiguration(listener: (e: IModelLanguageConfigurationChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the options of the current model has changed.\n\t * @event\n\t */\n\tonDidChangeModelOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)\n\t * @event\n\t */\n\tonDidChangeConfiguration(listener: (e: ConfigurationChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the cursor position has changed.\n\t * @event\n\t */\n\tonDidChangeCursorPosition(listener: (e: ICursorPositionChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the cursor selection has changed.\n\t * @event\n\t */\n\tonDidChangeCursorSelection(listener: (e: ICursorSelectionChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).\n\t * @event\n\t */\n\tonDidChangeModel(listener: (e: editorCommon.IModelChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the decorations of the current model have changed.\n\t * @event\n\t */\n\tonDidChangeModelDecorations(listener: (e: IModelDecorationsChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the text inside this editor gained focus (i.e. cursor starts blinking).\n\t * @event\n\t */\n\tonDidFocusEditorText(listener: () => void): IDisposable;\n\t/**\n\t * An event emitted when the text inside this editor lost focus (i.e. cursor stops blinking).\n\t * @event\n\t */\n\tonDidBlurEditorText(listener: () => void): IDisposable;\n\t/**\n\t * An event emitted when the text inside this editor or an editor widget gained focus.\n\t * @event\n\t */\n\tonDidFocusEditorWidget(listener: () => void): IDisposable;\n\t/**\n\t * An event emitted when the text inside this editor or an editor widget lost focus.\n\t * @event\n\t */\n\tonDidBlurEditorWidget(listener: () => void): IDisposable;\n\t/**\n\t * An event emitted before interpreting typed characters (on the keyboard).\n\t * @event\n\t * @internal\n\t */\n\tonWillType(listener: (text: string) => void): IDisposable;\n\t/**\n\t * An event emitted after interpreting typed characters (on the keyboard).\n\t * @event\n\t * @internal\n\t */\n\tonDidType(listener: (text: string) => void): IDisposable;\n\t/**\n\t * An event emitted after composition has started.\n\t */\n\tonDidCompositionStart(listener: () => void): IDisposable;\n\t/**\n\t * An event emitted after composition has ended.\n\t */\n\tonDidCompositionEnd(listener: () => void): IDisposable;\n\t/**\n\t * An event emitted when editing failed because the editor is read-only.\n\t * @event\n\t */\n\tonDidAttemptReadOnlyEdit(listener: () => void): IDisposable;\n\t/**\n\t * An event emitted when users paste text in the editor.\n\t * @event\n\t */\n\tonDidPaste(listener: (e: IPasteEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"mouseup\".\n\t * @event\n\t */\n\tonMouseUp(listener: (e: IEditorMouseEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"mousedown\".\n\t * @event\n\t */\n\tonMouseDown(listener: (e: IEditorMouseEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"mousedrag\".\n\t * @internal\n\t * @event\n\t */\n\tonMouseDrag(listener: (e: IEditorMouseEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"mousedrop\".\n\t * @internal\n\t * @event\n\t */\n\tonMouseDrop(listener: (e: IPartialEditorMouseEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"mousedropcanceled\".\n\t * @internal\n\t * @event\n\t */\n\tonMouseDropCanceled(listener: () => void): IDisposable;\n\t/**\n\t * An event emitted on a \"contextmenu\".\n\t * @event\n\t */\n\tonContextMenu(listener: (e: IEditorMouseEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"mousemove\".\n\t * @event\n\t */\n\tonMouseMove(listener: (e: IEditorMouseEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"mouseleave\".\n\t * @event\n\t */\n\tonMouseLeave(listener: (e: IPartialEditorMouseEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"mousewheel\"\n\t * @event\n\t * @internal\n\t */\n\tonMouseWheel(listener: (e: IMouseWheelEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"keyup\".\n\t * @event\n\t */\n\tonKeyUp(listener: (e: IKeyboardEvent) => void): IDisposable;\n\t/**\n\t * An event emitted on a \"keydown\".\n\t * @event\n\t */\n\tonKeyDown(listener: (e: IKeyboardEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the layout of the editor has changed.\n\t * @event\n\t */\n\tonDidLayoutChange(listener: (e: EditorLayoutInfo) => void): IDisposable;\n\t/**\n\t * An event emitted when the content width or content height in the editor has changed.\n\t * @event\n\t */\n\tonDidContentSizeChange(listener: (e: editorCommon.IContentSizeChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when the scroll in the editor has changed.\n\t * @event\n\t */\n\tonDidScrollChange(listener: (e: editorCommon.IScrollEvent) => void): IDisposable;\n\n\t/**\n\t * Saves current view state of the editor in a serializable object.\n\t */\n\tsaveViewState(): editorCommon.ICodeEditorViewState | null;\n\n\t/**\n\t * Restores the view state of the editor from a serializable object generated by `saveViewState`.\n\t */\n\trestoreViewState(state: editorCommon.ICodeEditorViewState): void;\n\n\t/**\n\t * Returns true if the text inside this editor or an editor widget has focus.\n\t */\n\thasWidgetFocus(): boolean;\n\n\t/**\n\t * Get a contribution of this editor.\n\t * @id Unique identifier of the contribution.\n\t * @return The contribution or null if contribution not found.\n\t */\n\tgetContribution<T extends editorCommon.IEditorContribution>(id: string): T;\n\n\t/**\n\t * Execute `fn` with the editor's services.\n\t * @internal\n\t */\n\tinvokeWithinContext<T>(fn: (accessor: ServicesAccessor) => T): T;\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): ITextModel | null;\n\n\t/**\n\t * Sets the current model attached to this editor.\n\t * If the previous model was created by the editor via the value key in the options\n\t * literal object, it will be destroyed. Otherwise, if the previous model was set\n\t * via setModel, or the model key in the options literal object, the previous model\n\t * will not be destroyed.\n\t * It is safe to call setModel(null) to simply detach the current model from the editor.\n\t */\n\tsetModel(model: ITextModel | null): void;\n\n\t/**\n\t * Gets all the editor computed options.\n\t */\n\tgetOptions(): IComputedEditorOptions;\n\n\t/**\n\t * Gets a specific editor option.\n\t */\n\tgetOption<T extends EditorOption>(id: T): FindComputedEditorOptionValueById<T>;\n\n\t/**\n\t * Returns the editor's configuration (without any validation or defaults).\n\t */\n\tgetRawOptions(): IEditorOptions;\n\n\t/**\n\t * @internal\n\t */\n\tgetOverflowWidgetsDomNode(): HTMLElement | undefined;\n\n\t/**\n\t * @internal\n\t */\n\tgetConfiguredWordAtPosition(position: Position): IWordAtPosition | null;\n\n\t/**\n\t * Get value of the current model attached to this editor.\n\t * @see `ITextModel.getValue`\n\t */\n\tgetValue(options?: { preserveBOM: boolean; lineEnding: string; }): string;\n\n\t/**\n\t * Set the value of the current model attached to this editor.\n\t * @see `ITextModel.setValue`\n\t */\n\tsetValue(newValue: string): void;\n\n\t/**\n\t * Get the width of the editor's content.\n\t * This is information that is \"erased\" when computing `scrollWidth = Math.max(contentWidth, width)`\n\t */\n\tgetContentWidth(): number;\n\t/**\n\t * Get the scrollWidth of the editor's viewport.\n\t */\n\tgetScrollWidth(): number;\n\t/**\n\t * Get the scrollLeft of the editor's viewport.\n\t */\n\tgetScrollLeft(): number;\n\n\t/**\n\t * Get the height of the editor's content.\n\t * This is information that is \"erased\" when computing `scrollHeight = Math.max(contentHeight, height)`\n\t */\n\tgetContentHeight(): number;\n\t/**\n\t * Get the scrollHeight of the editor's viewport.\n\t */\n\tgetScrollHeight(): number;\n\t/**\n\t * Get the scrollTop of the editor's viewport.\n\t */\n\tgetScrollTop(): number;\n\n\t/**\n\t * Change the scrollLeft of the editor's viewport.\n\t */\n\tsetScrollLeft(newScrollLeft: number, scrollType?: editorCommon.ScrollType): void;\n\t/**\n\t * Change the scrollTop of the editor's viewport.\n\t */\n\tsetScrollTop(newScrollTop: number, scrollType?: editorCommon.ScrollType): void;\n\t/**\n\t * Change the scroll position of the editor's viewport.\n\t */\n\tsetScrollPosition(position: editorCommon.INewScrollPosition, scrollType?: editorCommon.ScrollType): void;\n\n\t/**\n\t * Get an action that is a contribution to this editor.\n\t * @id Unique identifier of the contribution.\n\t * @return The action or null if action not found.\n\t */\n\tgetAction(id: string): editorCommon.IEditorAction;\n\n\t/**\n\t * Execute a command on the editor.\n\t * The edits will land on the undo-redo stack, but no \"undo stop\" will be pushed.\n\t * @param source The source of the call.\n\t * @param command The command to execute\n\t */\n\texecuteCommand(source: string | null | undefined, command: editorCommon.ICommand): void;\n\n\t/**\n\t * Create an \"undo stop\" in the undo-redo stack.\n\t */\n\tpushUndoStop(): boolean;\n\n\t/**\n\t * Remove the \"undo stop\" in the undo-redo stack.\n\t */\n\tpopUndoStop(): boolean;\n\n\t/**\n\t * Execute edits on the editor.\n\t * The edits will land on the undo-redo stack, but no \"undo stop\" will be pushed.\n\t * @param source The source of the call.\n\t * @param edits The edits to execute.\n\t * @param endCursorState Cursor state after the edits were applied.\n\t */\n\texecuteEdits(source: string | null | undefined, edits: IIdentifiedSingleEditOperation[], endCursorState?: ICursorStateComputer | Selection[]): boolean;\n\n\t/**\n\t * Execute multiple (concomitant) commands on the editor.\n\t * @param source The source of the call.\n\t * @param command The commands to execute\n\t */\n\texecuteCommands(source: string | null | undefined, commands: (editorCommon.ICommand | null)[]): void;\n\n\t/**\n\t * @internal\n\t */\n\t_getViewModel(): IViewModel | null;\n\n\t/**\n\t * Get all the decorations on a line (filtering out decorations from other editors).\n\t */\n\tgetLineDecorations(lineNumber: number): IModelDecoration[] | null;\n\n\t/**\n\t * All decorations added through this call will get the ownerId of this editor.\n\t * @see `ITextModel.deltaDecorations`\n\t */\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];\n\n\t/**\n\t * @internal\n\t */\n\tsetDecorations(decorationTypeKey: string, ranges: editorCommon.IDecorationOptions[]): void;\n\n\t/**\n\t * @internal\n\t */\n\tsetDecorationsFast(decorationTypeKey: string, ranges: IRange[]): void;\n\n\t/**\n\t * @internal\n\t */\n\tremoveDecorations(decorationTypeKey: string): void;\n\n\t/**\n\t * Get the layout info for the editor.\n\t */\n\tgetLayoutInfo(): EditorLayoutInfo;\n\n\t/**\n\t * Returns the ranges that are currently visible.\n\t * Does not account for horizontal scrolling.\n\t */\n\tgetVisibleRanges(): Range[];\n\n\t/**\n\t * @internal\n\t */\n\tgetVisibleRangesPlusViewportAboveBelow(): Range[];\n\n\t/**\n\t * Get the view zones.\n\t * @internal\n\t */\n\tgetWhitespaces(): IEditorWhitespace[];\n\n\t/**\n\t * Get the vertical position (top offset) for the line w.r.t. to the first line.\n\t */\n\tgetTopForLineNumber(lineNumber: number): number;\n\n\t/**\n\t * Get the vertical position (top offset) for the position w.r.t. to the first line.\n\t */\n\tgetTopForPosition(lineNumber: number, column: number): number;\n\n\t/**\n\t * Set the model ranges that will be hidden in the view.\n\t * @internal\n\t */\n\tsetHiddenAreas(ranges: IRange[]): void;\n\n\t/**\n\t * Sets the editor aria options, primarily the active descendent.\n\t * @internal\n\t */\n\tsetAriaOptions(options: IEditorAriaOptions): void;\n\n\t/**\n\t * @internal\n\t */\n\tgetTelemetryData(): { [key: string]: any } | undefined;\n\n\t/**\n\t * Returns the editor's container dom node\n\t */\n\tgetContainerDomNode(): HTMLElement;\n\n\t/**\n\t * Returns the editor's dom node\n\t */\n\tgetDomNode(): HTMLElement | null;\n\n\t/**\n\t * Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddContentWidget(widget: IContentWidget): void;\n\t/**\n\t * Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropriately.\n\t */\n\tlayoutContentWidget(widget: IContentWidget): void;\n\t/**\n\t * Remove a content widget.\n\t */\n\tremoveContentWidget(widget: IContentWidget): void;\n\n\t/**\n\t * Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddOverlayWidget(widget: IOverlayWidget): void;\n\t/**\n\t * Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropriately.\n\t */\n\tlayoutOverlayWidget(widget: IOverlayWidget): void;\n\t/**\n\t * Remove an overlay widget.\n\t */\n\tremoveOverlayWidget(widget: IOverlayWidget): void;\n\n\t/**\n\t * Change the view zones. View zones are lost when a new model is attached to the editor.\n\t */\n\tchangeViewZones(callback: (accessor: IViewZoneChangeAccessor) => void): void;\n\n\t/**\n\t * Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.\n\t * This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).\n\t * Use this method with caution.\n\t */\n\tgetOffsetForColumn(lineNumber: number, column: number): number;\n\n\t/**\n\t * Force an editor render now.\n\t */\n\trender(forceRedraw?: boolean): void;\n\n\t/**\n\t * Get the hit test target at coordinates `clientX` and `clientY`.\n\t * The coordinates are relative to the top-left of the viewport.\n\t *\n\t * @returns Hit test target or null if the coordinates fall outside the editor or the editor has no model.\n\t */\n\tgetTargetAtClientPoint(clientX: number, clientY: number): IMouseTarget | null;\n\n\t/**\n\t * Get the visible position for `position`.\n\t * The result position takes scrolling into account and is relative to the top left corner of the editor.\n\t * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.\n\t * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.\n\t * Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.\n\t */\n\tgetScrolledVisiblePosition(position: IPosition): { top: number; left: number; height: number; } | null;\n\n\t/**\n\t * Apply the same font settings as the editor to `target`.\n\t */\n\tapplyFontInfo(target: HTMLElement): void;\n\n\t/**\n\t * Check if the current instance has a model attached.\n\t * @internal\n\t */\n\thasModel(): this is IActiveCodeEditor;\n}\n\n/**\n * @internal\n */\nexport interface IActiveCodeEditor extends ICodeEditor {\n\t/**\n\t * Returns the primary position of the cursor.\n\t */\n\tgetPosition(): Position;\n\n\t/**\n\t * Returns the primary selection of the editor.\n\t */\n\tgetSelection(): Selection;\n\n\t/**\n\t * Returns all the selections of the editor.\n\t */\n\tgetSelections(): Selection[];\n\n\t/**\n\t * Saves current view state of the editor in a serializable object.\n\t */\n\tsaveViewState(): editorCommon.ICodeEditorViewState;\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): ITextModel;\n\n\t/**\n\t * @internal\n\t */\n\t_getViewModel(): IViewModel;\n\n\t/**\n\t * Get all the decorations on a line (filtering out decorations from other editors).\n\t */\n\tgetLineDecorations(lineNumber: number): IModelDecoration[];\n\n\t/**\n\t * Returns the editor's dom node\n\t */\n\tgetDomNode(): HTMLElement;\n\n\t/**\n\t * Get the visible position for `position`.\n\t * The result position takes scrolling into account and is relative to the top left corner of the editor.\n\t * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.\n\t * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.\n\t * Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.\n\t */\n\tgetScrolledVisiblePosition(position: IPosition): { top: number; left: number; height: number; };\n}\n\n/**\n * Information about a line in the diff editor\n */\nexport interface IDiffLineInformation {\n\treadonly equivalentLineNumber: number;\n}\n\n/**\n * @internal\n */\nexport const enum DiffEditorState {\n\tIdle,\n\tComputingDiff,\n\tDiffComputed\n}\n\n/**\n * A rich diff editor.\n */\nexport interface IDiffEditor extends editorCommon.IEditor {\n\n\t/**\n\t * Returns whether the diff editor is ignoring trim whitespace or not.\n\t * @internal\n\t */\n\treadonly ignoreTrimWhitespace: boolean;\n\t/**\n\t * Returns whether the diff editor is rendering side by side or not.\n\t * @internal\n\t */\n\treadonly renderSideBySide: boolean;\n\t/**\n\t * Returns whether the diff editor is rendering +/- indicators or not.\n\t * @internal\n\t */\n\treadonly renderIndicators: boolean;\n\t/**\n\t * Timeout in milliseconds after which diff computation is cancelled.\n\t * @internal\n\t */\n\treadonly maxComputationTime: number;\n\n\t/**\n\t * @see ICodeEditor.getDomNode\n\t */\n\tgetDomNode(): HTMLElement;\n\n\t/**\n\t * An event emitted when the diff information computed by this diff editor has been updated.\n\t * @event\n\t */\n\tonDidUpdateDiff(listener: () => void): IDisposable;\n\n\t/**\n\t * Saves current view state of the editor in a serializable object.\n\t */\n\tsaveViewState(): editorCommon.IDiffEditorViewState | null;\n\n\t/**\n\t * Restores the view state of the editor from a serializable object generated by `saveViewState`.\n\t */\n\trestoreViewState(state: editorCommon.IDiffEditorViewState): void;\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): editorCommon.IDiffEditorModel | null;\n\n\t/**\n\t * Sets the current model attached to this editor.\n\t * If the previous model was created by the editor via the value key in the options\n\t * literal object, it will be destroyed. Otherwise, if the previous model was set\n\t * via setModel, or the model key in the options literal object, the previous model\n\t * will not be destroyed.\n\t * It is safe to call setModel(null) to simply detach the current model from the editor.\n\t */\n\tsetModel(model: editorCommon.IDiffEditorModel | null): void;\n\n\t/**\n\t * Get the `original` editor.\n\t */\n\tgetOriginalEditor(): ICodeEditor;\n\n\t/**\n\t * Get the `modified` editor.\n\t */\n\tgetModifiedEditor(): ICodeEditor;\n\n\t/**\n\t * Get the computed diff information.\n\t */\n\tgetLineChanges(): editorCommon.ILineChange[] | null;\n\n\t/**\n\t * Get the computed diff information.\n\t * @internal\n\t */\n\tgetDiffComputationResult(): IDiffComputationResult | null;\n\n\t/**\n\t * Get information based on computed diff about a line number from the original model.\n\t * If the diff computation is not finished or the model is missing, will return null.\n\t */\n\tgetDiffLineInformationForOriginal(lineNumber: number): IDiffLineInformation | null;\n\n\t/**\n\t * Get information based on computed diff about a line number from the modified model.\n\t * If the diff computation is not finished or the model is missing, will return null.\n\t */\n\tgetDiffLineInformationForModified(lineNumber: number): IDiffLineInformation | null;\n\n\t/**\n\t * Update the editor's options after the editor has been created.\n\t */\n\tupdateOptions(newOptions: IDiffEditorOptions): void;\n}\n\n/**\n *@internal\n */\nexport function isCodeEditor(thing: unknown): thing is ICodeEditor {\n\tif (thing && typeof (<ICodeEditor>thing).getEditorType === 'function') {\n\t\treturn (<ICodeEditor>thing).getEditorType() === editorCommon.EditorType.ICodeEditor;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n *@internal\n */\nexport function isDiffEditor(thing: unknown): thing is IDiffEditor {\n\tif (thing && typeof (<IDiffEditor>thing).getEditorType === 'function') {\n\t\treturn (<IDiffEditor>thing).getEditorType() === editorCommon.EditorType.IDiffEditor;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n *@internal\n */\nexport function isCompositeEditor(thing: unknown): thing is editorCommon.ICompositeCodeEditor {\n\treturn !!thing\n\t\t&& typeof thing === 'object'\n\t\t&& typeof (<editorCommon.ICompositeCodeEditor>thing).onDidChangeActiveEditor === 'function';\n\n}\n\n/**\n *@internal\n */\nexport function getCodeEditor(thing: unknown): ICodeEditor | null {\n\tif (isCodeEditor(thing)) {\n\t\treturn thing;\n\t}\n\n\tif (isDiffEditor(thing)) {\n\t\treturn thing.getModifiedEditor();\n\t}\n\n\treturn null;\n}\n\n/**\n *@internal\n */\nexport function getIEditor(thing: any): editorCommon.IEditor | null {\n\tif (isCodeEditor(thing) || isDiffEditor(thing)) {\n\t\treturn thing;\n\t}\n\n\treturn null;\n}\n"]}