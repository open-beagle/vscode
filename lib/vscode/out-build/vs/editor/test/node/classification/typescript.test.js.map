{"version":3,"file":"typescript.test.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/test/node/classification/typescript.test.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\nimport { StandardTokenType } from 'vs/editor/common/modes';\nimport * as fs from 'fs';\n// import { getPathFromAmdModule } from 'vs/base/test/node/testUtils';\n// import { parse } from 'vs/editor/common/modes/tokenization/typescript';\nimport { toStandardTokenType } from 'vs/editor/common/modes/supports/tokenization';\n\ninterface IParseFunc {\n\t(text: string): number[];\n}\n\ninterface IAssertion {\n\ttestLineNumber: number;\n\tstartOffset: number;\n\tlength: number;\n\ttokenType: StandardTokenType;\n}\n\ninterface ITest {\n\tcontent: string;\n\tassertions: IAssertion[];\n}\n\nfunction parseTest(fileName: string): ITest {\n\tinterface ILineWithAssertions {\n\t\tline: string;\n\t\tassertions: ILineAssertion[];\n\t}\n\n\tinterface ILineAssertion {\n\t\ttestLineNumber: number;\n\t\tstartOffset: number;\n\t\tlength: number;\n\t\texpectedTokenType: StandardTokenType;\n\t}\n\n\tconst testContents = fs.readFileSync(fileName).toString();\n\tconst lines = testContents.split(/\\r\\n|\\n/);\n\tconst magicToken = lines[0];\n\n\tlet currentElement: ILineWithAssertions = {\n\t\tline: lines[1],\n\t\tassertions: []\n\t};\n\n\tlet parsedTest: ILineWithAssertions[] = [];\n\tfor (let i = 2; i < lines.length; i++) {\n\t\tlet line = lines[i];\n\t\tif (line.substr(0, magicToken.length) === magicToken) {\n\t\t\t// this is an assertion line\n\t\t\tlet m1 = line.substr(magicToken.length).match(/^( +)([\\^]+) (\\w+)\\\\?$/);\n\t\t\tif (m1) {\n\t\t\t\tcurrentElement.assertions.push({\n\t\t\t\t\ttestLineNumber: i + 1,\n\t\t\t\t\tstartOffset: magicToken.length + m1[1].length,\n\t\t\t\t\tlength: m1[2].length,\n\t\t\t\t\texpectedTokenType: toStandardTokenType(m1[3])\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet m2 = line.substr(magicToken.length).match(/^( +)<(-+) (\\w+)\\\\?$/);\n\t\t\t\tif (m2) {\n\t\t\t\t\tcurrentElement.assertions.push({\n\t\t\t\t\t\ttestLineNumber: i + 1,\n\t\t\t\t\t\tstartOffset: 0,\n\t\t\t\t\t\tlength: m2[2].length,\n\t\t\t\t\t\texpectedTokenType: toStandardTokenType(m2[3])\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Invalid test line at line number ${i + 1}.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// this is a line to be parsed\n\t\t\tparsedTest.push(currentElement);\n\t\t\tcurrentElement = {\n\t\t\t\tline: line,\n\t\t\t\tassertions: []\n\t\t\t};\n\t\t}\n\t}\n\tparsedTest.push(currentElement);\n\n\tlet assertions: IAssertion[] = [];\n\n\tlet offset = 0;\n\tfor (let i = 0; i < parsedTest.length; i++) {\n\t\tconst parsedTestLine = parsedTest[i];\n\t\tfor (let j = 0; j < parsedTestLine.assertions.length; j++) {\n\t\t\tconst assertion = parsedTestLine.assertions[j];\n\t\t\tassertions.push({\n\t\t\t\ttestLineNumber: assertion.testLineNumber,\n\t\t\t\tstartOffset: offset + assertion.startOffset,\n\t\t\t\tlength: assertion.length,\n\t\t\t\ttokenType: assertion.expectedTokenType\n\t\t\t});\n\t\t}\n\t\toffset += parsedTestLine.line.length + 1;\n\t}\n\n\tlet content: string = parsedTest.map(parsedTestLine => parsedTestLine.line).join('\\n');\n\n\treturn { content, assertions };\n}\n\n// @ts-expect-error\nfunction executeTest(fileName: string, parseFunc: IParseFunc): void {\n\tconst { content, assertions } = parseTest(fileName);\n\tconst actual = parseFunc(content);\n\n\tlet actualIndex = 0, actualCount = actual.length / 3;\n\tfor (let i = 0; i < assertions.length; i++) {\n\t\tconst assertion = assertions[i];\n\t\twhile (actualIndex < actualCount && actual[3 * actualIndex] + actual[3 * actualIndex + 1] <= assertion.startOffset) {\n\t\t\tactualIndex++;\n\t\t}\n\t\tassert.ok(\n\t\t\tactual[3 * actualIndex] <= assertion.startOffset,\n\t\t\t`Line ${assertion.testLineNumber} : startOffset : ${actual[3 * actualIndex]} <= ${assertion.startOffset}`\n\t\t);\n\t\tassert.ok(\n\t\t\tactual[3 * actualIndex] + actual[3 * actualIndex + 1] >= assertion.startOffset + assertion.length,\n\t\t\t`Line ${assertion.testLineNumber} : length : ${actual[3 * actualIndex]} + ${actual[3 * actualIndex + 1]} >= ${assertion.startOffset} + ${assertion.length}.`\n\t\t);\n\t\tassert.strictEqual(\n\t\t\tactual[3 * actualIndex + 2],\n\t\t\tassertion.tokenType,\n\t\t\t`Line ${assertion.testLineNumber} : tokenType`);\n\t}\n}\n\nsuite('Classification', () => {\n\ttest('TypeScript', () => {\n\t\t// executeTest(getPathFromAmdModule(require, 'vs/editor/test/node/classification/typescript-test.ts').replace(/\\bout\\b/, 'src'), parse);\n\t});\n});\n"]}