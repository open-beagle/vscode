{"version":3,"file":"indentationGuesser.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/common/model/indentationGuesser.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ITextBuffer } from 'vs/editor/common/model';\n\nclass SpacesDiffResult {\n\tpublic spacesDiff: number = 0;\n\tpublic looksLikeAlignment: boolean = false;\n}\n\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a: string, aLength: number, b: string, bLength: number, result: SpacesDiffResult): void {\n\n\tresult.spacesDiff = 0;\n\tresult.looksLikeAlignment = false;\n\n\t// This can go both ways (e.g.):\n\t//  - a: \"\\t\"\n\t//  - b: \"\\t    \"\n\t//  => This should count 1 tab and 4 spaces\n\n\tlet i: number;\n\n\tfor (i = 0; i < aLength && i < bLength; i++) {\n\t\tlet aCharCode = a.charCodeAt(i);\n\t\tlet bCharCode = b.charCodeAt(i);\n\n\t\tif (aCharCode !== bCharCode) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlet aSpacesCnt = 0, aTabsCount = 0;\n\tfor (let j = i; j < aLength; j++) {\n\t\tlet aCharCode = a.charCodeAt(j);\n\t\tif (aCharCode === CharCode.Space) {\n\t\t\taSpacesCnt++;\n\t\t} else {\n\t\t\taTabsCount++;\n\t\t}\n\t}\n\n\tlet bSpacesCnt = 0, bTabsCount = 0;\n\tfor (let j = i; j < bLength; j++) {\n\t\tlet bCharCode = b.charCodeAt(j);\n\t\tif (bCharCode === CharCode.Space) {\n\t\t\tbSpacesCnt++;\n\t\t} else {\n\t\t\tbTabsCount++;\n\t\t}\n\t}\n\n\tif (aSpacesCnt > 0 && aTabsCount > 0) {\n\t\treturn;\n\t}\n\tif (bSpacesCnt > 0 && bTabsCount > 0) {\n\t\treturn;\n\t}\n\n\tlet tabsDiff = Math.abs(aTabsCount - bTabsCount);\n\tlet spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n\n\tif (tabsDiff === 0) {\n\t\t// check if the indentation difference might be caused by alignment reasons\n\t\t// sometime folks like to align their code, but this should not be used as a hint\n\t\tresult.spacesDiff = spacesDiff;\n\n\t\tif (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n\t\t\tif (b.charCodeAt(bSpacesCnt) !== CharCode.Space && a.charCodeAt(bSpacesCnt - 1) === CharCode.Space) {\n\t\t\t\tif (a.charCodeAt(a.length - 1) === CharCode.Comma) {\n\t\t\t\t\t// This looks like an alignment desire: e.g.\n\t\t\t\t\t// const a = b + c,\n\t\t\t\t\t//       d = b - c;\n\t\t\t\t\tresult.looksLikeAlignment = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif (spacesDiff % tabsDiff === 0) {\n\t\tresult.spacesDiff = spacesDiff / tabsDiff;\n\t\treturn;\n\t}\n}\n\n/**\n * Result for a guessIndentation\n */\nexport interface IGuessedIndentation {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces: boolean;\n}\n\nexport function guessIndentation(source: ITextBuffer, defaultTabSize: number, defaultInsertSpaces: boolean): IGuessedIndentation {\n\t// Look at most at the first 10k lines\n\tconst linesCount = Math.min(source.getLineCount(), 10000);\n\n\tlet linesIndentedWithTabsCount = 0;\t\t\t\t// number of lines that contain at least one tab in indentation\n\tlet linesIndentedWithSpacesCount = 0;\t\t\t// number of lines that contain only spaces in indentation\n\n\tlet previousLineText = '';\t\t\t\t\t\t// content of latest line that contained non-whitespace chars\n\tlet previousLineIndentation = 0;\t\t\t\t// index at which latest line contained the first non-whitespace char\n\n\tconst ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];\t// prefer even guesses for `tabSize`, limit to [2, 8].\n\tconst MAX_ALLOWED_TAB_SIZE_GUESS = 8;\t\t\t// max(ALLOWED_TAB_SIZE_GUESSES) = 8\n\n\tlet spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];\t\t// `tabSize` scores\n\tlet tmp = new SpacesDiffResult();\n\n\tfor (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n\t\tlet currentLineLength = source.getLineLength(lineNumber);\n\t\tlet currentLineText = source.getLineContent(lineNumber);\n\n\t\t// if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n\t\t// checking charCode on chunks directly is cheaper.\n\t\tconst useCurrentLineText = (currentLineLength <= 65536);\n\n\t\tlet currentLineHasContent = false;\t\t\t// does `currentLineText` contain non-whitespace chars\n\t\tlet currentLineIndentation = 0;\t\t\t\t// index at which `currentLineText` contains the first non-whitespace char\n\t\tlet currentLineSpacesCount = 0;\t\t\t\t// count of spaces found in `currentLineText` indentation\n\t\tlet currentLineTabsCount = 0;\t\t\t\t// count of tabs found in `currentLineText` indentation\n\t\tfor (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n\t\t\tlet charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n\n\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\tcurrentLineTabsCount++;\n\t\t\t} else if (charCode === CharCode.Space) {\n\t\t\t\tcurrentLineSpacesCount++;\n\t\t\t} else {\n\t\t\t\t// Hit non whitespace character on this line\n\t\t\t\tcurrentLineHasContent = true;\n\t\t\t\tcurrentLineIndentation = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Ignore empty or only whitespace lines\n\t\tif (!currentLineHasContent) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (currentLineTabsCount > 0) {\n\t\t\tlinesIndentedWithTabsCount++;\n\t\t} else if (currentLineSpacesCount > 1) {\n\t\t\tlinesIndentedWithSpacesCount++;\n\t\t}\n\n\t\tspacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n\n\t\tif (tmp.looksLikeAlignment) {\n\t\t\t// if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n\t\t\t//\n\t\t\t// - item1\n\t\t\t//   - item2\n\t\t\t//\n\t\t\t// otherwise skip this line entirely\n\t\t\t//\n\t\t\t// const a = 1,\n\t\t\t//       b = 2;\n\n\t\t\tif (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tlet currentSpacesDiff = tmp.spacesDiff;\n\t\tif (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n\t\t\tspacesDiffCount[currentSpacesDiff]++;\n\t\t}\n\n\t\tpreviousLineText = currentLineText;\n\t\tpreviousLineIndentation = currentLineIndentation;\n\t}\n\n\tlet insertSpaces = defaultInsertSpaces;\n\tif (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n\t\tinsertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n\t}\n\n\tlet tabSize = defaultTabSize;\n\n\t// Guess tabSize only if inserting spaces...\n\tif (insertSpaces) {\n\t\tlet tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n\n\t\t// console.log(\"score threshold: \" + tabSizeScore);\n\n\t\tALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n\t\t\tlet possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n\t\t\tif (possibleTabSizeScore > tabSizeScore) {\n\t\t\t\ttabSizeScore = possibleTabSizeScore;\n\t\t\t\ttabSize = possibleTabSize;\n\t\t\t}\n\t\t});\n\n\t\t// Let a tabSize of 2 win even if it is not the maximum\n\t\t// (only in case 4 was guessed)\n\t\tif (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n\t\t\ttabSize = 2;\n\t\t}\n\t}\n\n\n\t// console.log('--------------------------');\n\t// console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n\t// console.log('spacesDiffCount: ' + spacesDiffCount);\n\t// console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n\n\treturn {\n\t\tinsertSpaces: insertSpaces,\n\t\ttabSize: tabSize\n\t};\n}\n"]}