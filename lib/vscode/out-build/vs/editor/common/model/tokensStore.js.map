{"version":3,"file":"tokensStore.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/common/model/tokensStore.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { LineTokens } from 'vs/editor/common/core/lineTokens';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange, Range } from 'vs/editor/common/core/range';\nimport { ColorId, FontStyle, LanguageId, MetadataConsts, StandardTokenType, TokenMetadata } from 'vs/editor/common/modes';\nimport { writeUInt32BE, readUInt32BE } from 'vs/base/common/buffer';\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n\nfunction getDefaultMetadata(topLevelLanguageId: LanguageId): number {\n\treturn (\n\t\t(topLevelLanguageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t| (StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t| (FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n}\n\nconst EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\n\nexport class MultilineTokensBuilder {\n\n\tpublic readonly tokens: MultilineTokens[];\n\n\tconstructor() {\n\t\tthis.tokens = [];\n\t}\n\n\tpublic add(lineNumber: number, lineTokens: Uint32Array): void {\n\t\tif (this.tokens.length > 0) {\n\t\t\tconst last = this.tokens[this.tokens.length - 1];\n\t\t\tconst lastLineNumber = last.startLineNumber + last.tokens.length - 1;\n\t\t\tif (lastLineNumber + 1 === lineNumber) {\n\t\t\t\t// append\n\t\t\t\tlast.tokens.push(lineTokens);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\n\t}\n\n\tpublic static deserialize(buff: Uint8Array): MultilineTokens[] {\n\t\tlet offset = 0;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tlet result: MultilineTokens[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffset = MultilineTokens.deserialize(buff, offset, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic serialize(): Uint8Array {\n\t\tconst size = this._serializeSize();\n\t\tconst result = new Uint8Array(size);\n\t\tthis._serialize(result);\n\t\treturn result;\n\t}\n\n\tprivate _serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the count\n\t\tfor (let i = 0; i < this.tokens.length; i++) {\n\t\t\tresult += this.tokens[i].serializeSize();\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _serialize(destination: Uint8Array): void {\n\t\tlet offset = 0;\n\t\twriteUInt32BE(destination, this.tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this.tokens.length; i++) {\n\t\t\toffset = this.tokens[i].serialize(destination, offset);\n\t\t}\n\t}\n}\n\nexport class SparseEncodedTokens {\n\t/**\n\t * The encoding of tokens is:\n\t *  4*i    deltaLine (from `startLineNumber`)\n\t *  4*i+1  startCharacter (from the line start)\n\t *  4*i+2  endCharacter (from the line start)\n\t *  4*i+3  metadata\n\t */\n\tprivate readonly _tokens: Uint32Array;\n\tprivate _tokenCount: number;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokenCount = tokens.length / 4;\n\t}\n\n\tpublic toString(startLineNumber: number): string {\n\t\tlet pieces: string[] = [];\n\t\tfor (let i = 0; i < this._tokenCount; i++) {\n\t\t\tpieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n\t\t}\n\t\treturn `[${pieces.join(',')}]`;\n\t}\n\n\tpublic getMaxDeltaLine(): number {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn this._getDeltaLine(tokenCount - 1);\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst tokenCount = this._getTokenCount();\n\t\tif (tokenCount === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startChar = this._getStartCharacter(0);\n\t\tconst maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n\t\tconst endChar = this._getEndCharacter(tokenCount - 1);\n\t\treturn new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n\t}\n\n\tprivate _getTokenCount(): number {\n\t\treturn this._tokenCount;\n\t}\n\n\tprivate _getDeltaLine(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex];\n\t}\n\n\tprivate _getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tprivate _getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._getTokenCount() === 0);\n\t}\n\n\tpublic getLineTokens(deltaLine: number): LineTokens2 | null {\n\t\tlet low = 0;\n\t\tlet high = this._getTokenCount() - 1;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst midDeltaLine = this._getDeltaLine(mid);\n\n\t\t\tif (midDeltaLine < deltaLine) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (midDeltaLine > deltaLine) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlet min = mid;\n\t\t\t\twhile (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n\t\t\t\t\tmin--;\n\t\t\t\t}\n\t\t\t\tlet max = mid;\n\t\t\t\twhile (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n\t\t\t\t\tmax++;\n\t\t\t\t}\n\t\t\t\treturn new LineTokens2(this._tokens.subarray(4 * min, 4 * max + 4));\n\t\t\t}\n\t\t}\n\n\t\tif (this._getDeltaLine(low) === deltaLine) {\n\t\t\treturn new LineTokens2(this._tokens.subarray(4 * low, 4 * low + 4));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic clear(): void {\n\t\tthis._tokenCount = 0;\n\t}\n\n\tpublic removeTokens(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): number {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tlet firstDeltaLine = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (\n\t\t\t\t(tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n\t\t\t\t&& (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))\n\t\t\t) {\n\t\t\t\thasDeletedTokens = true;\n\t\t\t} else {\n\t\t\t\tif (newTokenCount === 0) {\n\t\t\t\t\tfirstDeltaLine = tokenDeltaLine;\n\t\t\t\t}\n\t\t\t\tif (hasDeletedTokens) {\n\t\t\t\t\t// must move the token to the left\n\t\t\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\t\t\ttokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n\t\t\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\t\t}\n\t\t\t\tnewTokenCount++;\n\t\t\t}\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\n\t\treturn firstDeltaLine;\n\t}\n\n\tpublic split(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): [SparseEncodedTokens, SparseEncodedTokens, number] {\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tlet aTokens: number[] = [];\n\t\tlet bTokens: number[] = [];\n\t\tlet destTokens: number[] = aTokens;\n\t\tlet destOffset = 0;\n\t\tlet destFirstDeltaLine: number = 0;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tconst tokenDeltaLine = tokens[srcOffset];\n\t\t\tconst tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tconst tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n\t\t\t\tif ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n\t\t\t\t\t// this token is touching the range\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// this token is after the range\n\t\t\t\t\tif (destTokens !== bTokens) {\n\t\t\t\t\t\t// this token is the first token after the range\n\t\t\t\t\t\tdestTokens = bTokens;\n\t\t\t\t\t\tdestOffset = 0;\n\t\t\t\t\t\tdestFirstDeltaLine = tokenDeltaLine;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n\t\t\tdestTokens[destOffset++] = tokenStartCharacter;\n\t\t\tdestTokens[destOffset++] = tokenEndCharacter;\n\t\t\tdestTokens[destOffset++] = tokenMetadata;\n\t\t}\n\n\t\treturn [new SparseEncodedTokens(new Uint32Array(aTokens)), new SparseEncodedTokens(new Uint32Array(bTokens)), destFirstDeltaLine];\n\t}\n\n\tpublic acceptDeleteRange(horizontalShiftForFirstLineTokens: number, startDeltaLine: number, startCharacter: number, endDeltaLine: number, endCharacter: number): void {\n\t\t// This is a bit complex, here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token starts before the deletion range\n\t\t// 1a. The token is completely before the deletion range\n\t\t//               -----------\n\t\t//                          xxxxxxxxxxx\n\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t//               -----------\n\t\t//                      xxxxxxxxxxx\n\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t//               ---------------\n\t\t//                      xxxxxxxx\n\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t//               ---------------\n\t\t//                    xxxxx\n\t\t//\n\t\t// 2. The token starts at the same position with the deletion range\n\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t//               -------\n\t\t//               xxxxxxxxxxx\n\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t//               ----------\n\t\t//               xxxxxxxxxx\n\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t//               -------------\n\t\t//               xxxxxxx\n\t\t//\n\t\t// 3. The token starts inside the deletion range\n\t\t// 3a. The token is inside the deletion range\n\t\t//                -------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t//                ----------\n\t\t//             xxxxxxxxxxxxx\n\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t//                ------------\n\t\t//             xxxxxxxxxxx\n\t\t//\n\t\t// 4. The token starts after the deletion range\n\t\t//                  -----------\n\t\t//          xxxxxxxx\n\t\t//\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tconst deletedLineCount = (endDeltaLine - startDeltaLine);\n\t\tlet newTokenCount = 0;\n\t\tlet hasDeletedTokens = false;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst srcOffset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[srcOffset];\n\t\t\tlet tokenStartCharacter = tokens[srcOffset + 1];\n\t\t\tlet tokenEndCharacter = tokens[srcOffset + 2];\n\t\t\tconst tokenMetadata = tokens[srcOffset + 3];\n\n\t\t\tif (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n\t\t\t\t// 1a. The token is completely before the deletion range\n\t\t\t\t// => nothing to do\n\t\t\t\tnewTokenCount++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n\t\t\t\t// 1b, 1c, 1d\n\t\t\t\t// => the token survives, but it needs to shrink\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 1d. The token starts before, the deletion range is inside the token\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 1b. The token starts before, the deletion range ends after the token\n\t\t\t\t\t// 1c. The token starts before, the deletion range ends precisely with the token\n\t\t\t\t\t// => the token shrinks its ending to the deletion start\n\t\t\t\t\ttokenEndCharacter = startCharacter;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n\t\t\t\t// 2a, 2b, 2c\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 2c. The token starts at the same position, and ends after the deletion range\n\t\t\t\t\t// => the token shrinks by the deletion character count\n\t\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t\t} else {\n\t\t\t\t\t// 2a. The token starts at the same position, and ends inside the deletion range\n\t\t\t\t\t// 2b. The token starts at the same position, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n\t\t\t\t// 3a, 3b, 3c\n\t\t\t\tif (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n\t\t\t\t\t// 3c. The token starts inside the deletion range, and ends after the deletion range\n\t\t\t\t\t// => the token moves left and shrinks\n\t\t\t\t\tif (tokenDeltaLine === startDeltaLine) {\n\t\t\t\t\t\t// the deletion started on the same line as the token\n\t\t\t\t\t\t// => the token moves left and shrinks\n\t\t\t\t\t\ttokenStartCharacter = startCharacter;\n\t\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the deletion started on a line above the token\n\t\t\t\t\t\t// => the token moves to the beginning of the line\n\t\t\t\t\t\ttokenStartCharacter = 0;\n\t\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// 3a. The token is inside the deletion range\n\t\t\t\t\t// 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n\t\t\t\t\t// => the token is deleted\n\t\t\t\t\thasDeletedTokens = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine > endDeltaLine) {\n\t\t\t\t// 4. (partial) The token starts after the deletion range, on a line below...\n\t\t\t\tif (deletedLineCount === 0 && !hasDeletedTokens) {\n\t\t\t\t\t// early stop, there is no need to walk all the tokens and do nothing...\n\t\t\t\t\tnewTokenCount = tokenCount;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t} else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n\t\t\t\t// 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n\t\t\t\tif (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n\t\t\t\t\ttokenStartCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t\ttokenEndCharacter += horizontalShiftForFirstLineTokens;\n\t\t\t\t}\n\t\t\t\ttokenDeltaLine -= deletedLineCount;\n\t\t\t\ttokenStartCharacter -= (endCharacter - startCharacter);\n\t\t\t\ttokenEndCharacter -= (endCharacter - startCharacter);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Not possible!`);\n\t\t\t}\n\n\t\t\tconst destOffset = 4 * newTokenCount;\n\t\t\ttokens[destOffset] = tokenDeltaLine;\n\t\t\ttokens[destOffset + 1] = tokenStartCharacter;\n\t\t\ttokens[destOffset + 2] = tokenEndCharacter;\n\t\t\ttokens[destOffset + 3] = tokenMetadata;\n\t\t\tnewTokenCount++;\n\t\t}\n\n\t\tthis._tokenCount = newTokenCount;\n\t}\n\n\tpublic acceptInsertText(deltaLine: number, character: number, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\t// Here are the cases I used to think about this:\n\t\t//\n\t\t// 1. The token is completely before the insertion point\n\t\t//            -----------   |\n\t\t// 2. The token ends precisely at the insertion point\n\t\t//            -----------|\n\t\t// 3. The token contains the insertion point\n\t\t//            -----|------\n\t\t// 4. The token starts precisely at the insertion point\n\t\t//            |-----------\n\t\t// 5. The token is completely after the insertion point\n\t\t//            |   -----------\n\t\t//\n\t\tconst isInsertingPreciselyOneWordCharacter = (\n\t\t\teolCount === 0\n\t\t\t&& firstLineLength === 1\n\t\t\t&& (\n\t\t\t\t(firstCharCode >= CharCode.Digit0 && firstCharCode <= CharCode.Digit9)\n\t\t\t\t|| (firstCharCode >= CharCode.A && firstCharCode <= CharCode.Z)\n\t\t\t\t|| (firstCharCode >= CharCode.a && firstCharCode <= CharCode.z)\n\t\t\t)\n\t\t);\n\t\tconst tokens = this._tokens;\n\t\tconst tokenCount = this._tokenCount;\n\t\tfor (let i = 0; i < tokenCount; i++) {\n\t\t\tconst offset = 4 * i;\n\t\t\tlet tokenDeltaLine = tokens[offset];\n\t\t\tlet tokenStartCharacter = tokens[offset + 1];\n\t\t\tlet tokenEndCharacter = tokens[offset + 2];\n\n\t\t\tif (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n\t\t\t\t// 1. The token is completely before the insertion point\n\t\t\t\t// => nothing to do\n\t\t\t\tcontinue;\n\t\t\t} else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n\t\t\t\t// 2. The token ends precisely at the insertion point\n\t\t\t\t// => expand the end character only if inserting precisely one character that is a word character\n\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\ttokenEndCharacter += 1;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n\t\t\t\t// 3. The token contains the insertion point\n\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t// => just expand the end character\n\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t} else {\n\t\t\t\t\t// => cut off the token\n\t\t\t\t\ttokenEndCharacter = character;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 4. or 5.\n\t\t\t\tif (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n\t\t\t\t\t// 4. The token starts precisely at the insertion point\n\t\t\t\t\t// => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n\t\t\t\t\t// => otherwise behave as in case 5.\n\t\t\t\t\tif (isInsertingPreciselyOneWordCharacter) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// => the token must move and keep its size constant\n\t\t\t\tif (tokenDeltaLine === deltaLine) {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t\t// this token is on the line where the insertion is taking place\n\t\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\t\ttokenStartCharacter += firstLineLength;\n\t\t\t\t\t\ttokenEndCharacter += firstLineLength;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst tokenLength = tokenEndCharacter - tokenStartCharacter;\n\t\t\t\t\t\ttokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n\t\t\t\t\t\ttokenEndCharacter = tokenStartCharacter + tokenLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokenDeltaLine += eolCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokens[offset] = tokenDeltaLine;\n\t\t\ttokens[offset + 1] = tokenStartCharacter;\n\t\t\ttokens[offset + 2] = tokenEndCharacter;\n\t\t}\n\t}\n}\n\nexport class LineTokens2 {\n\n\tprivate readonly _tokens: Uint32Array;\n\n\tconstructor(tokens: Uint32Array) {\n\t\tthis._tokens = tokens;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokens.length / 4;\n\t}\n\n\tpublic getStartCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 1];\n\t}\n\n\tpublic getEndCharacter(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 2];\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._tokens[4 * tokenIndex + 3];\n\t}\n}\n\nexport class MultilineTokens2 {\n\n\tpublic startLineNumber: number;\n\tpublic endLineNumber: number;\n\tpublic tokens: SparseEncodedTokens;\n\n\tconstructor(startLineNumber: number, tokens: SparseEncodedTokens) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.tokens = tokens;\n\t\tthis.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.tokens.toString(this.startLineNumber);\n\t}\n\n\tprivate _updateEndLineNumber(): void {\n\t\tthis.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.tokens.isEmpty();\n\t}\n\n\tpublic getLineTokens(lineNumber: number): LineTokens2 | null {\n\t\tif (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\n\t\t\treturn this.tokens.getLineTokens(lineNumber - this.startLineNumber);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic getRange(): Range | null {\n\t\tconst deltaRange = this.tokens.getRange();\n\t\tif (!deltaRange) {\n\t\t\treturn deltaRange;\n\t\t}\n\t\treturn new Range(this.startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this.startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n\t}\n\n\tpublic removeTokens(range: Range): void {\n\t\tconst startLineIndex = range.startLineNumber - this.startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this.startLineNumber;\n\n\t\tthis.startLineNumber += this.tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tpublic split(range: Range): [MultilineTokens2, MultilineTokens2] {\n\t\t// split tokens to two:\n\t\t// a) all the tokens before `range`\n\t\t// b) all the tokens after `range`\n\t\tconst startLineIndex = range.startLineNumber - this.startLineNumber;\n\t\tconst endLineIndex = range.endLineNumber - this.startLineNumber;\n\n\t\tconst [a, b, bDeltaLine] = this.tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\t\treturn [new MultilineTokens2(this.startLineNumber, a), new MultilineTokens2(this.startLineNumber + bDeltaLine, b)];\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tthis.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : CharCode.Null);\n\t}\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\tthis._updateEndLineNumber();\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this.startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this.startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis.startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n\n\t\tif (firstLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis.startLineNumber = 0;\n\t\t\tthis.tokens.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0) {\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis.startLineNumber -= deletedBefore;\n\n\t\t\tthis.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n\t\t} else {\n\t\t\tthis.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this.startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis.startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n\n\t\tif (lineIndex >= tokenMaxDeltaLine + 1) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tthis.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t}\n}\n\nexport class MultilineTokens {\n\n\tpublic startLineNumber: number;\n\tpublic tokens: (Uint32Array | ArrayBuffer | null)[];\n\n\tconstructor(startLineNumber: number, tokens: Uint32Array[]) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.tokens = tokens;\n\t}\n\n\tpublic static deserialize(buff: Uint8Array, offset: number, result: MultilineTokens[]): number {\n\t\tconst view32 = new Uint32Array(buff.buffer);\n\t\tconst startLineNumber = readUInt32BE(buff, offset); offset += 4;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tlet tokens: Uint32Array[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst byteCount = readUInt32BE(buff, offset); offset += 4;\n\t\t\ttokens.push(view32.subarray(offset / 4, offset / 4 + byteCount / 4));\n\t\t\toffset += byteCount;\n\t\t}\n\t\tresult.push(new MultilineTokens(startLineNumber, tokens));\n\t\treturn offset;\n\t}\n\n\tpublic serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the start line number\n\t\tresult += 4; // 4 bytes for the line count\n\t\tfor (let i = 0; i < this.tokens.length; i++) {\n\t\t\tconst lineTokens = this.tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\tresult += 4; // 4 bytes for the byte count\n\t\t\tresult += lineTokens.byteLength;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic serialize(destination: Uint8Array, offset: number): number {\n\t\twriteUInt32BE(destination, this.startLineNumber, offset); offset += 4;\n\t\twriteUInt32BE(destination, this.tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this.tokens.length; i++) {\n\t\t\tconst lineTokens = this.tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\twriteUInt32BE(destination, lineTokens.byteLength, offset); offset += 4;\n\t\t\tdestination.set(new Uint8Array(lineTokens.buffer), offset); offset += lineTokens.byteLength;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength] = countEOL(text);\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this.startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this.startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis.startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= this.tokens.length) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= this.tokens.length) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis.startLineNumber = 0;\n\t\t\tthis.tokens = [];\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex === lastLineIndex) {\n\t\t\t// a delete on a single line\n\t\t\tthis.tokens[firstLineIndex] = TokensStore._delete(this.tokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= 0) {\n\t\t\t// The first line survives\n\t\t\tthis.tokens[firstLineIndex] = TokensStore._deleteEnding(this.tokens[firstLineIndex], range.startColumn - 1);\n\n\t\t\tif (lastLineIndex < this.tokens.length) {\n\t\t\t\t// The last line survives\n\t\t\t\tconst lastLineTokens = TokensStore._deleteBeginning(this.tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis.tokens[firstLineIndex] = TokensStore._append(this.tokens[firstLineIndex], lastLineTokens);\n\n\t\t\t\t// Delete middle lines\n\t\t\t\tthis.tokens.splice(firstLineIndex + 1, lastLineIndex - firstLineIndex);\n\t\t\t} else {\n\t\t\t\t// The last line does not survive\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis.tokens[firstLineIndex] = TokensStore._append(this.tokens[firstLineIndex], null);\n\n\t\t\t\t// Delete lines\n\t\t\t\tthis.tokens = this.tokens.slice(0, firstLineIndex + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// The first line does not survive\n\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis.startLineNumber -= deletedBefore;\n\n\t\t\t// Remove beginning from last line\n\t\t\tthis.tokens[lastLineIndex] = TokensStore._deleteBeginning(this.tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t// Delete lines\n\t\t\tthis.tokens = this.tokens.slice(lastLineIndex);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this.startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis.startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (lineIndex >= this.tokens.length) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis.tokens[lineIndex] = TokensStore._insert(this.tokens[lineIndex], position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.tokens[lineIndex] = TokensStore._deleteEnding(this.tokens[lineIndex], position.column - 1);\n\t\tthis.tokens[lineIndex] = TokensStore._insert(this.tokens[lineIndex], position.column - 1, firstLineLength);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tlet lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis.tokens = arrays.arrayInsert(this.tokens, insertIndex, lineTokens);\n\t}\n}\n\nfunction toUint32Array(arr: Uint32Array | ArrayBuffer): Uint32Array {\n\tif (arr instanceof Uint32Array) {\n\t\treturn arr;\n\t} else {\n\t\treturn new Uint32Array(arr);\n\t}\n}\n\nexport class TokensStore2 {\n\n\tprivate _pieces: MultilineTokens2[];\n\tprivate _isComplete: boolean;\n\n\tconstructor() {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._pieces = [];\n\t\tthis._isComplete = false;\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn (this._pieces.length === 0);\n\t}\n\n\tpublic set(pieces: MultilineTokens2[] | null, isComplete: boolean): void {\n\t\tthis._pieces = pieces || [];\n\t\tthis._isComplete = isComplete;\n\t}\n\n\tpublic setPartial(_range: Range, pieces: MultilineTokens2[]): Range {\n\t\t// console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n\n\t\tlet range = _range;\n\t\tif (pieces.length > 0) {\n\t\t\tconst _firstRange = pieces[0].getRange();\n\t\t\tconst _lastRange = pieces[pieces.length - 1].getRange();\n\t\t\tif (!_firstRange || !_lastRange) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t\trange = _range.plusRange(_firstRange).plusRange(_lastRange);\n\t\t}\n\n\t\tlet insertPosition: { index: number; } | null = null;\n\t\tfor (let i = 0, len = this._pieces.length; i < len; i++) {\n\t\t\tconst piece = this._pieces[i];\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// this piece is after the range, so mark the spot before this piece\n\t\t\t\t// as a good insertion position and stop looping\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// this piece might intersect with the range\n\t\t\tpiece.removeTokens(range);\n\n\t\t\tif (piece.isEmpty()) {\n\t\t\t\t// remove the piece if it became empty\n\t\t\t\tthis._pieces.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.endLineNumber < range.startLineNumber) {\n\t\t\t\t// after removal, this piece is before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (piece.startLineNumber > range.endLineNumber) {\n\t\t\t\t// after removal, this piece is after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// after removal, this piece contains the range\n\t\t\tconst [a, b] = piece.split(range);\n\t\t\tif (a.isEmpty()) {\n\t\t\t\t// this piece is actually after the range\n\t\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b.isEmpty()) {\n\t\t\t\t// this piece is actually before the range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._pieces.splice(i, 1, a, b);\n\t\t\ti++;\n\t\t\tlen++;\n\n\t\t\tinsertPosition = insertPosition || { index: i };\n\t\t}\n\n\t\tinsertPosition = insertPosition || { index: this._pieces.length };\n\n\t\tif (pieces.length > 0) {\n\t\t\tthis._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n\t\t}\n\n\t\t// console.log(`I HAVE ${this._pieces.length} pieces`);\n\t\t// console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n\n\t\treturn range;\n\t}\n\n\tpublic isComplete(): boolean {\n\t\treturn this._isComplete;\n\t}\n\n\tpublic addSemanticTokens(lineNumber: number, aTokens: LineTokens): LineTokens {\n\t\tconst pieces = this._pieces;\n\n\t\tif (pieces.length === 0) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\n\t\tconst bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n\n\t\tif (!bTokens) {\n\t\t\treturn aTokens;\n\t\t}\n\n\t\tconst aLen = aTokens.getCount();\n\t\tconst bLen = bTokens.getCount();\n\n\t\tlet aIndex = 0;\n\t\tlet result: number[] = [], resultLen = 0;\n\t\tlet lastEndOffset = 0;\n\n\t\tconst emitToken = (endOffset: number, metadata: number) => {\n\t\t\tif (endOffset === lastEndOffset) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastEndOffset = endOffset;\n\t\t\tresult[resultLen++] = endOffset;\n\t\t\tresult[resultLen++] = metadata;\n\t\t};\n\n\t\tfor (let bIndex = 0; bIndex < bLen; bIndex++) {\n\t\t\tconst bStartCharacter = bTokens.getStartCharacter(bIndex);\n\t\t\tconst bEndCharacter = bTokens.getEndCharacter(bIndex);\n\t\t\tconst bMetadata = bTokens.getMetadata(bIndex);\n\n\t\t\tconst bMask = (\n\t\t\t\t((bMetadata & MetadataConsts.SEMANTIC_USE_ITALIC) ? MetadataConsts.ITALIC_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BOLD) ? MetadataConsts.BOLD_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_UNDERLINE) ? MetadataConsts.UNDERLINE_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_FOREGROUND) ? MetadataConsts.FOREGROUND_MASK : 0)\n\t\t\t\t| ((bMetadata & MetadataConsts.SEMANTIC_USE_BACKGROUND) ? MetadataConsts.BACKGROUND_MASK : 0)\n\t\t\t) >>> 0;\n\t\t\tconst aMask = (~bMask) >>> 0;\n\n\t\t\t// push any token from `a` that is before `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\t// push the token from `a` if it intersects the token from `b`\n\t\t\tif (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n\t\t\t\temitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n\t\t\t}\n\n\t\t\t// skip any tokens from `a` that are contained inside `b`\n\t\t\twhile (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n\t\t\t\temitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\tif (aIndex < aLen) {\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n\t\t\t\tif (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n\t\t\t\t\t// `a` ends exactly at the same spot as `b`!\n\t\t\t\t\taIndex++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n\n\t\t\t\t// push the token from `b`\n\t\t\t\temitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n\t\t\t}\n\t\t}\n\n\t\t// push the remaining tokens from `a`\n\t\twhile (aIndex < aLen) {\n\t\t\temitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n\t\t\taIndex++;\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(result), aTokens.getLineContent());\n\t}\n\n\tprivate static _findFirstPieceWithLine(pieces: MultilineTokens2[], lineNumber: number): number {\n\t\tlet low = 0;\n\t\tlet high = pieces.length - 1;\n\n\t\twhile (low < high) {\n\t\t\tlet mid = low + Math.floor((high - low) / 2);\n\n\t\t\tif (pieces[mid].endLineNumber < lineNumber) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (pieces[mid].startLineNumber > lineNumber) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\twhile (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n\t\t\t\t\tmid--;\n\t\t\t\t}\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t//#region Editing\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void {\n\t\tfor (const piece of this._pieces) {\n\t\t\tpiece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n\t\t}\n\t}\n\n\t//#endregion\n}\n\nexport class TokensStore {\n\tprivate _lineTokens: (Uint32Array | ArrayBuffer | null)[];\n\tprivate _len: number;\n\n\tconstructor() {\n\t\tthis._lineTokens = [];\n\t\tthis._len = 0;\n\t}\n\n\tpublic flush(): void {\n\t\tthis._lineTokens = [];\n\t\tthis._len = 0;\n\t}\n\n\tpublic getTokens(topLevelLanguageId: LanguageId, lineIndex: number, lineText: string): LineTokens {\n\t\tlet rawLineTokens: Uint32Array | ArrayBuffer | null = null;\n\t\tif (lineIndex < this._len) {\n\t\t\trawLineTokens = this._lineTokens[lineIndex];\n\t\t}\n\n\t\tif (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n\t\t\treturn new LineTokens(toUint32Array(rawLineTokens), lineText);\n\t\t}\n\n\t\tlet lineTokens = new Uint32Array(2);\n\t\tlineTokens[0] = lineText.length;\n\t\tlineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n\t\treturn new LineTokens(lineTokens, lineText);\n\t}\n\n\tprivate static _massageTokens(topLevelLanguageId: LanguageId, lineTextLength: number, _tokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer {\n\n\t\tconst tokens = _tokens ? toUint32Array(_tokens) : null;\n\n\t\tif (lineTextLength === 0) {\n\t\t\tlet hasDifferentLanguageId = false;\n\t\t\tif (tokens && tokens.length > 1) {\n\t\t\t\thasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n\t\t\t}\n\n\t\t\tif (!hasDifferentLanguageId) {\n\t\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t\t}\n\t\t}\n\n\t\tif (!tokens || tokens.length === 0) {\n\t\t\tconst tokens = new Uint32Array(2);\n\t\t\ttokens[0] = lineTextLength;\n\t\t\ttokens[1] = getDefaultMetadata(topLevelLanguageId);\n\t\t\treturn tokens.buffer;\n\t\t}\n\n\t\t// Ensure the last token covers the end of the text\n\t\ttokens[tokens.length - 2] = lineTextLength;\n\n\t\tif (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n\t\t\t// Store directly the ArrayBuffer pointer to save an object\n\t\t\treturn tokens.buffer;\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tprivate _ensureLine(lineIndex: number): void {\n\t\twhile (lineIndex >= this._len) {\n\t\t\tthis._lineTokens[this._len] = null;\n\t\t\tthis._len++;\n\t\t}\n\t}\n\n\tprivate _deleteLines(start: number, deleteCount: number): void {\n\t\tif (deleteCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (start + deleteCount > this._len) {\n\t\t\tdeleteCount = this._len - start;\n\t\t}\n\t\tthis._lineTokens.splice(start, deleteCount);\n\t\tthis._len -= deleteCount;\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tlet lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n\t\tthis._len += insertCount;\n\t}\n\n\tpublic setTokens(topLevelLanguageId: LanguageId, lineIndex: number, lineTextLength: number, _tokens: Uint32Array | ArrayBuffer | null, checkEquality: boolean): boolean {\n\t\tconst tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\n\t\tthis._ensureLine(lineIndex);\n\t\tconst oldTokens = this._lineTokens[lineIndex];\n\t\tthis._lineTokens[lineIndex] = tokens;\n\n\t\tif (checkEquality) {\n\t\t\treturn !TokensStore._equals(oldTokens, tokens);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _equals(_a: Uint32Array | ArrayBuffer | null, _b: Uint32Array | ArrayBuffer | null) {\n\t\tif (!_a || !_b) {\n\t\t\treturn !_a && !_b;\n\t\t}\n\n\t\tconst a = toUint32Array(_a);\n\t\tconst b = toUint32Array(_b);\n\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (a[i] !== b[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t//#region Editing\n\n\tpublic acceptEdit(range: IRange, eolCount: number, firstLineLength: number): void {\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tconst firstLineIndex = range.startLineNumber - 1;\n\t\tif (firstLineIndex >= this._len) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n\n\t\tconst lastLineIndex = range.endLineNumber - 1;\n\t\tlet lastLineTokens: Uint32Array | ArrayBuffer | null = null;\n\t\tif (lastLineIndex < this._len) {\n\t\t\tlastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\n\n\t\t// Delete middle lines\n\t\tthis._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - 1;\n\t\tif (lineIndex >= this._len) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n\t\tthis._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\tpublic static _deleteBeginning(lineTokens: Uint32Array | ArrayBuffer | null, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\treturn TokensStore._delete(lineTokens, 0, toChIndex);\n\t}\n\n\tpublic static _deleteEnding(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst lineTextLength = tokens[tokens.length - 2];\n\t\treturn TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\n\t}\n\n\tpublic static _delete(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\t// special case: deleting everything\n\t\tif (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t}\n\n\t\tconst fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n\t\tconst fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n\t\tconst fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n\t\tif (toChIndex < fromTokenEndOffset) {\n\t\t\t// the delete range is inside a single token\n\t\t\tconst delta = (toChIndex - fromChIndex);\n\t\t\tfor (let i = fromTokenIndex; i < tokensCount; i++) {\n\t\t\t\ttokens[i << 1] -= delta;\n\t\t\t}\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tlet dest: number;\n\t\tlet lastEnd: number;\n\t\tif (fromTokenStartOffset !== fromChIndex) {\n\t\t\ttokens[fromTokenIndex << 1] = fromChIndex;\n\t\t\tdest = ((fromTokenIndex + 1) << 1);\n\t\t\tlastEnd = fromChIndex;\n\t\t} else {\n\t\t\tdest = (fromTokenIndex << 1);\n\t\t\tlastEnd = fromTokenStartOffset;\n\t\t}\n\n\t\tconst delta = (toChIndex - fromChIndex);\n\t\tfor (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\tconst tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\t\t\tif (tokenEndOffset > lastEnd) {\n\t\t\t\ttokens[dest++] = tokenEndOffset;\n\t\t\t\ttokens[dest++] = tokens[(tokenIndex << 1) + 1];\n\t\t\t\tlastEnd = tokenEndOffset;\n\t\t\t}\n\t\t}\n\n\t\tif (dest === tokens.length) {\n\t\t\t// nothing to trim\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tlet tmp = new Uint32Array(dest);\n\t\ttmp.set(tokens.subarray(0, dest), 0);\n\t\treturn tmp.buffer;\n\t}\n\n\tpublic static _append(lineTokens: Uint32Array | ArrayBuffer | null, _otherTokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer | null {\n\t\tif (_otherTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn _otherTokens;\n\t\t}\n\t\tif (lineTokens === null) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (_otherTokens === null) {\n\t\t\t// cannot determine combined line length...\n\t\t\treturn null;\n\t\t}\n\t\tconst myTokens = toUint32Array(lineTokens);\n\t\tconst otherTokens = toUint32Array(_otherTokens);\n\t\tconst otherTokensCount = (otherTokens.length >>> 1);\n\n\t\tlet result = new Uint32Array(myTokens.length + otherTokens.length);\n\t\tresult.set(myTokens, 0);\n\t\tlet dest = myTokens.length;\n\t\tconst delta = myTokens[myTokens.length - 2];\n\t\tfor (let i = 0; i < otherTokensCount; i++) {\n\t\t\tresult[dest++] = otherTokens[(i << 1)] + delta;\n\t\t\tresult[dest++] = otherTokens[(i << 1) + 1];\n\t\t}\n\t\treturn result.buffer;\n\t}\n\n\tpublic static _insert(lineTokens: Uint32Array | ArrayBuffer | null, chIndex: number, textLength: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\t// nothing to do\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\tlet fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\t\tif (fromTokenIndex > 0) {\n\t\t\tconst fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n\t\t\tif (fromTokenStartOffset === chIndex) {\n\t\t\t\tfromTokenIndex--;\n\t\t\t}\n\t\t}\n\t\tfor (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] += textLength;\n\t\t}\n\t\treturn lineTokens;\n\t}\n\n\t//#endregion\n}\n"]}