{"version":3,"file":"wordHelper.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/common/model/wordHelper.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWordAtPosition } from 'vs/editor/common/model';\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords: string = ''): RegExp {\n\tlet source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\tfor (const sep of USUAL_WORD_SEPARATORS) {\n\t\tif (allowInWords.indexOf(sep) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tsource += '\\\\' + sep;\n\t}\n\tsource += '\\\\s]+)';\n\treturn new RegExp(source, 'g');\n}\n\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\n\nexport function ensureValidWordDefinition(wordDefinition?: RegExp | null): RegExp {\n\tlet result: RegExp = DEFAULT_WORD_REGEXP;\n\n\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\tif (!wordDefinition.global) {\n\t\t\tlet flags = 'g';\n\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t\tif (wordDefinition.multiline) {\n\t\t\t\tflags += 'm';\n\t\t\t}\n\t\t\tif ((wordDefinition as any).unicode) {\n\t\t\t\tflags += 'u';\n\t\t\t}\n\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t} else {\n\t\t\tresult = wordDefinition;\n\t\t}\n\t}\n\n\tresult.lastIndex = 0;\n\n\treturn result;\n}\n\nconst _defaultConfig = {\n\tmaxLen: 1000,\n\twindowSize: 15,\n\ttimeBudget: 150\n};\n\nexport function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number, config = _defaultConfig): IWordAtPosition | null {\n\n\tif (text.length > config.maxLen) {\n\t\t// don't throw strings that long at the regexp\n\t\t// but use a sub-string in which a word must occur\n\t\tlet start = column - config.maxLen / 2;\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t} else {\n\t\t\ttextOffset += start;\n\t\t}\n\t\ttext = text.substring(start, column + config.maxLen / 2);\n\t\treturn getWordAtText(column, wordDefinition, text, textOffset, config);\n\t}\n\n\tconst t1 = Date.now();\n\tconst pos = column - 1 - textOffset;\n\n\tlet prevRegexIndex = -1;\n\tlet match: RegExpMatchArray | null = null;\n\n\tfor (let i = 1; ; i++) {\n\t\t// check time budget\n\t\tif (Date.now() - t1 >= config.timeBudget) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// reset the index at which the regexp should start matching, also know where it\n\t\t// should stop so that subsequent search don't repeat previous searches\n\t\tconst regexIndex = pos - config.windowSize * i;\n\t\twordDefinition.lastIndex = Math.max(0, regexIndex);\n\t\tconst thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n\t\tif (!thisMatch && match) {\n\t\t\t// stop: we have something\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch = thisMatch;\n\n\t\t// stop: searched at start\n\t\tif (regexIndex <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprevRegexIndex = regexIndex;\n\t}\n\n\tif (match) {\n\t\tlet result = {\n\t\t\tword: match[0],\n\t\t\tstartColumn: textOffset + 1 + match.index!,\n\t\t\tendColumn: textOffset + 1 + match.index! + match[0].length\n\t\t};\n\t\twordDefinition.lastIndex = 0;\n\t\treturn result;\n\t}\n\n\treturn null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition: RegExp, text: string, pos: number, stopPos: number): RegExpMatchArray | null {\n\tlet match: RegExpMatchArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n\t\t\treturn match;\n\t\t} else if (stopPos > 0 && matchIndex > stopPos) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n"]}