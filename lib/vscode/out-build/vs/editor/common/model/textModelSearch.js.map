{"version":3,"file":"textModelSearch.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/common/model/textModelSearch.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { WordCharacterClass, WordCharacterClassifier, getMapForWordSeparators } from 'vs/editor/common/controller/wordCharacterClassifier';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { EndOfLinePreference, FindMatch } from 'vs/editor/common/model';\nimport { TextModel } from 'vs/editor/common/model/textModel';\n\nconst LIMIT_FIND_COUNT = 999;\n\nexport class SearchParams {\n\tpublic readonly searchString: string;\n\tpublic readonly isRegex: boolean;\n\tpublic readonly matchCase: boolean;\n\tpublic readonly wordSeparators: string | null;\n\n\tconstructor(searchString: string, isRegex: boolean, matchCase: boolean, wordSeparators: string | null) {\n\t\tthis.searchString = searchString;\n\t\tthis.isRegex = isRegex;\n\t\tthis.matchCase = matchCase;\n\t\tthis.wordSeparators = wordSeparators;\n\t}\n\n\tpublic parseSearchRequest(): SearchData | null {\n\t\tif (this.searchString === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tlet multiline: boolean;\n\t\tif (this.isRegex) {\n\t\t\tmultiline = isMultilineRegexSource(this.searchString);\n\t\t} else {\n\t\t\tmultiline = (this.searchString.indexOf('\\n') >= 0);\n\t\t}\n\n\t\tlet regex: RegExp | null = null;\n\t\ttry {\n\t\t\tregex = strings.createRegExp(this.searchString, this.isRegex, {\n\t\t\t\tmatchCase: this.matchCase,\n\t\t\t\twholeWord: false,\n\t\t\t\tmultiline: multiline,\n\t\t\t\tglobal: true,\n\t\t\t\tunicode: true\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!regex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet canUseSimpleSearch = (!this.isRegex && !multiline);\n\t\tif (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n\t\t\t// casing might make a difference\n\t\t\tcanUseSimpleSearch = this.matchCase;\n\t\t}\n\n\t\treturn new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n\t}\n}\n\nexport function isMultilineRegexSource(searchString: string): boolean {\n\tif (!searchString || searchString.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = searchString.length; i < len; i++) {\n\t\tconst chCode = searchString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextChCode = searchString.charCodeAt(i);\n\t\t\tif (nextChCode === CharCode.n || nextChCode === CharCode.r || nextChCode === CharCode.W || nextChCode === CharCode.w) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport class SearchData {\n\n\t/**\n\t * The regex to search for. Always defined.\n\t */\n\tpublic readonly regex: RegExp;\n\t/**\n\t * The word separator classifier.\n\t */\n\tpublic readonly wordSeparators: WordCharacterClassifier | null;\n\t/**\n\t * The simple string to search for (if possible).\n\t */\n\tpublic readonly simpleSearch: string | null;\n\n\tconstructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null) {\n\t\tthis.regex = regex;\n\t\tthis.wordSeparators = wordSeparators;\n\t\tthis.simpleSearch = simpleSearch;\n\t}\n}\n\nexport function createFindMatch(range: Range, rawMatches: RegExpExecArray, captureMatches: boolean): FindMatch {\n\tif (!captureMatches) {\n\t\treturn new FindMatch(range, null);\n\t}\n\tlet matches: string[] = [];\n\tfor (let i = 0, len = rawMatches.length; i < len; i++) {\n\t\tmatches[i] = rawMatches[i];\n\t}\n\treturn new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n\n\tprivate readonly _lineFeedsOffsets: number[];\n\n\tconstructor(text: string) {\n\t\tlet lineFeedsOffsets: number[] = [];\n\t\tlet lineFeedsOffsetsLen = 0;\n\t\tfor (let i = 0, textLen = text.length; i < textLen; i++) {\n\t\t\tif (text.charCodeAt(i) === CharCode.LineFeed) {\n\t\t\t\tlineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n\t\t\t}\n\t\t}\n\t\tthis._lineFeedsOffsets = lineFeedsOffsets;\n\t}\n\n\tpublic findLineFeedCountBeforeOffset(offset: number): number {\n\t\tconst lineFeedsOffsets = this._lineFeedsOffsets;\n\t\tlet min = 0;\n\t\tlet max = lineFeedsOffsets.length - 1;\n\n\t\tif (max === -1) {\n\t\t\t// no line feeds\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (offset <= lineFeedsOffsets[0]) {\n\t\t\t// before first line feed\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (min < max) {\n\t\t\tconst mid = min + ((max - min) / 2 >> 0);\n\n\t\t\tif (lineFeedsOffsets[mid] >= offset) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lineFeedsOffsets[mid + 1] >= offset) {\n\t\t\t\t\t// bingo!\n\t\t\t\t\tmin = mid;\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min + 1;\n\t}\n}\n\nexport class TextModelSearch {\n\n\tpublic static findMatches(model: TextModel, searchParams: SearchParams, searchRange: Range, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n\t\t}\n\t\treturn this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Multiline search always executes on the lines concatenated with \\n.\n\t * We must therefore compensate for the count of \\n in case the model is CRLF\n\t */\n\tprivate static _getMultilineMatchRange(model: TextModel, deltaOffset: number, text: string, lfCounter: LineFeedCounter | null, matchIndex: number, match0: string): Range {\n\t\tlet startOffset: number;\n\t\tlet lineFeedCountBeforeMatch = 0;\n\t\tif (lfCounter) {\n\t\t\tlineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n\t\t\tstartOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tstartOffset = deltaOffset + matchIndex;\n\t\t}\n\n\t\tlet endOffset: number;\n\t\tif (lfCounter) {\n\t\t\tlet lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n\t\t\tlet lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n\t\t\tendOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tendOffset = startOffset + match0.length;\n\t\t}\n\n\t\tconst startPosition = model.getPositionAt(startOffset);\n\t\tconst endPosition = model.getPositionAt(endOffset);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tprivate static _doFindMatchesMultiline(model: TextModel, searchRange: Range, searcher: Searcher, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(searchRange, EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\n\t\tconst result: FindMatch[] = [];\n\t\tlet counter = 0;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tresult[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\t\t\tif (counter >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _doFindMatchesLineByLine(model: TextModel, searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\n\t\t// Early case for a search range that starts & stops on the same line number\n\t\tif (searchRange.startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Collect results from first line\n\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\n\t\t// Collect results from middle lines\n\t\tfor (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n\t\t\tresultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\t// Collect results from last line\n\t\tif (resultLen < limitResultCount) {\n\t\t\tconst text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _findMatchesInLine(searchData: SearchData, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\tpublic static findNextMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindNextMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst searchTextStart = new Position(searchStart.lineNumber, 1);\n\t\tconst deltaOffset = model.getOffsetAt(searchTextStart);\n\t\tconst lineCount = model.getLineCount();\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\t\tsearcher.reset(searchStart.column - 1);\n\t\tlet m = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\n\t\tif (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n\t\t\t// Try again from the top\n\t\t\treturn this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindNextMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber);\n\t\tconst r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (startLineNumber + i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findFirstMatchInLine(searcher: Searcher, text: string, lineNumber: number, fromColumn: number, captureMatches: boolean): FindMatch | null {\n\t\t// Set regex to search from column\n\t\tsearcher.reset(fromColumn - 1);\n\t\tconst m: RegExpExecArray | null = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tnew Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static findPreviousMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindPreviousMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\t\tif (matches.length > 0) {\n\t\t\treturn matches[matches.length - 1];\n\t\t}\n\n\t\tconst lineCount = model.getLineCount();\n\t\tif (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n\t\t\t// Try again with all content\n\t\t\treturn this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindPreviousMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\t\tconst r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLastMatchInLine(searcher: Searcher, text: string, lineNumber: number, captureMatches: boolean): FindMatch | null {\n\t\tlet bestResult: FindMatch | null = null;\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tbestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n\t\t}\n\t\treturn bestResult;\n\t}\n}\n\nfunction leftIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex === 0) {\n\t\t// Match starts at start of string\n\t\treturn true;\n\t}\n\n\tconst charBefore = text.charCodeAt(matchStartIndex - 1);\n\tif (wordSeparators.get(charBefore) !== WordCharacterClass.Regular) {\n\t\t// The character before the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charBefore === CharCode.CarriageReturn || charBefore === CharCode.LineFeed) {\n\t\t// The character before the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst firstCharInMatch = text.charCodeAt(matchStartIndex);\n\t\tif (wordSeparators.get(firstCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The first character inside the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction rightIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex + matchLength === textLength) {\n\t\t// Match ends at end of string\n\t\treturn true;\n\t}\n\n\tconst charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\tif (wordSeparators.get(charAfter) !== WordCharacterClass.Regular) {\n\t\t// The character after the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charAfter === CharCode.CarriageReturn || charAfter === CharCode.LineFeed) {\n\t\t// The character after the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\t\tif (wordSeparators.get(lastCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The last character in the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function isValidMatch(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\treturn (\n\t\tleftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t\t&& rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t);\n}\n\nexport class Searcher {\n\tpublic readonly _wordSeparators: WordCharacterClassifier | null;\n\tprivate readonly _searchRegex: RegExp;\n\tprivate _prevMatchStartIndex: number;\n\tprivate _prevMatchLength: number;\n\n\tconstructor(wordSeparators: WordCharacterClassifier | null, searchRegex: RegExp,) {\n\t\tthis._wordSeparators = wordSeparators;\n\t\tthis._searchRegex = searchRegex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic reset(lastIndex: number): void {\n\t\tthis._searchRegex.lastIndex = lastIndex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic next(text: string): RegExpExecArray | null {\n\t\tconst textLength = text.length;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tdo {\n\t\t\tif (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n\t\t\t\t// Reached the end of the line\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tm = this._searchRegex.exec(text);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst matchStartIndex = m.index;\n\t\t\tconst matchLength = m[0].length;\n\t\t\tif (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n\t\t\t\tif (matchLength === 0) {\n\t\t\t\t\t// the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n\t\t\t\t\t// we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n\t\t\t\t\tif (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Exit early if the regex matches the same range twice\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._prevMatchStartIndex = matchStartIndex;\n\t\t\tthis._prevMatchLength = matchLength;\n\n\t\t\tif (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn null;\n\t}\n}\n"]}