{"version":3,"file":"semanticTokensProviderStyling.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/common/services/semanticTokensProviderStyling.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { SemanticTokensLegend, TokenMetadata, FontStyle, MetadataConsts, SemanticTokens, LanguageIdentifier } from 'vs/editor/common/modes';\nimport { IThemeService } from 'vs/platform/theme/common/themeService';\nimport { ILogService, LogLevel } from 'vs/platform/log/common/log';\nimport { MultilineTokens2, SparseEncodedTokens } from 'vs/editor/common/model/tokensStore';\n\nexport const enum SemanticTokensProviderStylingConstants {\n\tNO_STYLING = 0b01111111111111111111111111111111\n}\n\nexport class SemanticTokensProviderStyling {\n\n\tprivate readonly _hashTable: HashTable;\n\tprivate _hasWarnedOverlappingTokens: boolean;\n\n\tconstructor(\n\t\tprivate readonly _legend: SemanticTokensLegend,\n\t\tprivate readonly _themeService: IThemeService,\n\t\tprivate readonly _logService: ILogService\n\t) {\n\t\tthis._hashTable = new HashTable();\n\t\tthis._hasWarnedOverlappingTokens = false;\n\t}\n\n\tpublic getMetadata(tokenTypeIndex: number, tokenModifierSet: number, languageId: LanguageIdentifier): number {\n\t\tconst entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, languageId.id);\n\t\tlet metadata: number;\n\t\tif (entry) {\n\t\t\tmetadata = entry.metadata;\n\t\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\t\tthis._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n\t\t\t}\n\t\t} else {\n\t\t\tlet tokenType = this._legend.tokenTypes[tokenTypeIndex];\n\t\t\tconst tokenModifiers: string[] = [];\n\t\t\tif (tokenType) {\n\t\t\t\tlet modifierSet = tokenModifierSet;\n\t\t\t\tfor (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n\t\t\t\t\tif (modifierSet & 1) {\n\t\t\t\t\t\ttokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n\t\t\t\t\t}\n\t\t\t\t\tmodifierSet = modifierSet >> 1;\n\t\t\t\t}\n\t\t\t\tif (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n\t\t\t\t\tthis._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n\t\t\t\t\ttokenModifiers.push('not-in-legend');\n\t\t\t\t}\n\n\t\t\t\tconst tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId.language);\n\t\t\t\tif (typeof tokenStyle === 'undefined') {\n\t\t\t\t\tmetadata = SemanticTokensProviderStylingConstants.NO_STYLING;\n\t\t\t\t} else {\n\t\t\t\t\tmetadata = 0;\n\t\t\t\t\tif (typeof tokenStyle.italic !== 'undefined') {\n\t\t\t\t\t\tconst italicBit = (tokenStyle.italic ? FontStyle.Italic : 0) << MetadataConsts.FONT_STYLE_OFFSET;\n\t\t\t\t\t\tmetadata |= italicBit | MetadataConsts.SEMANTIC_USE_ITALIC;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof tokenStyle.bold !== 'undefined') {\n\t\t\t\t\t\tconst boldBit = (tokenStyle.bold ? FontStyle.Bold : 0) << MetadataConsts.FONT_STYLE_OFFSET;\n\t\t\t\t\t\tmetadata |= boldBit | MetadataConsts.SEMANTIC_USE_BOLD;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof tokenStyle.underline !== 'undefined') {\n\t\t\t\t\t\tconst underlineBit = (tokenStyle.underline ? FontStyle.Underline : 0) << MetadataConsts.FONT_STYLE_OFFSET;\n\t\t\t\t\t\tmetadata |= underlineBit | MetadataConsts.SEMANTIC_USE_UNDERLINE;\n\t\t\t\t\t}\n\t\t\t\t\tif (tokenStyle.foreground) {\n\t\t\t\t\t\tconst foregroundBits = (tokenStyle.foreground) << MetadataConsts.FOREGROUND_OFFSET;\n\t\t\t\t\t\tmetadata |= foregroundBits | MetadataConsts.SEMANTIC_USE_FOREGROUND;\n\t\t\t\t\t}\n\t\t\t\t\tif (metadata === 0) {\n\t\t\t\t\t\t// Nothing!\n\t\t\t\t\t\tmetadata = SemanticTokensProviderStylingConstants.NO_STYLING;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\t\t\tthis._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n\t\t\t\t}\n\t\t\t\tmetadata = SemanticTokensProviderStylingConstants.NO_STYLING;\n\t\t\t\ttokenType = 'not-in-legend';\n\t\t\t}\n\t\t\tthis._hashTable.add(tokenTypeIndex, tokenModifierSet, languageId.id, metadata);\n\n\t\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\t\tthis._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n\t\t\t}\n\t\t}\n\n\t\treturn metadata;\n\t}\n\n\tpublic warnOverlappingSemanticTokens(lineNumber: number, startColumn: number): void {\n\t\tif (!this._hasWarnedOverlappingTokens) {\n\t\t\tthis._hasWarnedOverlappingTokens = true;\n\t\t\tconsole.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n\t\t}\n\t}\n\n}\n\nconst enum SemanticColoringConstants {\n\t/**\n\t * Let's aim at having 8KB buffers if possible...\n\t * So that would be 8192 / (5 * 4) = 409.6 tokens per area\n\t */\n\tDesiredTokensPerArea = 400,\n\n\t/**\n\t * Try to keep the total number of areas under 1024 if possible,\n\t * simply compensate by having more tokens per area...\n\t */\n\tDesiredMaxAreas = 1024,\n}\n\nexport function toMultilineTokens2(tokens: SemanticTokens, styling: SemanticTokensProviderStyling, languageId: LanguageIdentifier): MultilineTokens2[] {\n\tconst srcData = tokens.data;\n\tconst tokenCount = (tokens.data.length / 5) | 0;\n\tconst tokensPerArea = Math.max(Math.ceil(tokenCount / SemanticColoringConstants.DesiredMaxAreas), SemanticColoringConstants.DesiredTokensPerArea);\n\tconst result: MultilineTokens2[] = [];\n\n\tlet tokenIndex = 0;\n\tlet lastLineNumber = 1;\n\tlet lastStartCharacter = 0;\n\twhile (tokenIndex < tokenCount) {\n\t\tconst tokenStartIndex = tokenIndex;\n\t\tlet tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n\n\t\t// Keep tokens on the same line in the same area...\n\t\tif (tokenEndIndex < tokenCount) {\n\n\t\t\tlet smallTokenEndIndex = tokenEndIndex;\n\t\t\twhile (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n\t\t\t\tsmallTokenEndIndex--;\n\t\t\t}\n\n\t\t\tif (smallTokenEndIndex - 1 === tokenStartIndex) {\n\t\t\t\t// there are so many tokens on this line that our area would be empty, we must now go right\n\t\t\t\tlet bigTokenEndIndex = tokenEndIndex;\n\t\t\t\twhile (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n\t\t\t\t\tbigTokenEndIndex++;\n\t\t\t\t}\n\t\t\t\ttokenEndIndex = bigTokenEndIndex;\n\t\t\t} else {\n\t\t\t\ttokenEndIndex = smallTokenEndIndex;\n\t\t\t}\n\t\t}\n\n\t\tlet destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n\t\tlet destOffset = 0;\n\t\tlet areaLine = 0;\n\t\tlet prevLineNumber = 0;\n\t\tlet prevStartCharacter = 0;\n\t\tlet prevEndCharacter = 0;\n\t\twhile (tokenIndex < tokenEndIndex) {\n\t\t\tconst srcOffset = 5 * tokenIndex;\n\t\t\tconst deltaLine = srcData[srcOffset];\n\t\t\tconst deltaCharacter = srcData[srcOffset + 1];\n\t\t\tconst lineNumber = lastLineNumber + deltaLine;\n\t\t\tconst startCharacter = (deltaLine === 0 ? lastStartCharacter + deltaCharacter : deltaCharacter);\n\t\t\tconst length = srcData[srcOffset + 2];\n\t\t\tconst tokenTypeIndex = srcData[srcOffset + 3];\n\t\t\tconst tokenModifierSet = srcData[srcOffset + 4];\n\t\t\tconst metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n\n\t\t\tif (metadata !== SemanticTokensProviderStylingConstants.NO_STYLING) {\n\t\t\t\tif (areaLine === 0) {\n\t\t\t\t\tareaLine = lineNumber;\n\t\t\t\t}\n\t\t\t\tif (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n\t\t\t\t\tstyling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n\t\t\t\t\tif (prevStartCharacter < startCharacter) {\n\t\t\t\t\t\t// the previous token survives after the overlapping one\n\t\t\t\t\t\tdestData[destOffset - 4 + 2] = startCharacter;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token is entirely covered by the overlapping one\n\t\t\t\t\t\tdestOffset -= 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdestData[destOffset] = lineNumber - areaLine;\n\t\t\t\tdestData[destOffset + 1] = startCharacter;\n\t\t\t\tdestData[destOffset + 2] = startCharacter + length;\n\t\t\t\tdestData[destOffset + 3] = metadata;\n\t\t\t\tdestOffset += 4;\n\n\t\t\t\tprevLineNumber = lineNumber;\n\t\t\t\tprevStartCharacter = startCharacter;\n\t\t\t\tprevEndCharacter = startCharacter + length;\n\t\t\t}\n\n\t\t\tlastLineNumber = lineNumber;\n\t\t\tlastStartCharacter = startCharacter;\n\t\t\ttokenIndex++;\n\t\t}\n\n\t\tif (destOffset !== destData.length) {\n\t\t\tdestData = destData.subarray(0, destOffset);\n\t\t}\n\n\t\tconst tokens = new MultilineTokens2(areaLine, new SparseEncodedTokens(destData));\n\t\tresult.push(tokens);\n\t}\n\n\treturn result;\n}\n\nclass HashTableEntry {\n\tpublic readonly tokenTypeIndex: number;\n\tpublic readonly tokenModifierSet: number;\n\tpublic readonly languageId: number;\n\tpublic readonly metadata: number;\n\tpublic next: HashTableEntry | null;\n\n\tconstructor(tokenTypeIndex: number, tokenModifierSet: number, languageId: number, metadata: number) {\n\t\tthis.tokenTypeIndex = tokenTypeIndex;\n\t\tthis.tokenModifierSet = tokenModifierSet;\n\t\tthis.languageId = languageId;\n\t\tthis.metadata = metadata;\n\t\tthis.next = null;\n\t}\n}\n\nclass HashTable {\n\n\tprivate static _SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];\n\n\tprivate _elementsCount: number;\n\tprivate _currentLengthIndex: number;\n\tprivate _currentLength: number;\n\tprivate _growCount: number;\n\tprivate _elements: (HashTableEntry | null)[];\n\n\tconstructor() {\n\t\tthis._elementsCount = 0;\n\t\tthis._currentLengthIndex = 0;\n\t\tthis._currentLength = HashTable._SIZES[this._currentLengthIndex];\n\t\tthis._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n\t\tthis._elements = [];\n\t\tHashTable._nullOutEntries(this._elements, this._currentLength);\n\t}\n\n\tprivate static _nullOutEntries(entries: (HashTableEntry | null)[], length: number): void {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tentries[i] = null;\n\t\t}\n\t}\n\n\tprivate _hash2(n1: number, n2: number): number {\n\t\treturn (((n1 << 5) - n1) + n2) | 0;  // n1 * 31 + n2, keep as int32\n\t}\n\n\tprivate _hashFunc(tokenTypeIndex: number, tokenModifierSet: number, languageId: number): number {\n\t\treturn this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n\t}\n\n\tpublic get(tokenTypeIndex: number, tokenModifierSet: number, languageId: number): HashTableEntry | null {\n\t\tconst hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n\n\t\tlet p = this._elements[hash];\n\t\twhile (p) {\n\t\t\tif (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\tp = p.next;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic add(tokenTypeIndex: number, tokenModifierSet: number, languageId: number, metadata: number): void {\n\t\tthis._elementsCount++;\n\t\tif (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n\t\t\t// expand!\n\t\t\tconst oldElements = this._elements;\n\n\t\t\tthis._currentLengthIndex++;\n\t\t\tthis._currentLength = HashTable._SIZES[this._currentLengthIndex];\n\t\t\tthis._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n\t\t\tthis._elements = [];\n\t\t\tHashTable._nullOutEntries(this._elements, this._currentLength);\n\n\t\t\tfor (const first of oldElements) {\n\t\t\t\tlet p = first;\n\t\t\t\twhile (p) {\n\t\t\t\t\tconst oldNext = p.next;\n\t\t\t\t\tp.next = null;\n\t\t\t\t\tthis._add(p);\n\t\t\t\t\tp = oldNext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n\t}\n\n\tprivate _add(element: HashTableEntry): void {\n\t\tconst hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n\t\telement.next = this._elements[hash];\n\t\tthis._elements[hash] = element;\n\t}\n}\n"]}