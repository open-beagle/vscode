{"version":3,"file":"semanticTokensDto.js","sourceRoot":"file:///go/src/gitlab.wodcloud.com/cloud/vscode/lib/vscode/src","sources":["vs/editor/common/services/semanticTokensDto.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport * as platform from 'vs/base/common/platform';\n\nexport interface IFullSemanticTokensDto {\n\tid: number;\n\ttype: 'full';\n\tdata: Uint32Array;\n}\n\nexport interface IDeltaSemanticTokensDto {\n\tid: number;\n\ttype: 'delta';\n\tdeltas: { start: number; deleteCount: number; data?: Uint32Array; }[];\n}\n\nexport type ISemanticTokensDto = IFullSemanticTokensDto | IDeltaSemanticTokensDto;\n\nconst enum EncodedSemanticTokensType {\n\tFull = 1,\n\tDelta = 2\n}\n\nfunction reverseEndianness(arr: Uint8Array): void {\n\tfor (let i = 0, len = arr.length; i < len; i += 4) {\n\t\t// flip bytes 0<->3 and 1<->2\n\t\tconst b0 = arr[i + 0];\n\t\tconst b1 = arr[i + 1];\n\t\tconst b2 = arr[i + 2];\n\t\tconst b3 = arr[i + 3];\n\t\tarr[i + 0] = b3;\n\t\tarr[i + 1] = b2;\n\t\tarr[i + 2] = b1;\n\t\tarr[i + 3] = b0;\n\t}\n}\n\nfunction toLittleEndianBuffer(arr: Uint32Array): VSBuffer {\n\tconst uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\treturn VSBuffer.wrap(uint8Arr);\n}\n\nfunction fromLittleEndianBuffer(buff: VSBuffer): Uint32Array {\n\tconst uint8Arr = buff.buffer;\n\tif (!platform.isLittleEndian()) {\n\t\t// the byte order must be changed\n\t\treverseEndianness(uint8Arr);\n\t}\n\tif (uint8Arr.byteOffset % 4 === 0) {\n\t\treturn new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);\n\t} else {\n\t\t// unaligned memory access doesn't work on all platforms\n\t\tconst data = new Uint8Array(uint8Arr.byteLength);\n\t\tdata.set(uint8Arr);\n\t\treturn new Uint32Array(data.buffer, data.byteOffset, data.length / 4);\n\t}\n}\n\nexport function encodeSemanticTokensDto(semanticTokens: ISemanticTokensDto): VSBuffer {\n\tconst dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n\tlet offset = 0;\n\tdest[offset++] = semanticTokens.id;\n\tif (semanticTokens.type === 'full') {\n\t\tdest[offset++] = EncodedSemanticTokensType.Full;\n\t\tdest[offset++] = semanticTokens.data.length;\n\t\tdest.set(semanticTokens.data, offset); offset += semanticTokens.data.length;\n\t} else {\n\t\tdest[offset++] = EncodedSemanticTokensType.Delta;\n\t\tdest[offset++] = semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tdest[offset++] = delta.start;\n\t\t\tdest[offset++] = delta.deleteCount;\n\t\t\tif (delta.data) {\n\t\t\t\tdest[offset++] = delta.data.length;\n\t\t\t\tdest.set(delta.data, offset); offset += delta.data.length;\n\t\t\t} else {\n\t\t\t\tdest[offset++] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn toLittleEndianBuffer(dest);\n}\n\nfunction encodeSemanticTokensDtoSize(semanticTokens: ISemanticTokensDto): number {\n\tlet result = 0;\n\tresult += (\n\t\t+ 1 // id\n\t\t+ 1 // type\n\t);\n\tif (semanticTokens.type === 'full') {\n\t\tresult += (\n\t\t\t+ 1 // data length\n\t\t\t+ semanticTokens.data.length\n\t\t);\n\t} else {\n\t\tresult += (\n\t\t\t+ 1 // delta count\n\t\t);\n\t\tresult += (\n\t\t\t+ 1 // start\n\t\t\t+ 1 // deleteCount\n\t\t\t+ 1 // data length\n\t\t) * semanticTokens.deltas.length;\n\t\tfor (const delta of semanticTokens.deltas) {\n\t\t\tif (delta.data) {\n\t\t\t\tresult += delta.data.length;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function decodeSemanticTokensDto(_buff: VSBuffer): ISemanticTokensDto {\n\tconst src = fromLittleEndianBuffer(_buff);\n\tlet offset = 0;\n\tconst id = src[offset++];\n\tconst type: EncodedSemanticTokensType = src[offset++];\n\tif (type === EncodedSemanticTokensType.Full) {\n\t\tconst length = src[offset++];\n\t\tconst data = src.subarray(offset, offset + length); offset += length;\n\t\treturn {\n\t\t\tid: id,\n\t\t\ttype: 'full',\n\t\t\tdata: data\n\t\t};\n\t}\n\tconst deltaCount = src[offset++];\n\tlet deltas: { start: number; deleteCount: number; data?: Uint32Array; }[] = [];\n\tfor (let i = 0; i < deltaCount; i++) {\n\t\tconst start = src[offset++];\n\t\tconst deleteCount = src[offset++];\n\t\tconst length = src[offset++];\n\t\tlet data: Uint32Array | undefined;\n\t\tif (length > 0) {\n\t\t\tdata = src.subarray(offset, offset + length); offset += length;\n\t\t}\n\t\tdeltas[i] = { start, deleteCount, data };\n\t}\n\treturn {\n\t\tid: id,\n\t\ttype: 'delta',\n\t\tdeltas: deltas\n\t};\n}\n"]}